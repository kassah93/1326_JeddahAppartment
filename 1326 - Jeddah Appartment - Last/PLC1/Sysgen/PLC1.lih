{LIBFILE="LOCALLIB\STDLIB_V22_20180619.MLB"}
(* Mosaic IDE library *)
(* File name : C:\TecoLib\StdLib_V22_20180619.mlb *)
(* Library : StdLib 2.2 *)
(* Author : Teco a.s. *)
(* Copyright : (c) 2006-2018 Teco a.s. *)
(* IEC compiler version : 4.1.4.0 *)
(* Assembler version : 4.3.00 *)

//{Knihovna : StdLib 2.2  }
(* History: *)
(*
v1.0 2004-06-30 Nem  First edition
                     Blocks : R_TRIG, F_TRIG, SR, RS, TON, TOF, CTU, CTD, TP
v1.1 2004-08-09	Nem  Function block TOF corrected
v1.2 2004-09-06	Nem  New version of comments
v1.3 2005-05-16	Nem  New code for restart of TON/TOF/TP in the case
                     when timers are in retain area
v1.4            Nem  not used
v1.5 2005-11-01	Nem  Final version of hot restart TON/TOF/TP
                     Function blocks R_TRIG, F_TRIG, SR a RS rewritten in asm
v1.6 2005-11-07	Nem  Functions ADD_TIME, SUB_TIME, ADD_TOD_TIME,
                     ADD_DT_TIME, SUB_DATE_DATE, SUB_TOD_TIME, SUB_TOD_TOD,
                     SUB_DT_TIME, SUB_DT_DT a CONCAT_DATE_TOD added
v1.7 2006-03-17	Nem  Mask for TON/TOF/PT repaired
                     Function SUB_DT_DT repaired
v1.8 2006-04-04	Nem  Comments of TON, .... cutted (it is better for FBD)
v1.9 2008-09-29	Nem  Function block TOF completelly rewritten
v2.0 2009-02-25	Nem  When preset of TP is zero than there is no output puls
     2010-05-19	Nem  Czech comments added (Mosaic v2.0.23 and more)
     2010-10-27 Nem  English history version added
v2.1 2014-05-14	Nem  Rising edge of IN input is detected permanently
v2.2 2018-06-19	Nem  Added function IS_INVALID_REAL
*)

(*----------------------------------------------------------------------------*)

__DECL FUNCTION_BLOCK R_TRIG
(*Rising Edge Detector*)
  VAR_INPUT
    CLK              : bool;
  END_VAR
  VAR_OUTPUT
    Q                : bool;
  END_VAR
  VAR
    M                : bool;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK F_TRIG
(*Falling Edge Detector*)
  VAR_INPUT
    CLK              : bool;
  END_VAR
  VAR_OUTPUT
    Q                : bool;
  END_VAR
  VAR
    M                : bool :=  TRUE;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK SR
(*Flip-Flop (Set Dominant)*)
  VAR_INPUT
    S1               : bool;
    R                : bool;
  END_VAR
  VAR_OUTPUT
    Q1               : bool;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK RS
(*Flip-Flop (Reset Dominant)*)
  VAR_INPUT
    S                : bool;
    R1               : bool;
  END_VAR
  VAR_OUTPUT
    Q1               : bool;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK CTU
(*Up Counter*)
  VAR_INPUT
    CU               : bool R_EDGE;  (*up*)
    R                : bool;  (*reset*)
    PV               : int;  (*preset*)
  END_VAR
  VAR_OUTPUT
    Q                : bool;  (*output*)
    CV               : int;  (*value*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK CTD
(*Down Counter*)
  VAR_INPUT
    CD               : bool R_EDGE;  (*down*)
    LD               : bool;  (*load*)
    PV               : int;  (*preset*)
  END_VAR
  VAR_OUTPUT
    Q                : bool;  (*output*)
    CV               : int;  (*value*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK CTUD
(*Up-Down Counter*)
  VAR_INPUT
    CU               : bool R_EDGE;  (*up*)
    CD               : bool R_EDGE;  (*down*)
    R                : bool;  (*reset*)
    LD               : bool;  (*load*)
    PV               : int;  (*preset*)
  END_VAR
  VAR_OUTPUT
    QU               : bool;  (*up output*)
    QD               : bool;  (*down output*)
    CV               : int;  (*value*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK TON
(*On-delay Timer*)
  VAR_INPUT
    IN               : bool;  (*input*)
    PT               : time;  (*preset*)
  END_VAR
  VAR_OUTPUT
    Q                : bool;  (*output*)
    ET               : time;  (*value*)
  END_VAR
  VAR
    IN_r_edge        : R_TRIG;
    LT               : time;  (*last tick value ( 1ms resolution)*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK TOF
(*Off-delay Timer*)
  VAR_INPUT
    IN               : bool;  (*input*)
    PT               : time;  (*preset*)
  END_VAR
  VAR_OUTPUT
    Q                : bool;  (*output*)
    ET               : time;  (*value*)
  END_VAR
  VAR
    IN_f_edge        : F_TRIG;
    LT               : time;  (*last tick value ( 1ms resolution)*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK TP
(*Pulse Timer*)
  VAR_INPUT
    IN               : bool;  (*input*)
    PT               : time;  (*preset*)
  END_VAR
  VAR_OUTPUT
    Q                : bool;  (*output*)
    ET               : time;  (*value*)
  END_VAR
  VAR
    IN_r_edge        : R_TRIG;
    LT               : time;  (*last tick value ( 1ms resolution)*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION IS_INVALID_REAL : bool
(*Returns TRUE if the value of num is NaN, +INF or -INF*)
  VAR_INPUT
    num              : real;
  END_VAR
END_FUNCTION

__DECL FUNCTION ADD_TIME : time
(*------------------------------------------------------------------------------
  TIME := TIME + TIME;*)
  VAR_INPUT
    IN1              : time;
    IN2              : time;
  END_VAR
END_FUNCTION

__DECL FUNCTION SUB_TIME : time
(*------------------------------------------------------------------------------
  TIME := TIME - TIME;*)
  VAR_INPUT
    IN1              : time;
    IN2              : time;
  END_VAR
END_FUNCTION

__DECL FUNCTION ADD_TOD_TIME : tod
(*------------------------------------------------------------------------------
  TIME_OF_DAY := TIME_OF_DAY + TIME;*)
  VAR_INPUT
    IN1              : tod;
    IN2              : time;
  END_VAR
END_FUNCTION

__DECL FUNCTION ADD_DT_TIME : dt
(*------------------------------------------------------------------------------
  DATE_AND_TIME := DATE_AND_TIME + TIME;*)
  VAR_INPUT
    IN1              : dt;
    IN2              : time;
  END_VAR
END_FUNCTION

__DECL FUNCTION SUB_DATE_DATE : time
(*------------------------------------------------------------------------------
  TIME := DATE - DATE;*)
  VAR_INPUT
    IN1              : date;
    IN2              : date;
  END_VAR
END_FUNCTION

__DECL FUNCTION SUB_TOD_TIME : tod
(*------------------------------------------------------------------------------
  TIME_OF_DAY := TIME_OF_DAY - TIME;*)
  VAR_INPUT
    IN1              : tod;
    IN2              : time;
  END_VAR
END_FUNCTION

__DECL FUNCTION SUB_TOD_TOD : time
(*------------------------------------------------------------------------------
  TIME := TIME_OF_DAY - TIME_OF_DAY;*)
  VAR_INPUT
    IN1              : tod;
    IN2              : tod;
  END_VAR
END_FUNCTION

__DECL FUNCTION SUB_DT_TIME : dt
(*------------------------------------------------------------------------------
  DATE_AND_TIME := DATE_AND_TIME - TIME;*)
  VAR_INPUT
    IN1              : dt;
    IN2              : time;
  END_VAR
END_FUNCTION

__DECL FUNCTION SUB_DT_DT : time
(*------------------------------------------------------------------------------
  TIME := DATE_AND_TIME - DATE_AND_TIME;*)
  VAR_INPUT
    IN1              : dt;
    IN2              : dt;
  END_VAR
END_FUNCTION

__DECL FUNCTION CONCAT_DATE_TOD : dt
(*------------------------------------------------------------------------------
  DATE_AND_TIME := DATE + TIME_OF_DAY;*)
  VAR_INPUT
    IN1              : date;
    IN2              : tod;
  END_VAR
END_FUNCTION



{LIBFILE="LOCALLIB\SYSLIB_V41_20190710.MLB"}
(* Mosaic IDE library *)
(* File name : D:\MosaicLib\SysLib_V41_20190710.mlb *)
(* Library : SysLib 4.1 *)
(* Author : Teco a.s. Kolin *)
(* Copyright : (c) 2004-2019 Teco a.s. *)
(* IEC compiler version : 4.2.4.0 *)
(* Assembler version : 4.3.00 *)

//{Knihovna : SysLib 4.1  }
(* History: *)
(*
v1.0 2004-09-01 Nem First edition
v1.1 2004-09-16 Nem New funtions : memcpy(),
                    SetSummerTime(), IsSummerTime(), SetWinterTime(), IsWinterTime()
v1.2 2005-05-16 Nem New funtions : GetDate(), GetTime(), GetDateTime(), GetRTC(), 
                    SetRTC()
                    System registers declared as a structure
v1.3 2005-11-10 Nem New funtions : TecoDT_TO_DT() and DT_TO_TecoDT()
v1.4 2007-11-17 Nem New funtion : Memset()
v1.5 2008-01-17 Nem New funtions : IncreaseMaxCycleTime()
v1.6 2008-08-18 Nem Change parameters order VAR_INPUT and VAR_IN_OUT
                    in functions Memset() and Memcpy() - it is better for LD 
                    language
v1.7 2009-02-20 Nem New functions : Get_IP_address() and Set_IP_address() for Eth1
v1.8 2009-03-10 Nem Funtion Get_IP_address() replaced by function GetIPaddress() and 
                    moved to ComLib
                    Funtion Set_IP_address() replaced by function SetIPaddress() and 
                    moved to ComLib
v1.9 2009-10-22 Nem New funtions : CIBunitInfo() and SetCIBunitAddress()
                    and new data types TCIBunitState a TCIBunitInfo
v2.0 2009-11-20 Nem New funtion : ProgramLock()
v2.1 2009-12-16 Nem New funtions : function block fbTick() and function Memcmp()
v2.2 2010-01-18 Nem Corrected coding of CIB master and new code for master 0 
                   (MI0_CIB1 a MI0_CIB2)
v2.3 2010-05-06 Nem New funtions : SetWebPSW() and VerifyWebPSW()
v2.4 2010-08-16 Nem New funtions : SystemDisplayBacklightOn() and 
                    SystemDisplayBacklightOff()
v2.5 2010-09-02 Nem Dependency on the libraries added
     2010-09-15 Nem Function SetRTC returns TRUE when date and time is succesfully 
                    written to RTC device
v2.6 2011-01-19 Nem New funtions : RFunitInfo() and SetRFunitAddress()
v2.7 2011-06-30 Nem New funtion block : fbBondRFunit()
v2.8 2011-11-02 Nem New funtion blocks : memcpyEx(), memsetEx() and memcmpEx()
v2.9 2011-12-02 Nem New funtions : SetWebMAC() and VerifyWebMAC()
v3.0 2012-04-27 Nem New funtion block TPR() and completed declaration of SystemS
v3.1 2012-06-21 Nem Block TPR replaced by block fbTPR() - RESET input has high 
                    priority
                    Corrected declaration of structure SystemS 
                    (added CPU_DI and CPU_DO)
v3.2 2013-03-22 Nem Restored block TPR from version 3.0 (backward compatibility)
                    New funtion : ProgramIsChanged()
v3.3 2013-06-21 Nem Fixed bug in ProgramIsChanged() in case of on-line change
                    New funtions :  ReInitPLC_hotRestart(), ReInitPLC_coldRestart()
                    and ReInitPLC_noRestart() - it requires Foxtrot FW v7.8 
                    minimally
v3.4 2014-10-03 Nem New function : GetModuleID() and type T_RGB_COLOR
v3.5 2015-04-16 Nem New function : MemcpyPtr()
v3.6 2015-12-14 Nem New function : GetVarValueByName() a SetVarValueByName()
v3.7 2016-06-27 Nem New function : GetVarNameByAdr()
v3.8 2016-11-21 Nem Added funtions ReInitPLC_hotRestartX(), ReInitPLC_coldRestartX()
                    ReInitPLC_noRestartX() and function block fbIOSystemDiag- it requires Foxtrot FW v9.9 minimally
     2017-09-07 Nem Added funtions SetWebLevel() and VerifyWebLevel() 
v3.9 2018-06-01 Nem Added function blocks fbLoadRemFromFile() a fbSaveRemToFile()
                    (for Foxtrot II only)
v4.0 2018-12-04 Nem Added function MemcpyPtr0()
v4.1 2019-07-10 Nem Added functions CIBunitInfo2() and SetAddressCIBunit2() for Foxtrot 2
*)

(*----------------------------------------------------------------------------*)

TYPE T_RGB_COLOR :
  STRUCT
    red              : usint;  (*red color <0..255>*)
    green            : usint;  (*green color <0..255>*)
    blue             : usint;  (*blue color <0..255>*)
    opacity          : usint;  (*opacity (0 = opaque, 255 = transparent)*)
  END_STRUCT;
END_TYPE

TYPE TSYSTEM_S :
  STRUCT
    S0               : byte;  (*flags of the results of arithmetic operations *)
    S1               : byte;  (*flags of the results of logical operations *)
    S2_0             : bool;
    S2_1             : bool;
    S2_2             : bool;  (*PLC is running*)
    S2_3             : bool;  (*HOT restart*)
    S2_4             : bool;  (*COLD restart*)
    OUTPUTS_ARE_ENABLED : bool;  (*PLC outputs are enabled*)
    S2_6             : bool;  (*RUN without restart*)
    CYCLE_TIME_WARNING : bool;  (*Cycle time warning*)
    LAST_CYCLE_TIME_10MS : usint;  (*Last cycle time [x10 milisecond]*)
    CYCLE_COUNTER    : usint;  (*Cycle counter*)
    COUNTER_10MS     : usint;  (*10 miliseconds counter*)
    COUNTER_SECONDS  : usint;  (*second counter*)
    COUNTER_MINUTES  : usint;  (*minute counter*)
    COUNTER_HOURS    : usint;  (*hour counter*)
    COUNTER_DAYS_OF_WEEK : usint;  (*day of week*)
    COUNTER_DAYS_OF_MONTH : usint;  (*day*)
    COUNTER_MONTHS   : usint;  (*month*)
    COUNTER_YEARS    : usint;  (*year*)
    PERIOD_PULSE_100MS : bool;  (*100 ms periodic pulse*)
    PERIOD_PULSE_500MS : bool;  (*500 ms periodic pulse*)
    PERIOD_PULSE_1SEC : bool;  (*1 s periodic pulse*)
    PERIOD_PULSE_10SEC : bool;  (*10 s periodic pulse*)
    PERIOD_PULSE_1MIN : bool;  (*1 min periodic pulse*)
    PERIOD_PULSE_10MIN : bool;  (*10 min periodic pulse*)
    PERIOD_PULSE_1HOUR : bool;  (*1 hour periodic pulse*)
    PERIOD_PULSE_1DAY : bool;  (*1 day periodic pulse*)
    COUNTER_100MS    : uint;  (**)
    COUNTER_1SEC     : uint;  (**)
    COUNTER_10SEC    : uint;  (**)
    R_EDGE_100MS     : bool;  (**)
    R_EDGE_500MS     : bool;  (**)
    R_EDGE_1SEC      : bool;  (**)
    R_EDGE_10SEC     : bool;  (**)
    R_EDGE_1MIN      : bool;  (**)
    R_EDGE_10MIN     : bool;  (**)
    R_EDGE_1HOUR     : bool;  (**)
    R_EDGE_1DAY      : bool;  (**)
    F_EDGE_100MS     : bool;  (**)
    F_EDGE_500MS     : bool;  (**)
    F_EDGE_1SEC      : bool;  (**)
    F_EDGE_10SEC     : bool;  (**)
    F_EDGE_1MIN      : bool;  (**)
    F_EDGE_10MIN     : bool;  (**)
    F_EDGE_1HOUR     : bool;  (**)
    F_EDGE_1DAY      : bool;  (**)
    LAST_CYCLE_TIME_100US : uint;  (*Last cycle time [x100 microsecond]*)
    S24              : byte;  (*control masks for PLC processes*)
    S25              : byte;  (*control masks for PLC processes*)
    S26              : byte;  (*control masks for PLC processes*)
    S27              : byte;  (*control masks for PLC processes*)
    S28              : byte;  (*control masks for PLC processes*)
    S29              : byte;  (*control masks for PLC processes*)
    S30              : byte;  (*reserved*)
    S31              : byte;  (*reserved*)
    S32              : byte;  (*reserved*)
    S33              : byte;  (*reserved*)
    S34              : byte;  (*main code of PLC error*)
    BAT_ERR          : bool;  (*Backup baterry error*)
    S35_1            : bool;  (*reserved*)
    S35_2            : bool;  (*reserved*)
    S35_3            : bool;  (*reserved*)
    S35_4            : bool;  (*reserved*)
    S35_5            : bool;  (*reserved*)
    IS_SUMMER_TIME   : bool;  (*Summer time indication*)
    SUMMER_TIME_REQUEST : bool;  (**)
    CPU_TEMPERATURE  : usint;  (*CPU temperature [Celsius degree]*)
    S37              : byte;
    S38              : byte;
    S39              : byte;
    S40              : byte;
    S41              : byte;
    S42              : byte;
    S43              : byte;
    S44              : byte;
    S45              : byte;
    S46              : byte;
    S47              : byte;
    S48              : byte;
    S49              : byte;
    S50              : byte;
    S51              : byte;
    COUNTER_1MS      : udint;  (*1 ms counter*)
    S56              : byte;
    S57              : byte;
    CPU_DI           : byte;  (*inputs serviced by CPU*)
    CPU_DO           : byte;  (*outputs serviced by CPU*)
    INDEX_OF_RETAIN_ZONE : udint;  (*address of retain zone (index of %R)*)
    SIZE_OF_RETAIN_ZONE : udint;  (*size of retain zone (number of bytes)*)
    INDEX_SOFT_PLC_STRUCT : uint;  (*reserved for SoftPLC*)
    CRC_OF_USER_PROGRAM : word;  (*CRC of user program*)
    CRC_OF_HEADER_PROGRAM : word;  (*CRC of header of user program*)
  END_STRUCT;
END_TYPE

VAR_GLOBAL
 System_S AT %S0 : TSYSTEM_S;
 IS_HOT_RESTART_PLC AT System_S.S2_3 : bool;  (*HOT restart*)
 IS_COLD_RESTART_PLC AT System_S.S2_4 : bool;  (*COLD restart*)
 IS_RESTART_PLC AT System_S.S2_6 : bool;  (*RUN without restart*)
 CRC_OF_APLIC_PROGRAM AT System_S.CRC_OF_USER_PROGRAM : dword;  (*CRC of aplic program*)

END_VAR

TYPE TModuleInfo :
  STRUCT
    ECOM             : bool;  (*communication module <=> CPU : 0 ... communication is OK, 1 ... ERROR*)
    DATA             : bool;  (*data validity                : 0 ... module data are not valid, 1 ... OK*)
    DUMMY1           : bool;  (*not used*)
    DUMMY2           : bool;  (*not used*)
    ERR              : bool;  (*I/O module error             : 0 ... module is OK, 1 ... module has a problem*)
    DEC              : bool;  (*module declaration           : 0 ... module is not declared in user program*)
    OTH              : bool;  (*check module type            : 0 ... declared and exist module is the same*)
    POS              : bool;  (*position                     : 0 ... position is free, 1 ... module is present*)
    STAT             : usint;  (*collection all previous bits*)
  END_STRUCT;
END_TYPE

TYPE TIOSystemInfo :
  STRUCT
    err              : bool;  (*0 ... all I/O modules are OK, 1 ... any module has error*)
    rackNumber       : usint;  (*if err=1 then rack number where module is plugged*)
    position         : usint;  (*if err=1 then position number where module is plugged*)
  END_STRUCT;
END_TYPE

VAR_GLOBAL CONSTANT
 MODULE_AND_DATA_OK : usint :=  16#A2;

END_VAR

__DECL FUNCTION ModuleInfo : TModuleInfo
(*Get information about I/O module (Foxtrot 1 only)
   Function returns info about one I/O module.
   You can use this function if module can be removed on time*)
  VAR_INPUT
    rackNumber       : usint;  (*rack number where module is plugged*)
    position         : usint;  (*position number where module is plugged*)
  END_VAR
END_FUNCTION

__DECL FUNCTION ModuleInfo2 : TModuleInfo
(*Get information about I/O module (for Foxtrot 2 only)
   Function returns info about one I/O module.
   You can use this function if module can be removed on time*)
  VAR_INPUT
    Bus_ID           : udint;  (*bus ID number (TCL2 = 16#1020, ...)*)
    Unit_ID          : usint;  (*address of unit on the bus (0,...,63)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION IOSystemInfo : TIOSystemInfo
(*Get state of PLC I/O system on TCL2 bus (Foxtrot 1 only)

   Function returns info about I/O system on TCL2 bus
   Function is designed for monitoring of modules that can be removed online

   If any module on TCL2 bus has an error,
   err flag is true and position and rack number are set*)
END_FUNCTION

__DECL FUNCTION Memcpy : uint
(*Copy memory
  Function copies a block of n bytes from source to dest
  Function returns number of copied bytes*)
  VAR_INPUT
    length           : uint;  (*number of bytes*)
  END_VAR
  VAR_IN_OUT
    source           : usint;  (*source*)
    dest             : usint;  (*destination*)
  END_VAR
END_FUNCTION

__DECL FUNCTION MemcpyEx : uint
(*Copy memory
  Function copies a block of n bytes from source+offsetSource to dest+offsetDest
  Function returns number of copied bytes*)
  VAR_INPUT
    length           : udint;  (*number of bytes*)
    offSource        : udint;  (*offset in source*)
    offDest          : udint;  (*offset in destination*)
  END_VAR
  VAR_IN_OUT
    source           : usint;  (*source*)
    dest             : usint;  (*destination*)
  END_VAR
END_FUNCTION

__DECL FUNCTION MemcpyPtr : udint
(*Function MemcpyPtr copies a block of n bytes from source to dest.
  Function returns number of copied bytes.*)
  VAR_INPUT
    source           : PTR_TO usint;  (*pointer to source*)
    dest             : PTR_TO usint;  (*pointer to  destination*)
    length           : udint;  (*number of bytes*)
  END_VAR
END_FUNCTION

__DECL FUNCTION MemcpyPtr0 : udint
(*Function MemcpyPtr0 copies a block of n bytes from source to dest.
  Function returns number of copied bytes.
  One byte with value with binary zero is written behind the copied block
  (end of string).*)
  VAR_INPUT
    source           : PTR_TO usint;  (*pointer to source*)
    dest             : PTR_TO usint;  (*pointer to  destination*)
    length           : udint;  (*number of bytes*)
  END_VAR
END_FUNCTION

__DECL FUNCTION Memset : bool
(*Set memory
  This function fills the first length bytes of the array pointed to by dest to the value
  Function returns true if succesfull*)
  VAR_INPUT
    val              : udint;  (*filling value*)
    length           : uint;  (*number of bytes to be filled*)
  END_VAR
  VAR_IN_OUT
    dest             : usint;  (*destination*)
  END_VAR
END_FUNCTION

__DECL FUNCTION MemsetEx : bool
(*Set memory
  This function fills the first length bytes of the array pointed to by dest+offDest to the value
  Function returns true if succesfull*)
  VAR_INPUT
    val              : udint;  (*filling value*)
    length           : udint;  (*number of bytes to be filled*)
    offDest          : udint;  (*offset in destination*)
  END_VAR
  VAR_IN_OUT
    dest             : usint;  (*destination*)
  END_VAR
END_FUNCTION

__DECL FUNCTION Memcmp : bool
(*Compare memory
  Function compares a block of n bytes between in1 and in2
  Function returns TRUE if in1 is equal in2*)
  VAR_INPUT
    length           : uint;  (*number of bytes*)
  END_VAR
  VAR_IN_OUT
    in1              : usint;  (*first data block*)
    in2              : usint;  (*second data block*)
  END_VAR
END_FUNCTION

__DECL FUNCTION MemcmpEx : bool
(*Compare memory
  Function compares a block of n bytes between in1+offIn1 and in2+offIn2
  Function returns TRUE if blocks are equal*)
  VAR_INPUT
    length           : udint;  (*number of bytes*)
    offIn1           : udint;  (*offset in first data block*)
    offIn2           : udint;  (*offset in second data block*)
  END_VAR
  VAR_IN_OUT
    in1              : usint;  (*first data block*)
    in2              : usint;  (*second data block*)
  END_VAR
END_FUNCTION

__DECL FUNCTION IncreaseMaxCycleTime : bool
(*Increase max limit for PLC scan time

   Use IncreaseMaxCycleTime to increase max limit for PLC scan time in current scan*)
  VAR_INPUT
    addTime          : uint;  (*milisec*)
  END_VAR
END_FUNCTION

TYPE TTecoDateTime :
  STRUCT
    year             : usint;  (*last two numbers*)
    month            : usint;  (*1 .. 12*)
    day              : usint;  (*1 .. 28/29/30/31*)
    hour             : usint;  (*0 .. 23*)
    min              : usint;  (*0 .. 59*)
    sec              : usint;  (*0 .. 59*)
    dayOfWeek        : usint;  (*1 = Monday .. 7 = Sunday*)
    milisec          : uint;  (*0 .. 999*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION SetSummerTime : bool
(*Set Automatic Daylight Saving Time
  Set request for automatic changing between summer and winter time*)
END_FUNCTION

__DECL FUNCTION IsSummerTime : bool
(*Test of summer time
  Test if is summer time now*)
END_FUNCTION

__DECL FUNCTION SetWinterTime : bool
(*Disable Automatic Daylight Saving Time
  Reset request for automatic changing between summer and winter time*)
END_FUNCTION

__DECL FUNCTION IsWinterTime : bool
(*Test of winter time
  Test if is winter time now*)
END_FUNCTION

__DECL FUNCTION GetDate : date
(*Get actual system date*)
  VAR
    tmp              : TTecoDateTime;
  END_VAR
END_FUNCTION

__DECL FUNCTION GetTime : time
(*Get actual system time*)
  VAR
    milisec          : uint;
  END_VAR
END_FUNCTION

__DECL FUNCTION GetDateTime : dt
(*Get actual system date and time*)
  VAR
    tmp              : TTecoDateTime;
  END_VAR
END_FUNCTION

__DECL FUNCTION GetRTC : dt
(*Get actual date and time from RTC device directly*)
  VAR
    tmp              : TTecoDateTime;
  END_VAR
END_FUNCTION

__DECL FUNCTION SetRTC : bool
(*Set new date and time of PLC
  Function sets new actual date and time to RTC device*)
  VAR_INPUT
    PDT              : dt;  (*new date and time*)
  END_VAR
  VAR
    tmp              : TTecoDateTime;
  END_VAR
END_FUNCTION

__DECL FUNCTION TecoDT_TO_DT : dt
(*Convert structure TTecoDateTime to type DATE_AND_TIME*)
  VAR_INPUT
    Teco_DT          : TTecoDateTime;  (*date and time*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DT_TO_TecoDT : TTecoDateTime
(*Convert DATE_AND_TIME to structure TTecoDateTime*)
  VAR_INPUT
    IEC_DT           : dt;  (*date and time*)
  END_VAR
END_FUNCTION

__DECL FUNCTION memory_for_ProgramIsChanged {HIDDEN} : bool
  VAR_INPUT
    saveSL70         : bool;
    memSL70          : udint;
    memS4            : usint;
  END_VAR
END_FUNCTION

__DECL FUNCTION ProgramIsChanged : bool
(*Function returns TRUE in case of restart of PLC program or
        when program is changed on-line*)
  VAR
    saveSL70         : bool;
    memSL70          : udint;
    memS4            : usint;
  END_VAR
END_FUNCTION

__DECL FUNCTION ReInitPLC_hotRestart : bool
(*Function for initialization the PLC
  As a first step PLC goes to HALT mode. PLC outputs are blocked.
  Processing of application program is stopped.
  After that warm restart is executed and PLC goes to RUN mode.
  IO system is completely reinitialized.
  Values of RETAIN variables are unchanged,
  all others variables are initialized*)
  VAR_INPUT
    rq               : bool;  (*1 = request for reinitialization of PLC*)
  END_VAR
END_FUNCTION

__DECL FUNCTION ReInitPLC_coldRestart : bool
(*Function for initialization the PLC
  As a first step PLC goes to HALT mode. PLC outputs are blocked.
  Processing of application program is stopped.
  After that cold restart is executed and PLC goes to RUN mode.
  IO system is completely reinitialized.
  All variables are initialized.*)
  VAR_INPUT
    rq               : bool;  (*request for reinitialization of PLC*)
  END_VAR
END_FUNCTION

__DECL FUNCTION ReInitPLC_noRestart : bool
(*Function for initialization the PLC
  As a first step PLC goes to HALT mode. PLC outputs are blocked.
  Processing of application program is stopped.
  After that PLC goes to RUN mode.
  IO system is completely reinitialized.
  All variables are unchanged.*)
  VAR_INPUT
    rq               : bool;  (*request for reinitialization of PLC*)
  END_VAR
END_FUNCTION

__DECL FUNCTION ReInitPLC_hotRestartX : bool
(*Function for initialization the PLC with loading of new code from file
  The function first confirm that there are files whose names are listed
  in the table and code parameters. If so, the function returns TRUE and
  PLC completes the currently executing program cycle.
  Then PLC goes into HALT mode and PLC outputs are disabled.
  Processing of application program is stopped!
  Then downloads the new program code from the file (including tables)
  and PLC makes all the necessary checks of the new code.
  When checks reveal a problem, the PLC reads back the original code from EEPROM.
  If the code is ok and input EEPROM = TRUE so new code is programmed into the EEPROM.
  After that warm restart is executed and PLC goes to RUN mode.
  IO system is completely reinitialized.
  Values of RETAIN variables are unchanged,
  all others variables are initialized*)
  VAR_INPUT
    rq               : bool;  (*1 = request for reinitialization of PLC*)
    eeprom           : bool;  (*1 = request for programming of new code into EEPROM*)
    code             : string [80];  (*file name of program code*)
    table            : string [80];  (*file name of program tables*)
  END_VAR
END_FUNCTION

__DECL FUNCTION ReInitPLC_coldRestartX : bool
(*Function for initialization the PLC with loading of new code from file
  The function first confirm that there are files whose names are listed
  in the table and code parameters. If so, the function returns TRUE and
  PLC completes the currently executing program cycle.
  Then PLC goes into HALT mode and PLC outputs are disabled.
  Processing of application program is stopped!
  Then downloads the new program code from the file (including tables)
  and PLC makes all the necessary checks of the new code.
  When checks reveal a problem, the PLC reads back the original code from EEPROM.
  If the code is ok and input EEPROM = TRUE so new code is programmed into the EEPROM.
  After that cold restart is executed and PLC goes to RUN mode.
  IO system is completely reinitialized.
  All variables are initialized.*)
  VAR_INPUT
    rq               : bool;  (*request for reinitialization of PLC*)
    eeprom           : bool;  (*1 = request for programming of new code into EEPROM*)
    code             : string [80];  (*file name of program code*)
    table            : string [80];  (*file name of program tables*)
  END_VAR
END_FUNCTION

__DECL FUNCTION ReInitPLC_noRestartX : bool
(*Function for initialization the PLC with loading of new code from file
  The function first confirm that there are files whose names are listed
  in the table and code parameters. If so, the function returns TRUE and
  PLC completes the currently executing program cycle.
  Then PLC goes into HALT mode and PLC outputs are disabled.
  Processing of application program is stopped!
  Then downloads the new program code from the file (including tables)
  and PLC makes all the necessary checks of the new code.
  When checks reveal a problem, the PLC reads back the original code from EEPROM.
  If the code is ok and input EEPROM = TRUE so new code is programmed into the EEPROM.
  After that PLC goes to RUN mode. IO system is completely reinitialized.
  All variables are unchanged.*)
  VAR_INPUT
    rq               : bool;  (*request for reinitialization of PLC*)
    eeprom           : bool;  (*1 = request for programming of new code into EEPROM*)
    code             : string [80];  (*file name of program code*)
    table            : string [80];  (*file name of program tables*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GetModuleID : string [40]
(*Returns identification string from 32 to 36 characters according to module type (for Foxtrot 1 only)*)
  VAR_INPUT
    rackNumber       : usint;  (*rack number where module is plugged*)
    position         : usint;  (*position number where module is plugged*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GetVarValueByName : string [255]
(*Returns value of variable according to name of variable*)
  VAR_INPUT
    varName          : string [255];  (*full name of variable (name of instance)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GetVarNameByAdr : string [255]
(*Returns name of variable according to address of variable*)
  VAR_IN_OUT
    varAdr           : byte;  (*variable (name of instance)*)
  END_VAR
  VAR_INPUT
    varSize          : udint;  (*size of variable (number of bytes)*)
  END_VAR
END_FUNCTION

TYPE T_VAR_DESC :
  STRUCT
    addr             : udint;
    size             : udint;
    typ              : usint;
    isArray          : bool;
  END_STRUCT;
END_TYPE

__DECL FUNCTION GetVarDescByName : T_VAR_DESC
(*Returns description of variable according to name of variable*)
  VAR_INPUT
    varName          : string [255];  (*full name of variable (name of instance)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SetVarValueByName : bool
(*Set value of variable according to name of variable*)
  VAR_INPUT
    varName          : string [255];  (*full name of variable (name of instance)*)
    varValue         : string [255];  (*new value of variable*)
  END_VAR
END_FUNCTION

VAR_GLOBAL CONSTANT
 MI_CIB1 : usint :=  1;  (*internal Foxtrot CIB line*)
 MI_CIB2 : usint :=  2;
 MI0_CIB1 : usint :=  3;  (*external CIB master, address 0, CIB line 1*)
 MI0_CIB2 : usint :=  4;  (*external CIB master, address 0, CIB line 2*)
 MI2_CIB1 : usint :=  5;  (*external CIB master, address 2, CIB line 1*)
 MI2_CIB2 : usint :=  6;  (*external CIB master, address 2, CIB line 2*)
 MI4_CIB1 : usint :=  7;  (*external CIB master, address 4, CIB line 1*)
 MI4_CIB2 : usint :=  8;  (*external CIB master, address 4, CIB line 2*)
 MI6_CIB1 : usint :=  9;  (*external CIB master, address 6, CIB line 1*)
 MI6_CIB2 : usint :=  10;  (*external CIB master, address 6, CIB line 2*)
 MI_RF : usint :=  100;  (*internal Foxtrot RF line*)
 RF0_RF : usint :=  101;  (*external RF master, address 0*)
 RF2_RF : usint :=  102;  (*external RF master, address 2*)
 RF4_RF : usint :=  103;  (*external RF master, address 4*)
 RF6_RF : usint :=  104;  (*external RF master, address 6*)

END_VAR

TYPE TCIBunitState :
  STRUCT
    INI              : bool;  (*CIB unit is initialized*)
    COM              : bool;  (*communication with CIB unit is OK*)
    ADDR             : bool;  (*CIB unit address was accepted*)
    DUMMY3 {HIDDEN}  : bool;
    REI              : bool;  (*reinitialization of CIB unit*)
    DUMMY5 {HIDDEN}  : bool;
    ALT              : bool;  (*changed when new data is available (Foxtrot 2 only)*)
    NET              : bool;  (*CIB unit is defined and served by CPU*)
  END_STRUCT;
END_TYPE

TYPE TCIBunitInfo :
  STRUCT
    line_defined     : bool;  (*CIB line defined*)
    unit_defined     : bool;  (*CIB unit defined*)
    state            : TCIBunitState;  (*CIB unit state*)
    address          : word;  (*CIB unit address*)
    code             : word;  (*CIB unit code*)
    unit_type        : string [17];  (*CIB unit type*)
    description      : string [31];  (*CIB unit description*)
  END_STRUCT;
END_TYPE

TYPE TRFunitState :
  STRUCT
    INI              : bool;  (*RF unit is initialized*)
    COM              : bool;  (*communication with RF unit is OK*)
    DUMMY2 {HIDDEN}  : bool;
    DUMMY3 {HIDDEN}  : bool;
    DUMMY4 {HIDDEN}  : bool;
    SLP              : bool;  (*sleep mode is available*)
    BND              : bool;  (*unit is paired*)
    NET              : bool;  (*RF unit is defined and served by CPU*)
  END_STRUCT;
END_TYPE

TYPE TRFunitInfo :
  STRUCT
    line_defined     : bool;  (*RF line defined*)
    unit_defined     : bool;  (*RF unit defined*)
    state            : TRFunitState;  (*RF unit state*)
    address          : word;  (*RF unit address*)
    code             : word;  (*RF unit code*)
    unit_type        : string [17];  (*RF unit type*)
    description      : string [31];  (*RF unit description*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION CIBunitInfo : bool
(*Get state of CIB unit (Foxtrot 1 only)

  Function returns information about CIB unit
  When function is succesful, return value is TRUE*)
  VAR_INPUT
    CIB_line         : usint;  (*CIB line number (see constant MI_CIB1,...,MI6_CIB2)*)
    CIB_unitID       : usint;  (*CIB position number (1,...,32)*)
  END_VAR
  VAR_IN_OUT
    unitInfo         : TCIBunitInfo;  (*variable with information about CIB unit*)
  END_VAR
END_FUNCTION

__DECL FUNCTION CIBunitInfo2 : bool
(*Get state of CIB unit (Foxtrot 2 only)

  Function returns information about CIB unit
  When function is succesful, return value is TRUE*)
  VAR_INPUT
    Bus_ID           : udint;  (*bus ID number*)
    CIB_unitID       : usint;  (*logical address of CIB unit (0,...,31)*)
  END_VAR
  VAR_IN_OUT
    unitInfo         : TCIBunitInfo;  (*variable with information about CIB unit*)
  END_VAR
END_FUNCTION

__DECL FUNCTION RFunitInfo : bool
(*Get state of RF unit (Foxtrot 1 only)

  Function returns information about RF unit
  When function is succesful, return value is TRUE*)
  VAR_INPUT
    RF_line          : usint;  (*RF line number (see constant MI_RF, RF0_RF,...,RF6_RF)*)
    RF_unitID        : usint;  (*RF position number (1,...,64)*)
  END_VAR
  VAR_IN_OUT
    unitInfo         : TRFunitInfo;  (*variable with information about RF unit*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SetAddressCIBunit : bool
(*Set new address of CIB unit (Foxtrot 1 only)
  Function sets new address of CIB unit
  When function is succesful, return value is TRUE*)
  VAR_INPUT
    CIB_line         : usint;  (*CIB line number (see constant MI_CIB1,...,MI6_CIB2)*)
    CIB_unitID       : usint;  (*CIB position number (1,...,32)*)
    CIB_addr         : word;  (*new address of CIB unit*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SetAddressCIBunit2 : bool
(*Set new address of CIB unit (Foxtrot 2 only)
  Function sets new address of CIB unit
  When function is succesful, return value is TRUE*)
  VAR_INPUT
    Bus_ID           : udint;  (*bus ID number*)
    CIB_unitID       : usint;  (*logical address of CIB unit (0,...,31)*)
    CIB_addr         : word;  (*new HW address of CIB unit*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SetAddressRFunit : bool
(*Set new address of RF unit (Foxtrot 1 only)
  Function sets new address of RF unit
  When function is succesful, return value is TRUE*)
  VAR_INPUT
    RF_line          : usint;  (*RF line number (see constant MI_RF, RF0_RF,...,RF6_RF)*)
    RF_unitID        : usint;  (*RF position number (1,...,64)*)
    RF_addr          : word;  (*new address of RF unit*)
  END_VAR
END_FUNCTION

TYPE TBondStat {HIDDEN} :
  STRUCT  (*status bondovani*)
    disconnect       : bool;  (*probiha odbondovani*)
    connect          : bool;  (*probiha bondovani*)
    bondMap          : bool;  (*probiha cteni bondovaci mapy*)
    dummy3           : bool;
    dummy4           : bool;
    error            : bool;  (*doslo k chybe*)
    done             : bool;  (*hotovo*)
    busy             : bool;  (*master zaneprazdnen*)
  END_STRUCT;
END_TYPE

TYPE TBondInfo {HIDDEN} :
  STRUCT  (*informace, kterou vraci instrukce SYS 79*)
    bondStat         : TBondStat;
    bondID           : usint;  (*cislo pozice pribondovane jednotky (je-li bondovani uspesne)*)
    bondType         : word;  (*typ pribondovane jednotky (je-li bondovani uspesne)*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK fbBondRFunit
(*Bond RF unit with RF master  (Foxtrot 1 only)
  Function block establish relation between RF unit and RF master
  This operation may take some time. During the action variable busy is set.
  If you can pair RF unit output variable done has the value TRUE
  and variable unitType contains string with type of unit and serial number.
  In other case variable err has value TRUE and variable errID contains error number.*)
  VAR_INPUT
    exec             : bool R_EDGE;  (*request to initiate action (rising edge)*)
    RF_line          : usint;  (*RF line number (see constant MI_RF, RF0_RF,...,RF6_RF)*)
    RF_unitID        : usint;  (*RF position number (1,...,64)*)
    bondRq           : bool;  (*0 = unbond unit only, 1 = bond new unit*)
    useRouter        : bool;  (*1 = after bonding communicate with unit through router*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*action is done*)
    busy             : bool;  (*action in progress*)
    err              : bool;  (*error flag*)
    errID            : udint;  (*error number*)
    unitType         : string [40];  (*unit type when action is successful*)
  END_VAR
  VAR
    result           : TBondInfo;
    timIN            : bool;
    timPT            : time :=  T#2s;
    tim              : TON;  (*odbondovat 2+2 s, pribondovat 12+2 s*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION ProgramLock : bool
(*Lock the application program  (for Foxtrot 1 only)
  Lock the user program (it can not be decompiled)*)
END_FUNCTION

__DECL FUNCTION_BLOCK TPR
(*Pulse Timer with RESET. Obsolete version! Please use fbTPR.*)
  VAR_INPUT
    IN               : bool;  (*input*)
    R                : bool;  (*reset*)
    PT               : time;  (*preset*)
  END_VAR
  VAR_OUTPUT
    Q                : bool;  (*output*)
    ET               : time;  (*value*)
  END_VAR
  VAR
    IN_r_edge        : R_TRIG;
    LT               : time;  (*last tick value ( 1ms resolution)*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbTPR
(*Pulse Timer with RESET*)
  VAR_INPUT
    IN               : bool;  (*input*)
    R                : bool;  (*reset*)
    PT               : time;  (*preset*)
  END_VAR
  VAR_OUTPUT
    Q                : bool;  (*output*)
    ET               : time;  (*value*)
  END_VAR
  VAR
    IN_r_edge        : R_TRIG;
    LT               : time;  (*last tick value ( 1ms resolution)*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbSaveRemToFile
(*At the leading edge of the input exec stores the contents of all RETAIN variables into the file.
   The file name is passed as an input parameter. Storing values may take several PLC cycles.
   The output busy is set during storage. The output done is set for one cycle at a time,
   when all variables are stored. If an error occurred while saving, the output err is set,
   the output errId contains the error code and the output errTxt contains a description of the error.
   ATTENTION !!! The block can be used only for central units of Foxtrot II*)
  VAR_INPUT
    exec             : bool R_EDGE;  (*save content of RETAIN variables into file*)
    fileName         : string [80];  (*file name*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*done*)
    busy             : bool;  (*busy*)
    err              : bool;  (*error*)
    errId            : int;  (*error code*)
    errTxt           : string [80];  (*error description*)
    percent          : real;  (*how many percent is processed*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbLoadRemFromFile
(*At the leading edge of the input exec retrieves the contents of all RETAIN variables from the file.
   The filename is passed as an input parameter, the file created by the function block fbSaveRemToFile() is expected.
   While loading is set the output busy, loading may take several PLC cycles.
   The output done is set for one cycle at the time all RETAIN variables are loaded.
   If an error occurred while loading, the output err is set,
   the output errId contains the error code and the output errTxt contains a description of the error.
   ATTENTION !!! The block can be used only for central units of Foxtrot II*)
  VAR_INPUT
    exec             : bool R_EDGE;  (*load content of RETAIN variables from file*)
    fileName         : string [80];  (*file name*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*done*)
    busy             : bool;  (*busy*)
    err              : bool;  (*error*)
    errId            : int;  (*error code*)
    errTxt           : string [80];  (*error description*)
    percent          : real;  (*how many percent is processed*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION SetWebPSW : bool
(*Set password for web access
   Function sets new username and password for PLC web pages*)
  VAR_INPUT
    user             : usint;  (*line number in table of users (0...9)*)
  END_VAR
  VAR_IN_OUT
    name             : string [80];  (*new user name*)
    password         : string [80];  (*new password*)
  END_VAR
END_FUNCTION

__DECL FUNCTION VerifyWebPSW : bool
(*Verify password for the website PLC
   Function verifies username and password for PLC web pages*)
  VAR_INPUT
    user             : usint;  (*line number in table of users (0...9)*)
  END_VAR
  VAR_IN_OUT
    name             : string [80];  (*user name*)
    password         : string [80];  (*password*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SetWebMAC : bool
(*Set MAC for web access
   Function sets new MAC address for PLC web pages*)
  VAR_INPUT
    user             : usint;  (*line number in table of users (0...9)*)
  END_VAR
  VAR_IN_OUT
    MAC              : string [80];  (*new MAC address ('00:11:22:33:44:55')*)
  END_VAR
END_FUNCTION

__DECL FUNCTION VerifyWebMAC : bool
(*Verify MAC for the website PLC
   Function verifies MAC address for PLC web pages access*)
  VAR_INPUT
    user             : usint;  (*line number in table of users (0...9)*)
  END_VAR
  VAR_IN_OUT
    MAC              : string [80];  (*MAC address ('00:11:22:33:44:55')*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SetWebLevel : bool
(*Set level for web access
   Function sets new level for PLC web pages*)
  VAR_INPUT
    user             : usint;  (*line number in table of users (0...9)*)
    level            : sint;  (*new level (-1,0,...,9)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION VerifyWebLevel : bool
(*Verify level for the website PLC
   Function verifies level for PLC web pages access*)
  VAR_INPUT
    user             : usint;  (*line number in table of users (0...9)*)
    level            : sint;  (*verified level (-1,0,...,9)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SystemDisplayBacklightOn : bool
(*Switch on the display backlight  system
   Function switch ON backlight of system LCD display.
   Function returns TRUE if LCD display is available.
   In other cases function returns FALSE.*)
  VAR
    tmp              : udint;
  END_VAR
END_FUNCTION

__DECL FUNCTION SystemDisplayBacklightOff : bool
(*Switch off the display backlight  system
   Function switch OFF backlight of system LCD display.
   Function returns TRUE if LCD display is available.
   In other cases function returns FALSE.*)
  VAR
    tmp              : udint;
  END_VAR
END_FUNCTION

__DECL FUNCTION_BLOCK fbTick
(*Periodic Timer*)
  VAR_INPUT
    IN               : bool;  (*ticks enabled*)
    PT               : time;  (*period of ticks*)
  END_VAR
  VAR_OUTPUT
    Q                : bool;  (*tick impulse*)
    ET               : time;  (*elapsed time*)
  END_VAR
  VAR
    WasRun           : bool;
    RunTime          : time;
  END_VAR
END_FUNCTION_BLOCK



{LIBFILE="LOCALLIB\CRCLIB_V13_20170224.MLB"}
(* Mosaic IDE library *)
(* File name : C:\TecoLib\CrcLib_V13_20170224.mlb *)
(* Library : CrcLib 1.3 *)
(* Author : Teco a.s. *)
(* Copyright : (c) 2005,..,2017 Teco a.s. *)
(* IEC compiler version : 3.12.11.0 *)
(* Assembler version : 4.3.00 *)

//{Knihovna : CrcLib 1.3  }
(* History: *)
(*
v1.0 2005-08-01 Nem First edition
v1.1 2009-04-17 Nem Version without compiler warnings
v1.2 2010-09-02 Nem History version added
                    Dependency on the libraries added
v1.3 2017-02-24 Nem Added function CheckCRC_32
*)

(*----------------------------------------------------------------------------*)

__DECL FUNCTION CheckCRC_16 : uint
(*Calculation of polynomial (x16 + x15 + x2 + 1)

        Return value : UINT polynomial*)
  VAR_INPUT
    ptr              : PTR_TO usint;  (*pointer to array bytes*)
    length           : uint;  (*length of array (number of bytes)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION CheckSum : usint
(*Calculation of the arithmetic sum of an array of bytes modulo 256

        Return value : sum (mod 256)*)
  VAR_INPUT
    ptr              : PTR_TO usint;  (*pointer to array bytes*)
    length           : uint;  (*length of array (number of bytes)*)
  END_VAR
  VAR
    i                : uint;
    sum              : usint;
    ptrc             : PTR_TO usint;
  END_VAR
END_FUNCTION

__DECL FUNCTION CheckSum_XOR : usint
(*Calculation of the logical XOR array of bytes

        Return value : XOR of all bytes*)
  VAR_INPUT
    ptr              : PTR_TO usint;  (*pointer to array bytes*)
    length           : uint;  (*length of array (number of bytes)*)
  END_VAR
  VAR
    i                : uint;
    sum              : byte;
    ptrc             : PTR_TO byte;
  END_VAR
END_FUNCTION

__DECL FUNCTION CheckCRC_CCITT : uint
(*Calculation of polynomial (x16 + x12 + x5 + 1)
        (for PCD SAIA or GFR)

        Return value : UINT polynomial*)
  VAR_INPUT
    ptr              : PTR_TO usint;  (*pointer to array bytes*)
    length           : uint;  (*length of array (number of bytes)*)
  END_VAR
  VAR
    valCRC           : word;
    tmp              : word;
    i                : uint;
    j                : uint;
    ptrMsg           : PTR_TO byte;
  END_VAR
END_FUNCTION

__DECL FUNCTION CheckCRC_TECO : uint
(*Calculation of polynomial (x16 + x6 + x3 + 1)
        (Teco systems use this algorithm)
        
        Return value : UINT polynomial*)
  VAR_INPUT
    ptr              : PTR_TO usint;  (*pointer to array bytes*)
    length           : uint;  (*length of array (number of bytes)*)
  END_VAR
  VAR
    valCRC           : word;
    tmp              : word;
    i                : uint;
    j                : uint;
    ptrMsg           : PTR_TO byte;
  END_VAR
END_FUNCTION

__DECL FUNCTION CheckCRC_DIN : uint
(*Calculation of polynomial according standard DIN 66 348
  
        Return value : UINT polynomial*)
  VAR_INPUT
    ptr              : PTR_TO usint;  (*pointer to array bytes*)
    length           : uint;  (*length of array (number of bytes)*)
  END_VAR
  VAR
    tmp              : word;
    valCRC           : word;
    i                : uint;
    j                : uint;
    ptrMsg           : PTR_TO byte;
  END_VAR
END_FUNCTION

__DECL FUNCTION CheckCRC_ARNEP : uint
(*Calculation of the polynomial for Conel net ARNEP

        Return value : UINT polynomial*)
  VAR_INPUT
    ptr              : PTR_TO usint;  (*pointer to array bytes*)
    length           : uint;  (*length of array (number of bytes)*)
  END_VAR
  VAR
    valCRC           : word;
    tmp              : byte;
    i                : uint;
    j                : uint;
    ptrMsg           : PTR_TO byte;
  END_VAR
END_FUNCTION

__DECL FUNCTION CheckCRC_32 : udint
(*------------------------------------------------------------------------------
  Function calculates polynomial (X32+X26+X23+X22+X16+X12+X11+X10+X8+X7+X5+X4+X2+X+1) of byte array
  Return value : UDINT polynomial*)
  VAR_INPUT
    ptr              : PTR_TO usint;
    length           : uint;
  END_VAR
  VAR
    valCRC           : dword;
    mask             : dword;
    i                : uint;
    j                : uint;
    ptrMsg           : PTR_TO byte;
  END_VAR
END_FUNCTION



{LIBFILE="LOCALLIB\CANVASLIB_V23_20190122.MLB"}
(* Mosaic IDE library *)
(* File name : D:\TecoUserLibs\CanvasLib_V23_20190122.mlb *)
(* Library : CanvasLib 2.3 *)
(* Author : Teco a.s. *)
(* Copyright : (c)2014 - 2019 Teco a.s. *)
(* IEC compiler version : 4.2.2.2 *)
(* Assembler version : 4.3.00 *)

//{Knihovna : CanvasLib 2.3  }
(* History: *)
(*
v1.6 12/19/2010 Byd First release of library
v1.7 01/06/2011 Byd Added function GC_GraphLineRealArray
v1.8 08/12/2015 Byd Adding color from a palette Material Design
                    Fixed constant GLSCALE_HORIZONTAL
v1.9 02/02/2016 Byd Added default line style
                    Customized features GC_BEGIN to be safely updated value of the buffer size graphic
v2.0 10/06/2016 Byd Added block GC_GraphPolygonRealArray
v2.1 01/12/2017 Byd Added block GC_GraphLineXYRealArray
v2.2 03/22/2018 Byd Added types of TCavasData for minimalist objects
v2.3 01/22/2019 Byd Input of functions for drawing text expanded to 255 characters
*)

(*----------------------------------------------------------------------------*)

TYPE TCanvasInfo :
  STRUCT  (*information about canvas*)
    ver              : usint :=  2;  (*buffer structure version*)
    flags            : usint;  (*flags (.0 = 1 buffer is open to write)*)
    maxLen           : uint;  (*maximal length bufferu (1 byte less to make sure there is always space for end of buffer marker)*)
    actLen           : uint;  (*current length of buffer (progress)*)
    macroptr         : uint;  (*auxiliary variable for macro definition*)
  END_STRUCT;
END_TYPE

TYPE TCanvasPoint :
  STRUCT  (*point at canvas*)
    x                : int;  (*X coordinate*)
    y                : int;  (*Y coordinate*)
  END_STRUCT;
END_TYPE

TYPE TCanvasTouch :
  STRUCT  (*position of touch/click at canvas and color, that it is pointing to*)
    x                : int :=  -32767;  (*X coordinate of touch/click (-32767 without touch/click)*)
    y                : int :=  -32767;  (*Y coordinate of touch/click (-32767 without touch/click)*)
    color            : udint;  (*color at the point of touch/click*)
  END_STRUCT;
END_TYPE

TYPE TCanvasHeadBuf :
  STRUCT  (*header of canvas buffer*)
    dataChg          : uint;  (*unique number indicating change of data*)
    dataLen          : uint;  (*total length of data in buffer*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData16 :
  STRUCT  (*data structure for canvas, 64 bytes*)
    info             : TCanvasInfo :=  ( maxLen := 15);  (*information about buffer*)
    touch            : TCanvasTouch;  (*information about touch/click*)
    bufHead          : TCanvasHeadBuf;  (*header of buffer*)
    buf              : ARRAY [0..15] OF usint;  (*data*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData32 :
  STRUCT  (*data structure for canvas, 64 bytes*)
    info             : TCanvasInfo :=  ( maxLen := 31);  (*information about buffer*)
    touch            : TCanvasTouch;  (*information about touch/click*)
    bufHead          : TCanvasHeadBuf;  (*header of buffer*)
    buf              : ARRAY [0..31] OF usint;  (*data*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData64 :
  STRUCT  (*data structure for canvas, 64 bytes*)
    info             : TCanvasInfo :=  ( maxLen := 63);  (*information about buffer*)
    touch            : TCanvasTouch;  (*information about touch/click*)
    bufHead          : TCanvasHeadBuf;  (*header of buffer*)
    buf              : ARRAY [0..63] OF usint;  (*data*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData128 :
  STRUCT  (*data structure for canvas, 128 bytes*)
    info             : TCanvasInfo :=  ( maxLen := 127);  (*information about buffer*)
    touch            : TCanvasTouch;  (*information about touch/click*)
    bufHead          : TCanvasHeadBuf;  (*header of buffer*)
    buf              : ARRAY [0..127] OF usint;  (*data*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData256 :
  STRUCT  (*data structure for canvas, 256 bytes*)
    info             : TCanvasInfo :=  ( maxLen := 255);  (*information about buffer*)
    touch            : TCanvasTouch;  (*information about touch/click*)
    bufHead          : TCanvasHeadBuf;  (*header of buffer*)
    buf              : ARRAY [0..255] OF usint;  (*data*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData384 :
  STRUCT  (*data structure for canvas, 256 bytes*)
    info             : TCanvasInfo :=  ( maxLen := 383);  (*information about buffer*)
    touch            : TCanvasTouch;  (*information about touch/click*)
    bufHead          : TCanvasHeadBuf;  (*header of buffer*)
    buf              : ARRAY [0..383] OF usint;  (*data*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData512 :
  STRUCT  (*data structure for canvas, 512 bytes*)
    info             : TCanvasInfo :=  ( maxLen := 511);  (*information about buffer*)
    touch            : TCanvasTouch;  (*information about touch/click*)
    bufHead          : TCanvasHeadBuf;  (*header of buffer*)
    buf              : ARRAY [0..511] OF usint;  (*data*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData768 :
  STRUCT  (*data structure for canvas, 768 bytes*)
    info             : TCanvasInfo :=  ( maxLen := 767);  (*information about buffer*)
    touch            : TCanvasTouch;  (*information about touch/click*)
    bufHead          : TCanvasHeadBuf;  (*header of buffer*)
    buf              : ARRAY [0..767] OF usint;  (*data*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData1024 :
  STRUCT  (*data structure for canvas, 1024 bytes*)
    info             : TCanvasInfo :=  ( maxLen := 1023);  (*information about buffer*)
    touch            : TCanvasTouch;  (*information about touch/click*)
    bufHead          : TCanvasHeadBuf;  (*header of buffer*)
    buf              : ARRAY [0..1023] OF usint;  (*data*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData1536 :
  STRUCT  (*data structure for canvas, 1536 bytes*)
    info             : TCanvasInfo :=  ( maxLen := 1535);  (*information about buffer*)
    touch            : TCanvasTouch;  (*information about touch/click*)
    bufHead          : TCanvasHeadBuf;  (*header of buffer*)
    buf              : ARRAY [0..1535] OF usint;  (*data*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData2048 :
  STRUCT  (*data structure for canvas, 2048 bytes*)
    info             : TCanvasInfo :=  ( maxLen := 2047);  (*information about buffer*)
    touch            : TCanvasTouch;  (*information about touch/click*)
    bufHead          : TCanvasHeadBuf;  (*header of buffer*)
    buf              : ARRAY [0..2047] OF usint;  (*data*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData3072 :
  STRUCT  (*data structure for canvas, 3072 bytes*)
    info             : TCanvasInfo :=  ( maxLen := 3071);  (*information about buffer*)
    touch            : TCanvasTouch;  (*information about touch/click*)
    bufHead          : TCanvasHeadBuf;  (*header of buffer*)
    buf              : ARRAY [0..3071] OF usint;  (*data*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData4096 :
  STRUCT  (*data structure for canvas, 4096 bytes*)
    info             : TCanvasInfo :=  ( maxLen := 4095);  (*information about buffer*)
    touch            : TCanvasTouch;  (*information about touch/click*)
    bufHead          : TCanvasHeadBuf;  (*header of buffer*)
    buf              : ARRAY [0..4095] OF usint;  (*data*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData6144 :
  STRUCT  (*data structure for canvas, 6144 bytes*)
    info             : TCanvasInfo :=  ( maxLen := 6143);  (*information about buffer*)
    touch            : TCanvasTouch;  (*information about touch/click*)
    bufHead          : TCanvasHeadBuf;  (*header of buffer*)
    buf              : ARRAY [0..6143] OF usint;  (*data*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData :
  STRUCT  (*data structure for canvas, maximum size*)
    info             : TCanvasInfo :=  ( maxLen := 8191);  (*information about buffer*)
    touch            : TCanvasTouch;  (*information about touch/click*)
    bufHead          : TCanvasHeadBuf;  (*header of buffer*)
    buf              : ARRAY [0..8191] OF usint;  (*data*)
  END_STRUCT;
END_TYPE

VAR_GLOBAL CONSTANT
 GPRIMITIVE_BEGIN {HIDDEN} : usint :=  16#01;  (*zacatek bufferu*)
 GPRIMITIVE_END {HIDDEN} : usint :=  16#02;  (*konec bufferu, vykreslit vsechna primitiva*)
 GPRIMITIVE_SETLINEWIDTH {HIDDEN} : usint :=  16#03;  (*zmena tloustky cary*)
 GPRIMITIVE_SETLINESTYLE {HIDDEN} : usint :=  16#04;  (*zmena stylu cary*)
 GPRIMITIVE_SETFGCOLOR {HIDDEN} : usint :=  16#05;  (*zmena barvy popredi (car, pisma)*)
 GPRIMITIVE_SETBGCOLOR {HIDDEN} : usint :=  16#06;  (*zmena barvy pozadi (vyplne, podkladu)*)
 GPRIMITIVE_SETTEXTSIZE {HIDDEN} : usint :=  16#07;  (*zmena velikosti pisma*)
 GPRIMITIVE_SETTEXTSTYLE {HIDDEN} : usint :=  16#08;  (*zmena stylu pisma*)
 GPRIMITIVE_SETGRADIENTSTYLE {HIDDEN} : usint :=  16#09;  (*zmena stylu gradientu*)
 GPRIMITIVE_SETORIGIN {HIDDEN} : usint :=  16#0A;  (*presune pocatek souradnic do pozice kresliciho pera*)
 GPRIMITIVE_RESETORIGIN {HIDDEN} : usint :=  16#0B;  (*presune pocatek souradnic do vychozi pozice*)
 GPRIMITIVE_SETVIRTSIZE {HIDDEN} : usint :=  16#0C;  (*nastavi virtualni rozmer kreslici plochy, pri zobrazeni se prepocita na skutecny rozmer canvasu*)
 GPRIMITIVE_SETFILLSTYLE {HIDDEN} : usint :=  16#0D;  (*zmena stylu vyplne*)
 GPRIMITIVE_POINT {HIDDEN} : usint :=  16#10;  (*bod*)
 GPRIMITIVE_LINE {HIDDEN} : usint :=  16#11;  (*cara x1,y1 -> x2,y2*)
 GPRIMITIVE_MOVETO {HIDDEN} : usint :=  16#12;  (*nastaveni nove souradnice kresliciho pera*)
 GPRIMITIVE_LINETO {HIDDEN} : usint :=  16#13;  (*cara z minuleho bodu do x,y*)
 GPRIMITIVE_BOX {HIDDEN} : usint :=  16#14;  (*obdelnik*)
 GPRIMITIVE_FILLBOX {HIDDEN} : usint :=  16#15;  (*vyplneny obdelnik*)
 GPRIMITIVE_POLYGON {HIDDEN} : usint :=  16#16;  (*polygon*)
 GPRIMITIVE_FILLPOLYGON {HIDDEN} : usint :=  16#17;  (*vyplneny polygon*)
 GPRIMITIVE_CIRCLE {HIDDEN} : usint :=  16#18;  (*kruznice*)
 GPRIMITIVE_FILLCIRCLE {HIDDEN} : usint :=  16#19;  (*kruh*)
 GPRIMITIVE_ARC {HIDDEN} : usint :=  16#1A;  (*oblouk*)
 GPRIMITIVE_FILLARC {HIDDEN} : usint :=  16#1B;  (*vyplneny oblouk*)
 GPRIMITIVE_WRITETEXT {HIDDEN} : usint :=  16#1C;  (*vypis textu ppravo od pozice kresliciho pera*)
 GPRIMITIVE_IMAGE {HIDDEN} : usint :=  16#1D;  (*zobrazeni obrazku*)
 GPRIMITIVE_MOVE {HIDDEN} : usint :=  16#20;  (*relativni zmena souradnice kresliciho pera*)
 GPRIMITIVE_CBOX {HIDDEN} : usint :=  16#21;  (*centrovany obdelnik*)
 GPRIMITIVE_CFILLBOX {HIDDEN} : usint :=  16#22;  (*centrovany vyplneny obdelnik*)
 GPRIMITIVE_CFILLARC {HIDDEN} : usint :=  16#23;  (*vyplneny oblouk se stredem na pozici kresliciho pera*)
 GPRIMITIVE_CWRITETEXT {HIDDEN} : usint :=  16#24;  (*centrovany vypis textu*)
 GPRIMITIVE_CIMAGE {HIDDEN} : usint :=  16#25;  (*centrovane zobrazeni obrazku*)
 GPRIMITIVE_CCIRCLE {HIDDEN} : usint :=  16#26;  (*centrovana kruznice*)
 GPRIMITIVE_CFILLCIRCLE {HIDDEN} : usint :=  16#27;  (*centrovany kruh*)
 GPRIMITIVE_HEADING {HIDDEN} : usint :=  16#28;  (*nastaveni uhlu kresliciho pera*)
 GPRIMITIVE_TURN {HIDDEN} : usint :=  16#29;  (*zmena uhlu kresliciho pera (+=doprava, -=doleva)*)
 GPRIMITIVE_LINEFWD {HIDDEN} : usint :=  16#2A;  (*posun kresliciho pera podle jeho uhlu (kresli caru)*)
 GPRIMITIVE_MOVEFWD {HIDDEN} : usint :=  16#2B;  (*posun kresliciho pera podle jeho uhlu (nekresli caru)*)
 GPRIMITIVE_PUSHPOSITION {HIDDEN} : usint :=  16#2C;  (*ulozi aktualni pozici kresliciho pera*)
 GPRIMITIVE_POPPOSITION {HIDDEN} : usint :=  16#2D;  (*obnovi aktualni pozici kresliciho pera*)
 GPRIMITIVE_CPOLYGON {HIDDEN} : usint :=  16#2E;  (*polygon, natoceny podle uhlu kresliciho pera, souradnice jsou relativni k pozici kresliciho pera pri uhlu 0st*)
 GPRIMITIVE_CFILLPOLYGON {HIDDEN} : usint :=  16#2F;  (*vyplneny polygon, natoceny podle uhlu kresliciho pera, souradnice jsou relativni k pozici kresliciho pera pri uhlu 0st*)
 GPRIMITIVE_GRAPHLINE {HIDDEN} : usint :=  16#30;  (*vykresli data pro carovy graf*)
 GPRIMITIVE_GRAPHBARS {HIDDEN} : usint :=  16#31;  (*vykresli data pro sloupcovy graf*)
 GPRIMITIVE_PUSHHEADING {HIDDEN} : usint :=  16#32;  (*ulozi aktualni uhel kresliciho pera*)
 GPRIMITIVE_POPHEADING {HIDDEN} : usint :=  16#33;  (*obnovi aktualni uhel kresliciho pera*)
 GPRIMITIVE_MACROBEGIN {HIDDEN} : usint :=  16#34;  (*zacatek definice marka*)
 GPRIMITIVE_MACROEND {HIDDEN} : usint :=  16#35;  (*konec definice marka*)
 GPRIMITIVE_MACRORUN {HIDDEN} : usint :=  16#36;  (*volani marka*)
 GPRIMITIVE_RADIALSCALE {HIDDEN} : usint :=  16#37;  (*kruhová stupnice*)
 GPRIMITIVE_LINEARSCALE {HIDDEN} : usint :=  16#38;  (*lineární stupnice*)
 GPRIMITIVE_ROUNDBOX {HIDDEN} : usint :=  16#39;  (*obdélník se zaoblenými rohy*)
 GPRIMITIVE_ROUNDFILLBOX {HIDDEN} : usint :=  16#3A;  (*vyplnìný obdélník se zaoblenými rohy*)
 GPRIMITIVE_CROUNDBOX {HIDDEN} : usint :=  16#3B;  (*centrovaný obdélník se zaoblenými rohy*)
 GPRIMITIVE_CROUNDFILLBOX {HIDDEN} : usint :=  16#3C;  (*centrovaný vyplnìný obdélník se zaoblenými rohy*)
 GPRIMITIVE_CARC {HIDDEN} : usint :=  16#3D;  (*oblouk se stredem na pozici kresliciho pera*)
 GTEXT_STYLE_NORMAL : uint :=  16#0000;  (*normal font*)
 GTEXT_STYLE_BOLD : uint :=  16#0001;  (*boldface*)
 GTEXT_STYLE_ITALIC : uint :=  16#0002;  (*italics*)
 GTEXT_STYLE_FILLBG : uint :=  16#0004;  (*fill text background*)
 GTEXT_STYLE_ALIGN_LEFT : uint :=  16#0000;  (*multiline text - align lines to the left*)
 GTEXT_STYLE_ALIGN_RIGHT : uint :=  16#0010;  (*multiline text - align lines to the right*)
 GTEXT_STYLE_ALIGN_CENTER : uint :=  16#0020;  (*multiline text - align lines in the middle*)
 GTEXT_STYLE_HRIGHT : uint :=  16#0000;  (*print text from positions drawing pen to the right*)
 GTEXT_STYLE_HLEFT : uint :=  16#0040;  (*print text from position drawing pen to the left*)
 GTEXT_STYLE_HCENTER : uint :=  16#0080;  (*drawing pen position is at the center of line*)
 GTEXT_STYLE_VDOWN : uint :=  16#0000;  (*print text from position drawing pen down*)
 GTEXT_STYLE_VUP : uint :=  16#0100;  (*print text from position drawing pen up*)
 GTEXT_STYLE_VCENTER : uint :=  16#0200;  (*drawing pen position is in the middle of line*)
 GLINE_STYLE_SOLID : usint :=  16#00;  (*solid line*)
 GLINE_STYLE_DASH : usint :=  16#01;  (*dashed line*)
 GLINE_STYLE_DOTDASH : usint :=  16#02;  (*dot-and-dash line*)
 GLINE_STYLE_DOT : usint :=  16#03;  (*dotted line*)
 GLINE_CAP_BUTT : usint :=  16#00;  (*default end of the line at the end point*)
 GLINE_CAP_ROUND : usint :=  16#10;  (*a rounded end cap is added to each end of the line*)
 GLINE_CAP_SQUARE : usint :=  16#20;  (*a square end cap is added to each end of the line*)
 GLINE_JOIN_MITTER : usint :=  16#00;  (*default join of lines creates sharp corner*)
 GLINE_JOIN_ROUND : usint :=  16#40;  (*join of lines creates a rounded corner*)
 GLINE_JOIN_BEVEL : usint :=  16#80;  (*join of lines creates a beveled corner*)
 GFILL_STYLE_BGCOLOR : usint :=  16#00;  (*fill with background color*)
 GFILL_STYLE_FRAME : usint :=  16#01;  (*fill including frame (frame is drawn by foreground color)*)
 GFILL_STYLE_GRADIENT : usint :=  16#02;  (*fill with gradient*)
 GGRADIENT_STYLE_LINEAR : usint :=  16#00;  (*linear gradient*)
 GGRADIENT_STYLE_BAR1_3 : usint :=  16#02;  (*two reverse linear gradients side by side with a width of 1/3 and 2/3*)
 GGRADIENT_STYLE_RADIAL : usint :=  16#01;  (*circular gradient, first color at the center*)
 GGRADIENT_STYLE_RADIAL1_3 : usint :=  16#03;  (*circular gradient, first color is moved by 1/3 to the left top*)
 GGRADIENT_STYLE_HORIZONTAL : usint :=  16#80;  (*gradient from left to right (instead of from top to bottom)*)
 GPOS_TYPE_PCT : int :=  16#4000;  (*flag that coordinates are not in pixels but in percents*)
 GGRAPH_LINE_DEFAULT : usint :=  16#00;  (*default line style*)
 GGRAPH_LINE_SHOWDOT : usint :=  16#01;  (*show data points (circles)*)
 GGRAPH_LINE_SHOWCROSS : usint :=  16#02;  (*show data points (crosses)*)
 GGRAPH_LINE_NOLINES : usint :=  16#08;  (*do not draw lines (only points)*)
 GGRAPH_LINE_INTERPOLATE : usint :=  16#10;  (*data interpolation*)
 GGRAPH_LINE_FILL : usint :=  16#20;  (*fill area between line and X axis*)
 GCOLOR_TRANSPARENT : udint :=  16#FF000000;  (*fully transparent*)
 GCOLOR_TRANSPARENT3_4 : udint :=  16#C0000000;  (*3/4 transparent*)
 GCOLOR_TRANSPARENT1_2 : udint :=  16#80000000;  (*half transparent*)
 GCOLOR_TRANSPARENT1_4 : udint :=  16#40000000;  (*1/4 transparent*)
 GCOLOR_WHITE : udint :=  16#00FFFFFF;  (*white*)
 GCOLOR_BLACK : udint :=  16#00000001;  (*black*)
 GCOLOR_RED : udint :=  16#000000FF;  (*red*)
 GCOLOR_ORANGE : udint :=  16#000080FF;  (*orange*)
 GCOLOR_YELLOW : udint :=  16#0000FFFF;  (*yellow*)
 GCOLOR_CHARTREUSE : udint :=  16#0000FF80;  (*chartreuse*)
 GCOLOR_GREEN : udint :=  16#0000FF00;  (*green*)
 GCOLOR_SPRINGGREEN : udint :=  16#0080FF00;  (*spring green*)
 GCOLOR_CYAN : udint :=  16#00FFFF00;  (*cyan*)
 GCOLOR_AZURE : udint :=  16#00FF8000;  (*azure*)
 GCOLOR_BLUE : udint :=  16#00FF0000;  (*blue*)
 GCOLOR_VIOLET : udint :=  16#00FF0080;  (*violet*)
 GCOLOR_MAGENTA : udint :=  16#00FF00FF;  (*magenta*)
 GCOLOR_ROSE : udint :=  16#008000FF;  (*rose*)
 GCOLOR_LTGRAY : udint :=  16#00C0C0C0;  (*light gray*)
 GCOLOR_GRAY : udint :=  16#00808080;  (*gray*)
 GCOLOR_DKGRAY : udint :=  16#00404040;  (*dark gray*)
 GCOLOR_RED_50 : udint :=    16#EEEBFF;  (*red*)
 GCOLOR_RED_100 : udint :=   16#D2CDFF;  (*red*)
 GCOLOR_RED_200 : udint :=   16#9A9AEF;  (*red*)
 GCOLOR_RED_300 : udint :=   16#7373E5;  (*red*)
 GCOLOR_RED_400 : udint :=   16#5053EF;  (*red*)
 GCOLOR_RED_500 : udint :=   16#3643F4;  (*red*)
 GCOLOR_RED_600 : udint :=   16#3539E5;  (*red*)
 GCOLOR_RED_700 : udint :=   16#2F2FD3;  (*red*)
 GCOLOR_RED_800 : udint :=   16#2828C6;  (*red*)
 GCOLOR_RED_900 : udint :=   16#1C1CB7;  (*red*)
 GCOLOR_RED_A100 : udint :=  16#808AFF;  (*red*)
 GCOLOR_RED_A200 : udint :=  16#5252FF;  (*red*)
 GCOLOR_RED_A400 : udint :=  16#4417FF;  (*red*)
 GCOLOR_RED_A700 : udint :=  16#0000D5;  (*red*)
 GCOLOR_PINK_50 : udint :=    16#ECE4FC;  (*pink*)
 GCOLOR_PINK_100 : udint :=   16#D0BBF8;  (*pink*)
 GCOLOR_PINK_200 : udint :=   16#B18FF4;  (*pink*)
 GCOLOR_PINK_300 : udint :=   16#9262F0;  (*pink*)
 GCOLOR_PINK_400 : udint :=   16#7A40EC;  (*pink*)
 GCOLOR_PINK_500 : udint :=   16#631EE9;  (*pink*)
 GCOLOR_PINK_600 : udint :=   16#601BD8;  (*pink*)
 GCOLOR_PINK_700 : udint :=   16#5B18C2;  (*pink*)
 GCOLOR_PINK_800 : udint :=   16#5714AD;  (*pink*)
 GCOLOR_PINK_900 : udint :=   16#4F0E88;  (*pink*)
 GCOLOR_PINK_A100 : udint :=  16#AB80FF;  (*pink*)
 GCOLOR_PINK_A200 : udint :=  16#8140FF;  (*pink*)
 GCOLOR_PINK_A400 : udint :=  16#5700F5;  (*pink*)
 GCOLOR_PINK_A700 : udint :=  16#6211C5;  (*pink*)
 GCOLOR_PURPLE_50 : udint :=    16#F5E5F3;  (*purple*)
 GCOLOR_PURPLE_100 : udint :=   16#E7BEE1;  (*purple*)
 GCOLOR_PURPLE_200 : udint :=   16#D893CE;  (*purple*)
 GCOLOR_PURPLE_300 : udint :=   16#C868BA;  (*purple*)
 GCOLOR_PURPLE_400 : udint :=   16#BC47AB;  (*purple*)
 GCOLOR_PURPLE_500 : udint :=   16#B0279C;  (*purple*)
 GCOLOR_PURPLE_600 : udint :=   16#AA248E;  (*purple*)
 GCOLOR_PURPLE_700 : udint :=   16#A21F7B;  (*purple*)
 GCOLOR_PURPLE_800 : udint :=   16#9A1B6A;  (*purple*)
 GCOLOR_PURPLE_900 : udint :=   16#8C144A;  (*purple*)
 GCOLOR_PURPLE_A100 : udint :=  16#FC80EA;  (*purple*)
 GCOLOR_PURPLE_A200 : udint :=  16#FB40E0;  (*purple*)
 GCOLOR_PURPLE_A400 : udint :=  16#F900D5;  (*purple*)
 GCOLOR_PURPLE_A700 : udint :=  16#FF00AA;  (*purple*)
 GCOLOR_DEEP_PURPLE_50 : udint :=    16#F6E7ED;  (*deep purple*)
 GCOLOR_DEEP_PURPLE_100 : udint :=   16#E9C4D1;  (*deep purple*)
 GCOLOR_DEEP_PURPLE_200 : udint :=   16#DB9DB3;  (*deep purple*)
 GCOLOR_DEEP_PURPLE_300 : udint :=   16#CD7595;  (*deep purple*)
 GCOLOR_DEEP_PURPLE_400 : udint :=   16#C2577E;  (*deep purple*)
 GCOLOR_DEEP_PURPLE_500 : udint :=   16#B73A67;  (*deep purple*)
 GCOLOR_DEEP_PURPLE_600 : udint :=   16#B1355E;  (*deep purple*)
 GCOLOR_DEEP_PURPLE_700 : udint :=   16#A82D51;  (*deep purple*)
 GCOLOR_DEEP_PURPLE_800 : udint :=   16#A02745;  (*deep purple*)
 GCOLOR_DEEP_PURPLE_900 : udint :=   16#921B31;  (*deep purple*)
 GCOLOR_DEEP_PURPLE_A100 : udint :=  16#FF88B3;  (*deep purple*)
 GCOLOR_DEEP_PURPLE_A200 : udint :=  16#FF4D7C;  (*deep purple*)
 GCOLOR_DEEP_PURPLE_A400 : udint :=  16#FF1F65;  (*deep purple*)
 GCOLOR_DEEP_PURPLE_A700 : udint :=  16#EA0062;  (*deep purple*)
 GCOLOR_INDIGO_50 : udint :=    16#F6EAE8;  (*indigo*)
 GCOLOR_INDIGO_100 : udint :=   16#E9CAC5;  (*indigo*)
 GCOLOR_INDIGO_200 : udint :=   16#DAA89F;  (*indigo*)
 GCOLOR_INDIGO_300 : udint :=   16#CB8679;  (*indigo*)
 GCOLOR_INDIGO_400 : udint :=   16#C06B5C;  (*indigo*)
 GCOLOR_INDIGO_500 : udint :=   16#B5513F;  (*indigo*)
 GCOLOR_INDIGO_600 : udint :=   16#AB4939;  (*indigo*)
 GCOLOR_INDIGO_700 : udint :=   16#9F3F30;  (*indigo*)
 GCOLOR_INDIGO_800 : udint :=   16#933528;  (*indigo*)
 GCOLOR_INDIGO_900 : udint :=   16#7E231A;  (*indigo*)
 GCOLOR_INDIGO_A100 : udint :=  16#FF9E8C;  (*indigo*)
 GCOLOR_INDIGO_A200 : udint :=  16#FE6D53;  (*indigo*)
 GCOLOR_INDIGO_A400 : udint :=  16#FE5A3D;  (*indigo*)
 GCOLOR_INDIGO_A700 : udint :=  16#FE4F30;  (*indigo*)
 GCOLOR_BLUE_50 : udint :=    16#FDF2E3;  (*blue*)
 GCOLOR_BLUE_100 : udint :=   16#FBDEBB;  (*blue*)
 GCOLOR_BLUE_200 : udint :=   16#F9CA90;  (*blue*)
 GCOLOR_BLUE_300 : udint :=   16#F6B564;  (*blue*)
 GCOLOR_BLUE_400 : udint :=   16#F5A542;  (*blue*)
 GCOLOR_BLUE_500 : udint :=   16#F39621;  (*blue*)
 GCOLOR_BLUE_600 : udint :=   16#E5881E;  (*blue*)
 GCOLOR_BLUE_700 : udint :=   16#D27619;  (*blue*)
 GCOLOR_BLUE_800 : udint :=   16#C06515;  (*blue*)
 GCOLOR_BLUE_900 : udint :=   16#A1470D;  (*blue*)
 GCOLOR_BLUE_A100 : udint :=  16#FFB182;  (*blue*)
 GCOLOR_BLUE_A200 : udint :=  16#FF8A44;  (*blue*)
 GCOLOR_BLUE_A400 : udint :=  16#FF7929;  (*blue*)
 GCOLOR_BLUE_A700 : udint :=  16#FF6229;  (*blue*)
 GCOLOR_LIGHT_BLUE_50 : udint :=    16#FEF5E1;  (*light blue*)
 GCOLOR_LIGHT_BLUE_100 : udint :=   16#FCE5B3;  (*light blue*)
 GCOLOR_LIGHT_BLUE_200 : udint :=   16#FAD481;  (*light blue*)
 GCOLOR_LIGHT_BLUE_300 : udint :=   16#F7C34F;  (*light blue*)
 GCOLOR_LIGHT_BLUE_400 : udint :=   16#F6B629;  (*light blue*)
 GCOLOR_LIGHT_BLUE_500 : udint :=   16#F4A903;  (*light blue*)
 GCOLOR_LIGHT_BLUE_600 : udint :=   16#E59B03;  (*light blue*)
 GCOLOR_LIGHT_BLUE_700 : udint :=   16#D18802;  (*light blue*)
 GCOLOR_LIGHT_BLUE_800 : udint :=   16#BD7702;  (*light blue*)
 GCOLOR_LIGHT_BLUE_900 : udint :=   16#9B5701;  (*light blue*)
 GCOLOR_LIGHT_BLUE_A100 : udint :=  16#FFD880;  (*light blue*)
 GCOLOR_LIGHT_BLUE_A200 : udint :=  16#FFC440;  (*light blue*)
 GCOLOR_LIGHT_BLUE_A400 : udint :=  16#FFB000;  (*light blue*)
 GCOLOR_LIGHT_BLUE_A700 : udint :=  16#EA9100;  (*light blue*)
 GCOLOR_CYAN_50 : udint :=    16#FAF7E0;  (*cyan*)
 GCOLOR_CYAN_100 : udint :=   16#F2EBB2;  (*cyan*)
 GCOLOR_CYAN_200 : udint :=   16#EADE80;  (*cyan*)
 GCOLOR_CYAN_300 : udint :=   16#E1D04D;  (*cyan*)
 GCOLOR_CYAN_400 : udint :=   16#DAC626;  (*cyan*)
 GCOLOR_CYAN_500 : udint :=   16#D4BC00;  (*cyan*)
 GCOLOR_CYAN_600 : udint :=   16#C1AC00;  (*cyan*)
 GCOLOR_CYAN_700 : udint :=   16#A79700;  (*cyan*)
 GCOLOR_CYAN_800 : udint :=   16#8F8300;  (*cyan*)
 GCOLOR_CYAN_900 : udint :=   16#646000;  (*cyan*)
 GCOLOR_CYAN_A100 : udint :=  16#FFFF84;  (*cyan*)
 GCOLOR_CYAN_A200 : udint :=  16#FFFF18;  (*cyan*)
 GCOLOR_CYAN_A400 : udint :=  16#FFE500;  (*cyan*)
 GCOLOR_CYAN_A700 : udint :=  16#D4B800;  (*cyan*)
 GCOLOR_TEAL_50 : udint :=    16#F1F2E0;  (*teal*)
 GCOLOR_TEAL_100 : udint :=   16#DBDFB2;  (*teal*)
 GCOLOR_TEAL_200 : udint :=   16#C4CB80;  (*teal*)
 GCOLOR_TEAL_300 : udint :=   16#ACB64D;  (*teal*)
 GCOLOR_TEAL_400 : udint :=   16#9AA626;  (*teal*)
 GCOLOR_TEAL_500 : udint :=   16#889600;  (*teal*)
 GCOLOR_TEAL_600 : udint :=   16#7B8900;  (*teal*)
 GCOLOR_TEAL_700 : udint :=   16#6B7900;  (*teal*)
 GCOLOR_TEAL_800 : udint :=   16#5C6900;  (*teal*)
 GCOLOR_TEAL_900 : udint :=   16#404D00;  (*teal*)
 GCOLOR_TEAL_A100 : udint :=  16#EBFFA7;  (*teal*)
 GCOLOR_TEAL_A200 : udint :=  16#DAFF64;  (*teal*)
 GCOLOR_TEAL_A400 : udint :=  16#B6E91D;  (*teal*)
 GCOLOR_TEAL_A700 : udint :=  16#A5BF00;  (*teal*)
 GCOLOR_GREEN_50 : udint :=    16#E9F5E8;  (*green*)
 GCOLOR_GREEN_100 : udint :=   16#C9E6C8;  (*green*)
 GCOLOR_GREEN_200 : udint :=   16#A7D6A5;  (*green*)
 GCOLOR_GREEN_300 : udint :=   16#84C781;  (*green*)
 GCOLOR_GREEN_400 : udint :=   16#6ABB66;  (*green*)
 GCOLOR_GREEN_500 : udint :=   16#50AF4C;  (*green*)
 GCOLOR_GREEN_600 : udint :=   16#47A043;  (*green*)
 GCOLOR_GREEN_700 : udint :=   16#3C8E38;  (*green*)
 GCOLOR_GREEN_800 : udint :=   16#327D2E;  (*green*)
 GCOLOR_GREEN_900 : udint :=   16#205E1B;  (*green*)
 GCOLOR_GREEN_A100 : udint :=  16#CAF6B9;  (*green*)
 GCOLOR_GREEN_A200 : udint :=  16#AEF069;  (*green*)
 GCOLOR_GREEN_A400 : udint :=  16#76E600;  (*green*)
 GCOLOR_GREEN_A700 : udint :=  16#53C800;  (*green*)
 GCOLOR_LIGHT_GREEN_50 : udint :=    16#E9F8F1;  (*light green*)
 GCOLOR_LIGHT_GREEN_100 : udint :=   16#C8EDDC;  (*light green*)
 GCOLOR_LIGHT_GREEN_200 : udint :=   16#A5E1C5;  (*light green*)
 GCOLOR_LIGHT_GREEN_300 : udint :=   16#81D5AE;  (*light green*)
 GCOLOR_LIGHT_GREEN_400 : udint :=   16#65CC9C;  (*light green*)
 GCOLOR_LIGHT_GREEN_500 : udint :=   16#4AC38B;  (*light green*)
 GCOLOR_LIGHT_GREEN_600 : udint :=   16#42B37C;  (*light green*)
 GCOLOR_LIGHT_GREEN_700 : udint :=   16#389F68;  (*light green*)
 GCOLOR_LIGHT_GREEN_800 : udint :=   16#2F8B55;  (*light green*)
 GCOLOR_LIGHT_GREEN_900 : udint :=   16#1E6933;  (*light green*)
 GCOLOR_LIGHT_GREEN_A100 : udint :=  16#90FFCC;  (*light green*)
 GCOLOR_LIGHT_GREEN_A200 : udint :=  16#59FFB2;  (*light green*)
 GCOLOR_LIGHT_GREEN_A400 : udint :=  16#03FF76;  (*light green*)
 GCOLOR_LIGHT_GREEN_A700 : udint :=  16#17DD64;  (*light green*)
 GCOLOR_LIME_50 : udint :=    16#E7FBF9;  (*lime*)
 GCOLOR_LIME_100 : udint :=   16#C3F4F0;  (*lime*)
 GCOLOR_LIME_200 : udint :=   16#9CEEE6;  (*lime*)
 GCOLOR_LIME_300 : udint :=   16#75E7DC;  (*lime*)
 GCOLOR_LIME_400 : udint :=   16#57E1D4;  (*lime*)
 GCOLOR_LIME_500 : udint :=   16#39DCCD;  (*lime*)
 GCOLOR_LIME_600 : udint :=   16#33CAC0;  (*lime*)
 GCOLOR_LIME_700 : udint :=   16#2BB4AF;  (*lime*)
 GCOLOR_LIME_800 : udint :=   16#249D9E;  (*lime*)
 GCOLOR_LIME_900 : udint :=   16#177782;  (*lime*)
 GCOLOR_LIME_A100 : udint :=  16#81FFF4;  (*lime*)
 GCOLOR_LIME_A200 : udint :=  16#41FFEE;  (*lime*)
 GCOLOR_LIME_A400 : udint :=  16#00FFC6;  (*lime*)
 GCOLOR_LIME_A700 : udint :=  16#00EAAE;  (*lime*)
 GCOLOR_YELLOW_50 : udint :=  16#E7FDFF;  (*yellow*)
 GCOLOR_YELLOW_100 : udint :=  16#C4F9FF;  (*yellow*)
 GCOLOR_YELLOW_200 : udint :=  16#9DF5FF;  (*yellow*)
 GCOLOR_YELLOW_300 : udint :=  16#76F1FF;  (*yellow*)
 GCOLOR_YELLOW_400 : udint :=  16#58EEFF;  (*yellow*)
 GCOLOR_YELLOW_500 : udint :=  16#3BEBFF;  (*yellow*)
 GCOLOR_YELLOW_600 : udint :=  16#35D8FD;  (*yellow*)
 GCOLOR_YELLOW_700 : udint :=  16#2DC0FB;  (*yellow*)
 GCOLOR_YELLOW_800 : udint :=  16#25A8F9;  (*yellow*)
 GCOLOR_YELLOW_900 : udint :=  16#177FF5;  (*yellow*)
 GCOLOR_YELLOW_A100 : udint :=  16#8DFFFF;  (*yellow*)
 GCOLOR_YELLOW_A200 : udint :=  16#00FFFF;  (*yellow*)
 GCOLOR_YELLOW_A400 : udint :=  16#00EAFF;  (*yellow*)
 GCOLOR_YELLOW_A700 : udint :=  16#00D6FF;  (*yellow*)
 GCOLOR_AMBER_50 : udint :=  16#E1F8FF;  (*amber*)
 GCOLOR_AMBER_100 : udint :=  16#B3ECFF;  (*amber*)
 GCOLOR_AMBER_200 : udint :=  16#82E0FF;  (*amber*)
 GCOLOR_AMBER_300 : udint :=  16#4FD5FF;  (*amber*)
 GCOLOR_AMBER_400 : udint :=  16#28CAFF;  (*amber*)
 GCOLOR_AMBER_500 : udint :=  16#07C1FF;  (*amber*)
 GCOLOR_AMBER_600 : udint :=  16#00B3FF;  (*amber*)
 GCOLOR_AMBER_700 : udint :=  16#00A0FF;  (*amber*)
 GCOLOR_AMBER_800 : udint :=  16#008FFF;  (*amber*)
 GCOLOR_AMBER_900 : udint :=  16#006FFF;  (*amber*)
 GCOLOR_AMBER_A100 : udint :=  16#7FE5FF;  (*amber*)
 GCOLOR_AMBER_A200 : udint :=  16#40D7FF;  (*amber*)
 GCOLOR_AMBER_A400 : udint :=  16#00C4FF;  (*amber*)
 GCOLOR_AMBER_A700 : udint :=  16#00ABFF;  (*amber*)
 GCOLOR_ORANGE_50 : udint :=  16#E0F3FF;  (*orange*)
 GCOLOR_ORANGE_100 : udint :=  16#B2E0FF;  (*orange*)
 GCOLOR_ORANGE_200 : udint :=  16#80CCFF;  (*orange*)
 GCOLOR_ORANGE_300 : udint :=  16#4DB7FF;  (*orange*)
 GCOLOR_ORANGE_400 : udint :=  16#26A7FF;  (*orange*)
 GCOLOR_ORANGE_500 : udint :=  16#0098FF;  (*orange*)
 GCOLOR_ORANGE_600 : udint :=  16#008CFB;  (*orange*)
 GCOLOR_ORANGE_700 : udint :=  16#007CF5;  (*orange*)
 GCOLOR_ORANGE_800 : udint :=  16#006CEF;  (*orange*)
 GCOLOR_ORANGE_900 : udint :=  16#0051E6;  (*orange*)
 GCOLOR_ORANGE_A100 : udint :=  16#80D1FF;  (*orange*)
 GCOLOR_ORANGE_A200 : udint :=  16#40ABFF;  (*orange*)
 GCOLOR_ORANGE_A400 : udint :=  16#0091FF;  (*orange*)
 GCOLOR_ORANGE_A700 : udint :=  16#006DFF;  (*orange*)
 GCOLOR_DEEP_ORANGE_50 : udint :=  16#E7E9FB;  (*deep orange*)
 GCOLOR_DEEP_ORANGE_100 : udint :=  16#BCCCFF;  (*deep orange*)
 GCOLOR_DEEP_ORANGE_200 : udint :=  16#91ABFF;  (*deep orange*)
 GCOLOR_DEEP_ORANGE_300 : udint :=  16#658AFF;  (*deep orange*)
 GCOLOR_DEEP_ORANGE_400 : udint :=  16#4370FF;  (*deep orange*)
 GCOLOR_DEEP_ORANGE_500 : udint :=  16#2257FF;  (*deep orange*)
 GCOLOR_DEEP_ORANGE_600 : udint :=  16#1E51F4;  (*deep orange*)
 GCOLOR_DEEP_ORANGE_700 : udint :=  16#194AE6;  (*deep orange*)
 GCOLOR_DEEP_ORANGE_800 : udint :=  16#1543D8;  (*deep orange*)
 GCOLOR_DEEP_ORANGE_900 : udint :=  16#0C36BF;  (*deep orange*)
 GCOLOR_DEEP_ORANGE_A100 : udint :=  16#809EFF;  (*deep orange*)
 GCOLOR_DEEP_ORANGE_A200 : udint :=  16#406EFF;  (*deep orange*)
 GCOLOR_DEEP_ORANGE_A400 : udint :=  16#003DFF;  (*deep orange*)
 GCOLOR_DEEP_ORANGE_A700 : udint :=  16#002CDD;  (*deep orange*)
 GCOLOR_BROWN_50 : udint :=  16#E9EBEF;  (*brown*)
 GCOLOR_BROWN_100 : udint :=  16#C8CCD7;  (*brown*)
 GCOLOR_BROWN_200 : udint :=  16#A4AABC;  (*brown*)
 GCOLOR_BROWN_300 : udint :=  16#7F88A1;  (*brown*)
 GCOLOR_BROWN_400 : udint :=  16#636E8D;  (*brown*)
 GCOLOR_BROWN_500 : udint :=  16#485579;  (*brown*)
 GCOLOR_BROWN_600 : udint :=  16#414C6D;  (*brown*)
 GCOLOR_BROWN_700 : udint :=  16#37405D;  (*brown*)
 GCOLOR_BROWN_800 : udint :=  16#2E344E;  (*brown*)
 GCOLOR_BROWN_900 : udint :=  16#23273E;  (*brown*)
 GCOLOR_GREY_50 : udint :=  16#FAFAFA;  (*grey*)
 GCOLOR_GREY_100 : udint :=  16#F5F5F5;  (*grey*)
 GCOLOR_GREY_200 : udint :=  16#EEEEEE;  (*grey*)
 GCOLOR_GREY_300 : udint :=  16#E0E0E0;  (*grey*)
 GCOLOR_GREY_400 : udint :=  16#BDBDBD;  (*grey*)
 GCOLOR_GREY_500 : udint :=  16#9E9E9E;  (*grey*)
 GCOLOR_GREY_600 : udint :=  16#757575;  (*grey*)
 GCOLOR_GREY_700 : udint :=  16#616161;  (*grey*)
 GCOLOR_GREY_800 : udint :=  16#424242;  (*grey*)
 GCOLOR_GREY_900 : udint :=  16#212121;  (*grey*)
 GCOLOR_BLUE_GREY_50 : udint :=  16#F1EFEC;  (*blue grey*)
 GCOLOR_BLUE_GREY_100 : udint :=  16#DCD8CF;  (*blue grey*)
 GCOLOR_BLUE_GREY_200 : udint :=  16#C5BEB0;  (*blue grey*)
 GCOLOR_BLUE_GREY_300 : udint :=  16#AEA490;  (*blue grey*)
 GCOLOR_BLUE_GREY_400 : udint :=  16#9C9078;  (*blue grey*)
 GCOLOR_BLUE_GREY_500 : udint :=  16#8B7D60;  (*blue grey*)
 GCOLOR_BLUE_GREY_600 : udint :=  16#7A6E54;  (*blue grey*)
 GCOLOR_BLUE_GREY_700 : udint :=  16#645A45;  (*blue grey*)
 GCOLOR_BLUE_GREY_800 : udint :=  16#4F4737;  (*blue grey*)
 GCOLOR_BLUE_GREY_900 : udint :=  16#383226;  (*blue grey*)
 GRSCALE_NO_FIRST : int :=  16#01;  (*don't draw first tick*)
 GRSCALE_NO_LAST : int :=  16#02;  (*don't draw last tick*)
 GRSCALE_NO_LABELS : int :=  16#04;  (*don't draw text labels*)
 GRSCALE_BOLD_TICK : int :=  16#08;  (*bold major tick*)
 GRSCALE_CIRCULAR_TICK : int :=  16#10;  (*circular major tick*)
 GRSCALE_OUTLINE : int :=  16#20;  (*draw arc connecting tick*)
 GLSCALE_HORIZONTAL : int :=  16#00;  (*horizontal scale*)
 GLSCALE_VERTICAL : int :=  16#01;  (*vertical scale*)
 GLSCALE_NO_BASELINE : int :=  16#02;  (*don't draw base line (only ticks)*)
 GLSCALE_NO_LABELS : int :=  16#04;  (*don't draw text labels*)
 GLSCALE_BOLD_TICK : int :=  16#08;  (*bold major tick*)

END_VAR

__DECL FUNCTION GC_TestSpace {HIDDEN} : bool
  VAR_INPUT
    rqLen            : uint;
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SaveByte {HIDDEN} : bool
  VAR_INPUT
    data             : usint;  (*BYTE to save*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SaveWord {HIDDEN} : bool
  VAR_INPUT
    data             : int;
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SaveDword {HIDDEN} : bool
  VAR_INPUT
    data             : udint;
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SaveWordArray {HIDDEN} : bool
  VAR_INPUT
    n                : int;  (*number of items*)
  END_VAR
  VAR_IN_OUT
    data             : int;  (*first item*)
    GrData           : TCanvasData;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SaveDwordArray {HIDDEN} : bool
  VAR_INPUT
    n                : usint;  (*number of items*)
  END_VAR
  VAR_IN_OUT
    data             : udint;  (*first item*)
    GrData           : TCanvasData;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SavePos {HIDDEN} : bool
  VAR_INPUT
    x                : int;
    y                : int;
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SaveAngle {HIDDEN} : bool
  VAR_INPUT
    angle            : real;  (*uhel ve stupnich*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SaveReal {HIDDEN} : bool
  VAR_INPUT
    data             : real;
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SaveString {HIDDEN} : bool
  VAR_IN_OUT
    in               : string [80];
    GrData           : TCanvasData;
  END_VAR
  VAR
    l                : uint;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SaveArray {HIDDEN} : bool
  VAR_IN_OUT
    in               : usint;
  END_VAR
  VAR_INPUT
    lenIn            : usint;
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_DataLen : uint
(*returns number of bytes saved in the canvas buffer*)
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Begin : bool
(*beginning of drawing, resets the buffer and unlocks it for writing*)
  VAR_INPUT
    SizeOfGrData     : udint;
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_End : bool
(*End of drawing, locks buffer for writing and enable its drawing
Returns TRUE if all graphical operations were successfully stored.*)
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
  VAR
    w                : PTR_TO uint;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_MacroBegin : bool
(*Function marks the beginning of block of graphics operations, which can then be re-run as a macro.
it can be used for reducing of occupied space in the graphics buffer if some sequences of graphics operations are repeated.
Index of macro (1-10) is parameter of function, its value is used to run the macro. Function GC_MacroEnd indicates end of macro.
All operations from GC_MacroBegin to GC_MacroEnd are skiped during graphics buffer data processing. They are processed only after macro is executed by function GC_MacroRun.*)
  VAR_INPUT
    index            : usint;  (*index of macro (1-10)*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_MacroEnd : bool
(*Funkce oznaèuje konec definice makra.*)
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_MacroRun : bool
(*Function executes a predefined macro.
After its completion continues with following graphic operation.*)
  VAR_INPUT
    index            : usint;  (*index of macro (1-10)*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SetLineWidth : bool
(*Function sets line width in pixels.*)
  VAR_INPUT
    width            : usint;  (*line width in pixels*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SetLineStyle : bool
(*Function sets style of line, its termination and connection.*)
  VAR_INPUT
    style            : usint;  (*style defined by constants  GLINE_...*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SetFillStyle : bool
(*Fucntion sets fill style.*)
  VAR_INPUT
    style            : usint;  (*style defined by constants  GFILL_...*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SetFgColor : bool
(*Function sets color of lines and text (foreground).*)
  VAR_INPUT
    color            : udint;  (*color stored in format UDINT (16#AABBGGRR)*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SetBgColor : bool
(*Function sets fill color (background).*)
  VAR_INPUT
    color            : udint;  (*color stored in format UDINT (16#AABBGGRR)*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SetTextSize : bool
(*Function sets the font height in pixels.*)
  VAR_INPUT
    size             : usint;  (*font height in pixels*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SetTextStyle : bool
(*Function allows to change font style, aligment of lines in multiline text and the way text is positioned relative to coordinates from which it should be printed.*)
  VAR_INPUT
    style            : uint;  (*style defined by constants  GTEXT_STYLE_...*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SetGradientStyle : bool
(*Function sets colors and style of color transition (gradient).
Fill style must be set to GFILL_STYLE_GRADIENT by function GC_SetFillStyle for gradient to be used instead of background color.*)
  VAR_INPUT
    color1           : udint;  (*begin color stored in format UDINT (16#AABBGGRR)*)
    color2           : udint;  (*end color stored in format UDINT (16#AABBGGRR)*)
    style            : usint;  (*style defined by constants  GGRADIENT_STYLE_...*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SetOrigin : bool
(*Function moves of the origin of coordinates (point 0, 0) to position of drawing pens. All coordinates are then understood as relative to this position.*)
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_ResetOrigin : bool
(*Function moves the origin of coordinates in the top left corner of the drawing area.*)
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SetVirtSize : bool
(*Function sets the size of the virtual drawing area.
Virtual area is placed on the canvas so that it has a maximum size while maintaining the aspect ratio and its center is identical with the center of the canvas.
Coordinates and dimensions of following graphics operations are set according to dimension of virtal area. Coordinates of touch/click are converted using the last entered dimension of virtual are. This feature allows to draw independently of the canvas size.
If both parameters are set to zero, default dimmesion of the canvas is restored.*)
  VAR_INPUT
    width            : int;  (*width of the virtual drawing area*)
    height           : int;  (*height of the virtual drawing area*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_MoveTo : bool
(*Function changes position of the drawing pen (without drawing).*)
  VAR_INPUT
    x                : int;  (*new coordinate X of the drawing pen*)
    y                : int;  (*new coordinate Y of the drawing pen*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Move : bool
(*Function changes position of the drawing pen relative to its original location (without drawing).*)
  VAR_INPUT
    x                : int;  (*relative change of the position on the X axis*)
    y                : int;  (*relative change of the position on the Y axis*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Point : bool
(**)
  VAR_INPUT
    x                : int;  (*coordinate X*)
    y                : int;  (*coordinate Y*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_LineTo : bool
(*Function draws line from current position of drawing pen to the point set by coordinates. Position of the drawing pen is moved to the end point.*)
  VAR_INPUT
    x                : int;  (*coordinate X of the end point*)
    y                : int;  (*coordinate Y of the end point*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Line : bool
(*Function draws line between two points. Position of the drawing pen is set to the end point.*)
  VAR_INPUT
    x1               : int;  (*coordinate X of the start point*)
    y1               : int;  (*coordinate Y of the start point*)
    x2               : int;  (*coordinate X of the end point*)
    y2               : int;  (*coordinate Y of the end point*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Box : bool
(*Draws rectangle.
        Drawing pen is moved to the center of the rectangle.*)
  VAR_INPUT
    fill             : bool;  (*draw filled*)
    x                : int;  (*X coordinate of the top left corner*)
    y                : int;  (*Y coordinate of the top left corner*)
    width            : int;  (*rectangle width*)
    height           : int;  (*rectangle height*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_CBox : bool
(*Draws rectangle with center at drawing pen position.
Rectangle is rotated by the angle set by the heading of the drawing pen.*)
  VAR_INPUT
    fill             : bool;  (*draw filled*)
    width            : int;  (*rectangle width*)
    height           : int;  (*rectangle height*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_RoundBox : bool
(*Draws rectangle with rounded corners.
        Drawing pen is moved to the center of the rectangle.*)
  VAR_INPUT
    fill             : bool;  (*draw filled*)
    x                : int;  (*X coordinate of the top left corner*)
    y                : int;  (*Y coordinate of the top left corner*)
    width            : int;  (*rectangle width*)
    height           : int;  (*rectangle height*)
    r                : int;  (*corner radius*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer  //*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_CRoundBox : bool
(*Draws rectangle with rounded corners with center at drawing pen position.
Rectangle is rotated by the angle set by the heading of the drawing pen.*)
  VAR_INPUT
    fill             : bool;  (*draw filled*)
    width            : int;  (*rectangle width*)
    height           : int;  (*rectangle height*)
    r                : int;  (*corner radius*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Triangle : bool
(*Draws a triangle defined by three points.
        Position of the drawing pen stays unchanged.*)
  VAR_INPUT
    fill             : bool;  (*draw filled*)
    x1               : int;  (*X coordinate of the first point*)
    y1               : int;  (*Y coordinate of the first point*)
    x2               : int;  (*X coordinate of the second point*)
    y2               : int;  (*Y coordinate of the second point*)
    x3               : int;  (*X coordinate of the third point*)
    y3               : int;  (*Y coordinate of the third point*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Polygon4 : bool
(*Draws a quadrilateral defined by four points.
        Position of the drawing pen stays unchanged.*)
  VAR_INPUT
    fill             : bool;  (*draw filled*)
    x1               : int;  (*X coordinate of the first point*)
    y1               : int;  (*Y coordinate of the first point*)
    x2               : int;  (*X coordinate of the second point*)
    y2               : int;  (*Y coordinate of the second point*)
    x3               : int;  (*X coordinate of the third point*)
    y3               : int;  (*Y coordinate of the third point*)
    x4               : int;  (*X coordinate of the fourth point*)
    y4               : int;  (*Y coordinate of the fourth point*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Polygon : bool
(*Draws a polygon. The coordinates of individual points are added by function GC_AddPoint.
        Position of the drawing pen stays unchanged.*)
  VAR_INPUT
    fill             : bool;  (*draw filled*)
    numPoints        : usint;  (*number of points*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_PolygonArray : bool
(*Draws a polygon. The coordinates of individual points are passed as array.
        Position of the drawing pen stays unchanged.*)
  VAR_INPUT
    fill             : bool;  (*draw filled*)
    numPoints        : usint;  (*number of points*)
  END_VAR
  VAR_IN_OUT
    points           : TCanvasPoint;  (*first point in array of points*)
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Arc : bool
(*Function draws an arc / elliptical sector. Drawing pen is moved to the center.*)
  VAR_INPUT
    fill             : bool;  (*draw filled*)
    x                : int;  (*X coordinate of the center point*)
    y                : int;  (*Y coordinate of the center point*)
    rx               : int;  (*radius on axis X*)
    ry               : int;  (*radius on axis Y*)
    angle            : real;  (*starting angle in degrees*)
    dangle           : real;  (*length of arc in degrees*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_CArc : bool
(*Function draws an arc / elliptical sector with center at position of the drawing pen.*)
  VAR_INPUT
    fill             : bool;  (*draw filled*)
    rx               : int;  (*radius on axis X*)
    ry               : int;  (*radius on axis Y*)
    angle            : real;  (*starting angle in degrees*)
    dangle           : real;  (*length of arc in degrees*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Circle : bool
(*Function draws a circle. Drawing pen is moved to the center.*)
  VAR_INPUT
    fill             : bool;  (*draw filled*)
    x                : int;  (*X coordinate of the center point*)
    y                : int;  (*X coordinate of the center point*)
    r                : int;  (*radius*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_CCircle : bool
(*Function draws a circle with center at position of the drawing pen.*)
  VAR_INPUT
    fill             : bool;  (*draw filled*)
    r                : int;  (*radius*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_CTriangle : bool
(*Function draws a triangle defined by three points around the position of the drawing pen rotated by the angle of the drawing pen.
The coordinates of individual points are relative to the position of the drawing pen. Position of the drawing pen stays unchanged.*)
  VAR_INPUT
    fill             : bool;  (*draw filled*)
    x1               : int;  (*X coordinate of the first point*)
    y1               : int;  (*Y coordinate of the first point*)
    x2               : int;  (*X coordinate of the second point*)
    y2               : int;  (*Y coordinate of the second point*)
    x3               : int;  (*X coordinate of the third point*)
    y3               : int;  (*Y coordinate of the third point*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_CPolygon4 : bool
(*Function draws a quadrilateral defined by four points around the position of the drawing pen rotated by the angle of the drawing pen.
The coordinates of individual points are relative to the position of the drawing pen. Position of the drawing pen stays unchanged.*)
  VAR_INPUT
    fill             : bool;  (*draw filled*)
    x1               : int;  (*X coordinate of the first point*)
    y1               : int;  (*Y coordinate of the first point*)
    x2               : int;  (*X coordinate of the second point*)
    y2               : int;  (*Y coordinate of the second point*)
    x3               : int;  (*X coordinate of the third point*)
    y3               : int;  (*Y coordinate of the third point*)
    x4               : int;  (*X coordinate of the fourth point*)
    y4               : int;  (*Y coordinate of the fourth point*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_CPolygon : bool
(*The function draws a polygon around the position of the drawing pen rotated by the angle of the drawing pen.
The coordinates of individual points are relative to the position of the drawing pen. The points are added using GC_AddPoint. Position of the drawing pen stays unchanged.*)
  VAR_INPUT
    fill             : bool;  (*draw filled*)
    numPoints        : usint;  (*number of points*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_CPolygonArray : bool
(*The function draws a polygon around the position of the drawing pen rotated by the angle of the drawing pen.
The coordinates of individual points are relative to the position of the drawing pen. The points are passed as array. Position of the drawing pen stays unchanged.*)
  VAR_INPUT
    fill             : bool;  (*draw filled*)
    numPoints        : usint;  (*number of points*)
  END_VAR
  VAR_IN_OUT
    points           : TCanvasPoint;  (*first point in array of points*)
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_AddPoint : bool
(*Function is used to add coordinates of individual point of a polygon. Function is called after functions GC_CPolygon and GC_Polygon.*)
  VAR_INPUT
    x                : int;  (*X coordinate*)
    y                : int;  (*Y coordinate*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_WriteText : bool
(*Function displays text from the position of the drawing pen. Text can also be multi-line, each line are separated by $n.
Font size can be set by function GC_SetTextSize functions, font style and how each line is aligned can be changed by function GC_SetTextStyle.
Change of drawing pen position varies depending on whether the text is displayed to the left, centered, or right from its position.*)
  VAR_INPUT
    text             : string [255];  (*text to be displayed*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_CWriteText : bool
(*Function displays text centered at the position of the drawing pen. Text can also be multi-line, each line are separated by $n.
Font size can be set by function GC_SetTextSize functions, font style and how each line is aligned can be changed by function GC_SetTextStyle.
Position of the drawing pen stays unchanged.*)
  VAR_INPUT
    text             : string [255];  (*text to be displayed*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Image : bool
(*Function displays an image, the upper left corner will be at the position of the drawing pen. The position of the drawing pen is moved to the center of the image.
The image must be associated with the canvas object.*)
  VAR_INPUT
    width            : int;  (*width of the displayed image (0 original size)*)
    height           : int;  (*height of the displayed image (0 original size)*)
    fileName         : string [80];  (*image name*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_CImage : bool
(*Function displays an image with center at the position of the drawing pen. Position of the drawing pen stays unchanged.
The image must be associated with the canvas object.*)
  VAR_INPUT
    width            : int;  (*width of the displayed image (0 original size)*)
    height           : int;  (*height of the displayed image (0 original size)*)
    fileName         : string [80];  (*long name of image associated with the canvas*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Heading : bool
(*Function set the angle of the drawing pen in degrees. A value of 0 corresponds to the rightward direction to the right, value of 90 downward direction.*)
  VAR_INPUT
    angle            : real;  (*new angle of the drawing pen in degrees*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Turn : bool
(*Function rotates angle of the drawing pen by the value specified in degrees. Positive values rotates pen clockwise, negative counterclockwise.*)
  VAR_INPUT
    angle            : real;  (*angle of rotation of pen in degrees*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_LineFwd : bool
(*Function draws a line of specified length from the position of the drawing pen using heading of the drawing pen. The position of the drawing pen moves to the end point of the line.*)
  VAR_INPUT
    length           : int;  (*length of line*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_MoveFwd : bool
(*Function moves position of the drawing pen by specified distance using heading of the drawing pen.*)
  VAR_INPUT
    length           : int;  (*distance between old and new position of the drawing pen*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_PushPosition : bool
(*Function stores current location of the drawing pen to the auxiliary stack.
Index of position in the stack is parameter of function. If the index is greater than 0 and less or equal to 10, the location is stored to this position.
If the index is equal to 0, old locations are shifted (data from index 1 - 9 is moved to indexes 2 - 10) and new location is stored to position with index 1 (top of the stack)*)
  VAR_INPUT
    index            : usint;  (*index of position in the stack (1 - 10) or the top of stack 0*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_PopPosition : bool
(*Function restores location of the drawing pen stored by function GC_PushPosition.
Index of position in the stack is parameter of function. If the index is greater than 0 and less or equal to 10, the location is restored from this position.
If the index is equal to 0, the location is restored from the top of stack (index 1) and old locations are shifted (data from index 2 - 10 is moved to indexes 1 - 9)*)
  VAR_INPUT
    index            : usint;  (*index of position in the stack (1 - 10) or the top of stack 0*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_PushHeading : bool
(*Function stores current heading of the drawing pen to the auxiliary stack.
Index of position in the stack is parameter of function. If the index is greater than 0 and less or equal to 10, the heading is stored to this position.
If the index is equal to 0, old headings are shifted (data from index 1 - 9 is moved to indexes 2 - 10) and new heading is stored to position with index 1 (top of the stack)*)
  VAR_INPUT
    index            : usint;  (*index of position in the stack (1 - 10) or the top of stack 0*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_PopHeading : bool
(*Function restores heading of the drawing pen stored by function GC_PushHeading.
Index of position in the stack is parameter of function. If the index is greater than 0 and less or equal to 10, the heading is restored from this position.
If the index is equal to 0, the heading is restored from the top of stack (index 1) and old headings are shifted (data from index 2 - 10 is moved to indexes 1 - 9)*)
  VAR_INPUT
    index            : usint;  (*index of position in the stack (1 - 10) or the top of stack 0*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_GraphLineArray : bool
(*Function draws data for a line graph.
Drawing starts at position of the drawing pen, Y coordinates of individual data points are relative to the position of the drawing pen.
Coordinates of individual points are passed as array of INT values.
The position of the drawing pen stays unchanged.*)
  VAR_INPUT
    params           : usint;  (*optional parameters, that modify graph presentation (constants GGRAPH_LINE_...)*)
    length           : int;  (*length of the graph line in pixels*)
    numPoints        : int;  (*number of data points*)
  END_VAR
  VAR_IN_OUT
    data             : int;  (*first element of the array of Y coordinates relative to position of the drawing pen*)
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_GraphLineRealArray : bool
(*Function draws data for a line graph.
Drawing starts at position of the drawing pen. This point is identical with the minimum of axes X and Y.
Coordinates of individual points are passed as array of REAL values. Coordinates are scaled according to minY and maxY.
The position of the drawing pen stays unchanged.*)
  VAR_INPUT
    params           : usint;  (*optional parameters, that modify graph presentation (constants GGRAPH_LINE_...)*)
    length           : int;  (*length of the graph line in pixels*)
    numPoints        : int;  (*number of data points*)
    height           : int;  (*height of graph in pixels*)
    minY             : real;  (*value of graph minimum*)
    maxY             : real;  (*value of graph maximum*)
  END_VAR
  VAR_IN_OUT
    data             : real;  (*first element of the array of Y coordinates*)
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
  VAR
    a                : int;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_GraphLine : bool
(*Function draws data for a line graph.
Drawing starts at position of the drawing pen, Y coordinates of individual data points are relative to the position of the drawing pen.
Coordinates of individual points are added using GC_GraphAddData.
The position of the drawing pen stays unchanged.*)
  VAR_INPUT
    params           : usint;  (*optional parameters, that modify graph presentation (constants GGRAPH_LINE_...)*)
    length           : int;  (*length of the graph line in pixels*)
    numPoints        : int;  (*number of data points*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_GraphBarsArray : bool
(*Function draws data for a bars graph.
Drawing starts at position of the drawing pen, Y coordinates of individual data points are relative to the position of the drawing pen.
Coordinates of individual points are passed as array of INT values.
The position of the drawing pen stays unchanged.*)
  VAR_INPUT
    params           : usint;  (*optional parameters, that modify graph presentation*)
    length           : int;  (*distance between centers of the first and the last bar in pixels*)
    barWidth         : int;  (*width of bars*)
    numPoints        : int;  (*number of data points*)
  END_VAR
  VAR_IN_OUT
    data             : int;  (*first element of the array of Y coordinates relative to position of the drawing pen*)
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_GraphBarsRealArray : bool
(*Function draws data for a bars graph.
Drawing starts at position of the drawing pen. This point is identical with the minimum of axes X and Y.
Coordinates of individual points are passed as array of REAL values. Coordinates are scaled according to minY and maxY.
The position of the drawing pen stays unchanged.*)
  VAR_INPUT
    params           : usint;  (*optional parameters, that modify graph presentation*)
    length           : int;  (*distance between centers of the first and the last bar in pixels*)
    barWidth         : int;  (*width of bars*)
    numPoints        : int;  (*number of data points*)
    height           : int;  (*height of graph in pixels*)
    minY             : real;  (*value of graph minimum*)
    maxY             : real;  (*value of graph maximum*)
  END_VAR
  VAR_IN_OUT
    data             : real;  (*first element of the array of Y coordinates*)
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
  VAR
    a                : int;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_GraphBars : bool
(*Function draws data for a bars graph.
Drawing starts at position of the drawing pen, Y coordinates of individual data points are relative to the position of the drawing pen.
Coordinates of individual points are added using GC_GraphAddData.
The position of the drawing pen stays unchanged.*)
  VAR_INPUT
    params           : usint;  (*optional parameters, that modify graph presentation*)
    length           : int;  (*distance between centers of the first and the last bar in pixels*)
    barWidth         : int;  (*width of bars*)
    numPoints        : int;  (*number of data points*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_GraphAddData : bool
(*Adds one data point to a graph. This function is used with functions GC_GraphBars and GC_GraphLine.*)
  VAR_INPUT
    data             : int;  (*Coordinate Y in pixels of the data point relative to the drawing pen position*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_RadialScale : bool
(*Function draws circular gauge scale*)
  VAR_INPUT
    radius           : int;  (*radius*)
    sAngle           : real;  (*start angle - corresponds to the minimum value*)
    eAngle           : real;  (*end angle - corresponds to the maximum value*)
    majorTickLen     : int;  (*length of the major tick with label (positive is drawn toward the center)*)
    minorTickLen     : int;  (*length of minor tick*)
    labelOffset      : usint;  (*space between label and tick*)
    labelDec         : usint;  (*number of label decimal places*)
    sVal             : real;  (*start value*)
    eVal             : real;  (*end value*)
    majorStep        : real;  (*step after which render major ticks*)
    labelAt          : real;  (*value with label*)
    labelStep        : usint;  (*step after which render labels*)
    stepDiv          : usint;  (*division step of major ticks for drawing minor ticks*)
    params           : int;  (*other parameters (constants GRSCALE ...)*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_LinearScale : bool
(*Function draws a linear scale*)
  VAR_INPUT
    length           : int;  (*length*)
    majorTickLen     : int;  (*length of major tick with label (positive is drawn to the left/bottom)*)
    minorTickLen     : int;  (*length of minor tick*)
    gridLength       : int;  (*length of grid line*)
    labelOffset      : usint;  (*space between label and tick*)
    labelDec         : usint;  (*number of label decimal places*)
    sVal             : real;  (*start value*)
    eVal             : real;  (*end value*)
    majorStep        : real;  (*step after which render major ticks*)
    labelAt          : real;  (*value with label*)
    labelStep        : usint;  (*step after which render labels*)
    stepDiv          : usint;  (*division step of major ticks for drawing minor ticks*)
    params           : int;  (*other parameters (constants GLSCALE ...)*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION RGBA_TO_Color : udint
(*Compose color from individual RGB components and transparency to UDINT format (16#AABBGGRR)*)
  VAR_INPUT
    R                : usint;  (*Red component (0-255)*)
    G                : usint;  (*Green component (0-255)*)
    B                : usint;  (*Blue component (0-255)*)
    A                : usint;  (*Transparency (0 - opaque, 255 - transparent)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION Color_TO_RGBA : bool
(*Decompose color in UDINT format (16#AABBGGRR) to individual RGB components and transparency*)
  VAR_INPUT
    color            : udint;  (*color stored in format UDINT (16#AABBGGRR)*)
  END_VAR
  VAR_IN_OUT
    R                : usint;  (*Red component (0-255)*)
    G                : usint;  (*Green component (0-255)*)
    B                : usint;  (*Blue component (0-255)*)
    A                : usint;  (*Transparency (0 - opaque, 255 - transparent)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION Alpha_TO_Color : udint
(*Sets transparency to a color stored in format UDINT (16#AABBGGRR) (0 - opaque, 255 - transparent)*)
  VAR_INPUT
    color            : udint;  (*color stored in format UDINT (16#AABBGGRR)*)
    alpha            : usint;  (*transparency (0 - opaque, 255 - transparent)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_GraphPolygonRealArray : bool
(*Draws a polygon as an XY graph. The coordinates of individual points are passed as array of coordinates X and Y.
Position of the drawing pen stays unchanged.*)
  VAR_INPUT
    fill             : bool;  (*draw filled*)
    numPoints        : usint;  (*number of points*)
    length           : int;  (*length of X axis in pixels*)
    height           : int;  (*lenght of Y axis in pixels*)
    minX             : real;  (*value of graph minimum on X axis*)
    maxX             : real;  (*value of graph maximum on X axis*)
    minY             : real;  (*value of graph minimum on Y axis*)
    maxY             : real;  (*value of graph maximum on Y axis*)
  END_VAR
  VAR_IN_OUT
    pointsX          : real;  (*first point in array of X coordinates*)
    pointsY          : real;  (*first point in array of Y coordinates*)
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
  VAR
    a                : int;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_GraphLineXYRealArray : bool
(*Draws a line as an XY graph. The coordinates of individual points are passed as array of coordinates X and Y.
Position of the drawing pen stays unchanged.*)
  VAR_INPUT
    x                : int;  (*coordinate X of the start point*)
    y                : int;  (*coordinate Y of the start point*)
    numPoints        : usint;  (*number of points*)
    length           : int;  (*length of X axis in pixels*)
    height           : int;  (*lenght of Y axis in pixels*)
    minX             : real;  (*value of graph minimum on X axis*)
    maxX             : real;  (*value of graph maximum on X axis*)
    minY             : real;  (*value of graph minimum on Y axis*)
    maxY             : real;  (*value of graph maximum on Y axis*)
  END_VAR
  VAR_IN_OUT
    pointsX          : real;  (*first point in array of X coordinates*)
    pointsY          : real;  (*first point in array of Y coordinates*)
    GrData           : TCanvasData;  (*reference to the canvas buffer*)
  END_VAR
END_FUNCTION



{LIBFILE="LOCALLIB\MODELLIB_V22_20171205.MLB"}
(* Mosaic IDE library *)
(* File name : D:\TecoUserLibs\ModelLib_V22_20171205.mlb *)
(* Library : ModelLib 2.2 *)
(* Author : Teco a.s. *)
(* Copyright : (c)2004-2017 *)
(* IEC compiler version : 3.12.15.1 *)
(* Assembler version : 4.3.00 *)

//{Knihovna : ModelLib 2.2  }
(* History: *)
(*
v1.0 2004-09-18 Byd First version of library
v1.1 2010-09-02 Byd Dependency on the libraries and comments added.
v1.2 2012-05-04 Byd Improved initialisation of fbSimplePID
v1.3 2012-09-21 Byd Improved fbSimplePID, added fbStepControl
v1.4 2012-11-08 Byd Added fbStepControl improved minimal pulse time control
v1.5 2012-11-14 Byd fbSimplePID behaviour in saturation corrected
v1.6 2013-11-27 Byd In saturation outputs Open/Close of fbStepControl is set 
permanently
(before they were reset if duration of saturation was longer than t0100)
v1.7 2014-11-21 Byd fbSimplePID derivative component action suppressed during 
initialization
v1.8 2016-06-09 Byd Changed timing algorithm to handle a state when function blocks are not 
called every PLC cycle
v1.9 2016-11-01 Byd Added handling of inputs like NaN for fbSimplePID
v2.0 2017-06-30 Byd Added handling of inputs like NaN for fbLimIntegrator, fbIntegrator, fbDerivator, fbFirstOrder, fbSecondOrder and fbSecondOrderOsc.
v2.1 2017-11-16 Byd fbSimplePID block was modified so that actuator value would start at u_man after first execution.
v2.2 2017-12-05 Byd Modified transition from manual to automatic mode inside dead band. 
		    Seamless transition is still computed when it exits dead band but current value of the output 'u' is used for the calculation, not the current value of 'u_man'.
*)

(*----------------------------------------------------------------------------*)
// {LIBRARY="LOCALLIB\REXLIB_V17_20101208.MLB"}

__DECL FUNCTION fcModelLibInvalidReal {HIDDEN} : bool
  VAR_INPUT
    r                : real;
  END_VAR
END_FUNCTION

TYPE  GenericArrayForDelay : ARRAY [0..1023] OF real;  (*Generic type for VAR_IN_OUT*)
END_TYPE

__DECL FUNCTION fcHiddenModelLibDoStep {HIDDEN} : bool
(*Auxiliary function for controlling periodic execution*)
  VAR_INPUT
    T                : real;
  END_VAR
  VAR_IN_OUT
    LastT            : time;
  END_VAR
END_FUNCTION

__DECL FUNCTION_BLOCK fbLimIntegrator
(*Simulation of integral of input with limits.
  Calculated by left-endpoint rectangular approximation method (LRAM).

            1    /t
  Out(t) = --- * |  In(t) dt + Preset
            Ti   /0

  Approximation:

  Out(k) = Out(k-1) + (T/Ti) * In(k) + Preset*)
  VAR_INPUT
    In               : real;  (*Input*)
    MinO             : real;  (*Limits*)
    MaxO             : real;  (*Limits*)
    T                : real :=  0.100;  (*Sample period [s]*)
    Preset           : real;  (*Initial value for output*)
    Reset            : bool R_EDGE;  (*Reset output to initial value*)
  END_VAR
  VAR_OUTPUT
    Out              : real;  (*Output*)
  END_VAR
  VAR
    Init             : bool;  (*Initialization flag (true means initialized)*)
    LastT            : time;  (*Last time of block execution*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbIntegrator
(*Simulation of integral of input.
  Calculated by left-endpoint rectangular approximation method (LRAM).

           /t
  Out(t) = |  In(t) dt + Preset
           /0

  Approximation:

  Out(k) = Out(k-1) + T * In(k) + Preset*)
  VAR_INPUT
    In               : real;  (*Input*)
    T                : real :=  0.1;  (*Sample period [s]*)
    Preset           : real;  (*Initial value for output*)
    Reset            : bool R_EDGE;  (*Reset output to initial value*)
  END_VAR
  VAR_OUTPUT
    Out              : real;  (*Output*)
  END_VAR
  VAR
    Init             : bool;  (*Initialization flag (true means initialized)*)
    LastT            : time;  (*Last time of block execution*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbDerivator
(*Simulation of derivation of input. Calculated by trapezoid
  approximation method (TAM).

                  d
  Out(t) = In(t) ---
                  dt

  Approximation:

  Out(k) = (In(k) - In(k-1)) / T*)
  VAR_INPUT
    In               : real;  (*Input*)
    T                : real :=  0.1;  (*Sample period [s]*)
  END_VAR
  VAR_OUTPUT
    Out              : real;  (*Output*)
  END_VAR
  VAR
    Init             : bool;  (*Initialization flag (true means initialized)*)
    LastT            : time;  (*Last time of block execution*)
    Last_In          : real;  (*Last input value (In(k-1))*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbDelay
(*Simulation of transport delay of input.

  Out(t) = In(t - Tau)
  Tau = T*K

  Approximation:

  Out(k) = In(k-K)*)
  VAR_INPUT
    In               : real;  (*Input*)
    K                : int;  (*Multiples of sample period determining transport delay (max 1024)*)
    T                : real :=  0.1;  (*Sample period [s]*)
  END_VAR
  VAR_OUTPUT
    Out              : real;  (*Output*)
  END_VAR
  VAR_IN_OUT
    Buffer           : GenericArrayForDelay;  (*Samples buffer [0..max.1023] of REAL*)
  END_VAR
  VAR
    LastT            : time;  (*Last time of block execution*)
    Point            : int;  (*Pointer to buffer*)
    Init             : bool;  (*Initialization flag (true means initialized)*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbFirstOrder
(*Simulation of first-order system described by differential equation

       d Out(t)
  T1 * -------- + Out(t) = G * In
          dt

  or by laplace domain equation

  OUT(s) * [T1 * s + 1] = G * IN(s)*)
  VAR_INPUT
    In               : real;  (*Input*)
    G                : real :=  1.0;  (*Gain*)
    T1               : real :=  1.0;  (*Time constant [s]*)
    T                : real :=  0.1;  (*Sample period [s]*)
    Preset           : real;  (*Initial value for output*)
    Reset            : bool R_EDGE;  (*Reset output to initial value*)
  END_VAR
  VAR_OUTPUT
    Out              : real;  (*Output*)
  END_VAR
  VAR
    Init             : bool;  (*Initialization flag (true means initialized)*)
    LastT            : time;  (*Last time of block execution*)
    Exp1             : real;  (*Constant evaluated by time constant*)
    OldT1            : real;  (*Old time constant - for change tracking*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbSecondOrder
(*Simulation of second-order system described by differential equation

          d^2 Out(t)             d Out(t)
  T1 * T2 ---------- + (T1 + T2) -------- + Out(t) = G * In(t)
             dt^2                   dt

  or by laplace domain equation

  OUT(s) * [T1 * T2 * s^2 + (T1 + T2) * s + 1] = G * IN(s)*)
  VAR_INPUT
    In               : real;  (*Input*)
    G                : real :=  1.0;  (*Gain*)
    T1               : real :=  1.0;  (*Time constant [s]*)
    T2               : real :=  1.0;  (*Time constant [s]*)
    T                : real :=  0.1;  (*Sample period [s]*)
    Preset           : real;  (*Initial value for output*)
    Reset            : bool R_EDGE;  (*Reset output to initial value*)
  END_VAR
  VAR_OUTPUT
    Out              : real;  (*Output*)
  END_VAR
  VAR
    Init             : bool;  (*Initialization flag (true means initialized)*)
    LastT            : time;  (*Last time of block execution*)
    a                : real;  (*Auxiliary constants*)
    b                : real;  (*Auxiliary constants*)
    c                : real;  (*Auxiliary constants*)
    d                : real;  (*Auxiliary constants*)
    OldT1            : real;  (*Old time constant - for change tracking*)
    OldT2            : real;  (*Old time constant - for change tracking*)
    LastIn           : real;  (*Last input*)
    LastOut          : real;  (*Output to step older*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbSecondOrderOsc
(*Block for simulation of second-order oscillating system described by
  differential equation

              d^2 Out(t)                 d Out(t)
  (1 / Omg^2) ---------- + 2 * Alp / Omg -------- + Out(t) = G * In(t)
                 dt^2                       dt

  or by laplace domain equation

  OUT(s) * [(1 / Omg^2) * s^2  + 2 * Alp / Omg * s + 1] = G * IN(s)*)
  VAR_INPUT
    In               : real;  (*Input*)
    G                : real :=  1.0;  (*Gain*)
    Alp              : real :=  0.25;  (*Damping ratio*)
    Omg              : real :=  4.0;  (*Natural frequency [1/(rad * s)]*)
    T                : real :=  0.1;  (*Sample period [s]*)
    Preset           : real;  (*Initial value for output*)
    Reset            : bool R_EDGE;  (*Reset output to initial value*)
  END_VAR
  VAR_OUTPUT
    Out              : real;  (*Output*)
  END_VAR
  VAR
    i1               : fbIntegrator;
    i2               : fbIntegrator;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbSimplePID
(*PID algorithm with antiwind-up and filtered D-part
  described by laplace domain equation

                /          1              Td * s        \
  U(s) = Gain * | E(s) + ------ E(s) - ----------- Y(s) |
                \        Ti * s         Tf * s + 1      /*)
  VAR_INPUT
    y                : real;  (*Measured value*)
    w                : real;  (*Set point*)
    u_man            : real;  (*Manual output value*)
    min_u            : real :=  0.0;  (*Output low limit*)
    max_u            : real :=  100.0;  (*Output high limit*)
    Gain             : real :=  1.0;  (*Proporcional gain*)
    Ti               : real :=  10.0;  (*Integration time constant [s]*)
    Td               : real :=  1.0;  (*Derivative time constant [s]*)
    T                : real :=  0.1;  (*Sample periode [s]*)
    Tf               : real :=  0.25;  (*D-part filter time constant [s]*)
    dz               : real;  (*Symetric dead zone*)
    manual           : bool;  (*Manual mode (0 - automatic mode, 1 - manual mode)*)
    IH               : bool;  (*Integrator hold (0 - intergator enabled, 1 - integrator hold)*)
  END_VAR
  VAR_OUTPUT
    u                : real;  (*Actuator value*)
    uvel             : real;  (*Speed of actuator*)
    partP            : real;  (*Value of proportional part*)
    partI            : real;  (*Value of integral part*)
    partD            : real;  (*Value of derivative part*)
    e                : real;  (*Deviation (error) value*)
    auto             : bool;  (*Controller mode (0 - manual mode, 1 - automatic mode)*)
    satmax           : bool;  (*Output is saturated at maximal value*)
    satmin           : bool;  (*Output is saturated at minimal value*)
  END_VAR
  VAR
    wasman           : bool;  (*flag for change from manual mode*)
    Init             : bool;  (*initialization flag (true means initialized)*)
    e_1              : real;  (*last deviation*)
    y_p              : real;  (*filtered input*)
    y_1              : real;  (*last output*)
    LastT            : time;  (*last execution time*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK _STEP_CONTROL_POS_SIM_
(*Auxiliary block
do not use standalone*)
  VAR_INPUT
    o                : bool;
    c                : bool;
    fo               : bool;
    fc               : bool;
    t0100            : real;
  END_VAR
  VAR
    LT               : time;
    timdif           : real;
    virPos           : real;
    INIT             : bool;
  END_VAR
  VAR_OUTPUT
    so               : bool;
    sc               : bool;
    pos              : real;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbStepControl
(*Actuator step control for fbSimplePID*)
  VAR_INPUT
    Pos              : real;  (*Actuator set point*)
    PosVel           : real;  (*Velocity of actuator set point*)
    HiSw             : bool;  (*Switch of fully open position*)
    LoSw             : bool;  (*Switch of fully close position*)
    t0100            : real :=  30.0;  (*Time of transition from fully close to fully open position in seconds*)
    tmin             : real :=  0.5;  (*Minimal length of pulse and duration between pulses in seconds*)
    t01min           : real :=  2.0;  (*Minimal time between pulses of oposite direction in seconds*)
  END_VAR
  VAR_OUTPUT
    Open             : bool;  (*Request to open*)
    Close            : bool;  (*Request to close*)
    Run              : bool;  (*Actuator is running (logical disjunction of requests to open and close)*)
    VirPos           : real;  (*Computed virtual position of actuator*)
  END_VAR
  VAR
    wasOpen          : bool;
    wasClose         : bool;
    Idle             : bool;
    t0               : TON;  (*_TIM_REAL_;*)
    t1               : TON;  (*_TIM_REAL_;*)
    ps               : _STEP_CONTROL_POS_SIM_;
  END_VAR
END_FUNCTION_BLOCK

TYPE TGeneratorSignalType : 
  (gst_Sin,
   gst_Square,
   gst_Saw,
   gst_DblSaw 
  );
END_TYPE

__DECL FUNCTION_BLOCK fbGenerator
(*Signal generator*)
  VAR_INPUT
    Zero             : real;  (*Zero level*)
    Amp              : real :=  1.0;  (*Output signal amplitude*)
    Per              : real :=  1.0;  (*Output signal period [s]*)
    SType            : TGeneratorSignalType;  (*Type of output signal*)
    Reset            : bool R_EDGE;  (*Generator reset*)
  END_VAR
  VAR_OUTPUT
    Out              : real;  (*Generator output*)
  END_VAR
  VAR
    Init             : bool;
    Start            : time;
    Phase            : real;
  END_VAR
END_FUNCTION_BLOCK



{LIBFILE="LOCALLIB\COLORLIB_V12_20160316.MLB"}
(* Mosaic IDE library *)
(* File name : D:\TecoUserLibs\ColorLib_V12_20160316.mlb *)
(* Library : ColorLib 1.2 *)
(* Author : Teco *)
(* Copyright : Teco (c) 2014-2016 *)
(* IEC compiler version : 3.11.3.0 *)
(* Assembler version : 4.3.00 *)

//{Knihovna : ColorLib 1.2  }
(* History: *)
(*
v1.0 2014-09-09 Byd - first version
v1.1 2016-03-16 Byd - added functions ShadeToWhite a ShadeToBlack
v1.2 2016-03-24 Byd - added functions MixColors
*)

(*----------------------------------------------------------------------------*)
// {LIBRARY="LOCALLIB\STDLIB_V20_20100519.MLB"}
// {LIBRARY="LOCALLIB\SIGNALADAPT_V11_20101206.MLB"}

TYPE TColorModelRGB :
  STRUCT
    Red              : real;  (*Red (0-1)*)
    Green            : real;  (*Green (0-1)*)
    Blue             : real;  (*Blue (0-1)*)
  END_STRUCT;
END_TYPE

TYPE TColorModelHSV :
  STRUCT
    Hue              : real;  (*Hue (0-360)*)
    Saturation       : real;  (*Saturation (0-1)*)
    Value            : real;  (*Value (0-1)*)
  END_STRUCT;
END_TYPE

TYPE TColorModelHSL :
  STRUCT
    Hue              : real;  (*Hue (0-360)*)
    Saturation       : real;  (*Saturation (0-1)*)
    Lightness        : real;  (*Lightness (0-1)*)
  END_STRUCT;
END_TYPE

TYPE TColorModelLCH :
  STRUCT
    Luma             : real;  (*Luma (0-1)*)
    Chroma           : real;  (*Chroma (0-1)*)
    Hue              : real;  (*Hue (0-360)*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION HSV_TO_RGB : TColorModelRGB
(*Converts HSV color model to RGB*)
  VAR_INPUT
    HSV              : TColorModelHSV;  (*Color described by HSV color model*)
  END_VAR
END_FUNCTION

__DECL FUNCTION HSL_TO_RGB : TColorModelRGB
(*Converts HSL color model to RGB*)
  VAR_INPUT
    HSL              : TColorModelHSL;  (*Color described by HSL color model*)
  END_VAR
END_FUNCTION

__DECL FUNCTION LCH_TO_RGB : TColorModelRGB
(*Converts LCH color model to RGB*)
  VAR_INPUT
    LCH              : TColorModelLCH;  (*Color described by LCH color model*)
  END_VAR
END_FUNCTION

__DECL FUNCTION RGB_TO_HSV : TColorModelHSV
(*Converts RGB color model to HSV*)
  VAR_INPUT
    RGB              : TColorModelRGB;  (*Color described by RGB color model*)
  END_VAR
END_FUNCTION

__DECL FUNCTION RGB_TO_HSL : TColorModelHSL
(*Converts RGB color model to HSL*)
  VAR_INPUT
    RGB              : TColorModelRGB;  (*Color described by RGB color model*)
  END_VAR
END_FUNCTION

__DECL FUNCTION RGB_TO_LCH : TColorModelLCH
(*Converts RGB color model to LCH*)
  VAR_INPUT
    RGB              : TColorModelRGB;  (*Color described by RGB color model*)
  END_VAR
END_FUNCTION

__DECL FUNCTION HSV_TO_Color : udint
(*Converts color described by HSV color model to color stored in UDINT data type (16#BBGGRR)*)
  VAR_INPUT
    HSV              : TColorModelHSV;  (*Color described by HSV color model*)
  END_VAR
END_FUNCTION

__DECL FUNCTION HSL_TO_Color : udint
(*Converts color described by HSL color model to color stored in UDINT data type (16#BBGGRR)*)
  VAR_INPUT
    HSL              : TColorModelHSL;  (*Color described by HSL color model*)
  END_VAR
END_FUNCTION

__DECL FUNCTION LCH_TO_Color : udint
(*Converts color described by LCH color model to color stored in UDINT data type (16#BBGGRR)*)
  VAR_INPUT
    LCH              : TColorModelLCH;  (*Color described by LCH color model*)
  END_VAR
END_FUNCTION

__DECL FUNCTION Color_TO_RGB : TColorModelRGB
(*Converts color stored in UDINT data type (16#BBGGRR) to RGB color model*)
  VAR_INPUT
    Color            : udint;  (*Color stored in UDINT data type (16#BBGGRR)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION Color_TO_HSV : TColorModelHSV
(*Converts color stored in UDINT data type (16#BBGGRR) to HSV color model*)
  VAR_INPUT
    Color            : udint;  (*Color stored in UDINT data type (16#BBGGRR)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION Color_TO_HSL : TColorModelHSL
(*Converts color stored in UDINT data type (16#BBGGRR) to HSL color model*)
  VAR_INPUT
    Color            : udint;  (*Color stored in UDINT data type (16#BBGGRR)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION Color_TO_LCH : TColorModelLCH
(*Converts color stored in UDINT data type (16#BBGGRR) to LCH color model*)
  VAR_INPUT
    Color            : udint;  (*Color stored in UDINT data type (16#BBGGRR)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION RGB_TO_Color : udint
(*Converts color described by RGB color model to color stored in UDINT data type (16#BBGGRR)*)
  VAR_INPUT
    RGB              : TColorModelRGB;  (*Color described by RGB color model*)
  END_VAR
END_FUNCTION

__DECL FUNCTION ShadeColor : udint
(*Changes lightness of color stored in UDINT data type (16#BBGGRR), highest byte stays unchanged*)
  VAR_INPUT
    color            : udint;  (*vstupni barva*)
    light            : real;  (*koeficient zesvetlani barvy (1.0 = puvodni barva)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION ShadeToWhite : udint
(*Changes lightness of color stored in UDINT data type (16#BBGGRR) by adding white, highest byte stays unchanged*)
  VAR_INPUT
    color            : udint;  (*vstupni barva*)
    white            : real;  (*podíl pøidané bílé (0.0 = pùvodní barva, 1.0 = bílá)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION ShadeToBlack : udint
(*Changes lightness of color stored in UDINT data type (16#BBGGRR) by adding black, highest byte stays unchanged*)
  VAR_INPUT
    color            : udint;  (*vstupni barva*)
    black            : real;  (*podíl pøidané èerné (0.0 = pùvodní barva, 1.0 = èerná)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION MixColors : udint
(*Mixes two colors stored in UDINT data type (16#BBGGRR) by specified ratio*)
  VAR_INPUT
    color1           : udint;  (*vstupni barva 1*)
    color2           : udint;  (*vstupni barva 2*)
    ratio            : real;  (*pomìr barev (0.0 = vstupni barva 1, 1.0 = vstupni barva 2)*)
  END_VAR
END_FUNCTION



{LIBFILE="LOCALLIB\TOSTRINGLIB_V13_20110203.MLB"}
(* Mosaic IDE library *)
(* File name : c:\Program Files\Common Files\Mosaic\Lib\ToStringLib_V13_20110203.mlb *)
(* Library : ToStringLib 1.3 *)
(* Author : Teco a.s. Kolin *)
(* Copyright : (c) 2004..2009 Teco a.s. *)
(* IEC compiler version : 3.8.13.3 *)
(* Assembler version : 4.3.00 *)

//{Knihovna : ToStringLib 1.3  }
(* History: *)
(*
v1.0 2009-02-04 Nem  first edition
v1.1 2010-10-27 Nem  czech comments added
v1.2 2010-12-06 Nem  english comments added
v1.3 2011-02-03 Nem  added function BOOL_TO_STRINGF
*)

(*----------------------------------------------------------------------------*)

__DECL FUNCTION USINT_TO_STRINGF : string
(*
  Conversion USINT to formatted STRING
  Format example : '%4u'
*)
  VAR_INPUT
    in               : usint;
    format           : string [80];  (* format string*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SINT_TO_STRINGF : string
(*
  Conversion SINT to formatted STRING
  Format example : '%4d'
*)
  VAR_INPUT
    in               : sint;
    format           : string [80];  (* format string*)
  END_VAR
END_FUNCTION

__DECL FUNCTION UINT_TO_STRINGF : string
(*
  Conversion UINT to formatted STRING
  Format example : '%5u'
*)
  VAR_INPUT
    in               : uint;
    format           : string [80];  (* format string*)
  END_VAR
END_FUNCTION

__DECL FUNCTION INT_TO_STRINGF : string
(*
  Conversion INT to formatted STRING
  Format example : '%5d'
*)
  VAR_INPUT
    in               : int;
    format           : string [80];  (* format string*)
  END_VAR
END_FUNCTION

__DECL FUNCTION UDINT_TO_STRINGF : string
(*
  Conversion UDINT to formatted STRING
  Format example : '%6u'
*)
  VAR_INPUT
    in               : udint;
    format           : string [80];  (* format string*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DINT_TO_STRINGF : string
(*
  Conversion DINT to formatted STRING
  Format example : '%6d'
*)
  VAR_INPUT
    in               : dint;
    format           : string [80];  (* format string*)
  END_VAR
END_FUNCTION

__DECL FUNCTION REAL_TO_STRINGF : string
(*
  Conversion REAL to formatted STRING
  Format example : '%6.1f'
*)
  VAR_INPUT
    in               : real;
    format           : string [80];  (* format string*)
  END_VAR
END_FUNCTION

__DECL FUNCTION LREAL_TO_STRINGF : string
(*
  Conversion LREAL to formatted STRING
  Format example : '%6.1f'
*)
  VAR_INPUT
    in               : lreal;
    format           : string [80];  (* format string*)
  END_VAR
END_FUNCTION

__DECL FUNCTION BYTE_TO_STRINGF : string
(*
  Conversion BYTE to formatted STRING
  Format example : '%02X'
*)
  VAR_INPUT
    in               : byte;
    format           : string [80];  (* format string*)
  END_VAR
END_FUNCTION

__DECL FUNCTION WORD_TO_STRINGF : string
(*
  Conversion WORD to formatted STRING
  Format example : '%04X'
*)
  VAR_INPUT
    in               : word;
    format           : string [80];  (* format string*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DWORD_TO_STRINGF : string
(*
  Conversion DWORD to formatted STRING
  Format example : '%08X'
*)
  VAR_INPUT
    in               : dword;
    format           : string [80];  (* format string*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DATE_TO_STRINGF : string
(*
  Conversion DATE to formatted STRING
  Format example : '%TYYYY-MM-DD'
*)
  VAR_INPUT
    in               : date;
    format           : string [80];  (* format string*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DT_TO_STRINGF : string
(*
  Conversion DATE_AND_TIME to formatted STRING
  Format example : '%TYYYY-MM-DD-hh:mm:ss'
*)
  VAR_INPUT
    in               : dt;
    format           : string [80];  (* format string*)
  END_VAR
END_FUNCTION

__DECL FUNCTION TIME_TO_STRINGF : string
(*
  Conversion TIME to formatted STRING
  Format example : '%Thh:mm:ss.zzz'
*)
  VAR_INPUT
    in               : time;
    format           : string [80];  (* format string*)
  END_VAR
END_FUNCTION

__DECL FUNCTION TOD_TO_STRINGF : string
(*
  Conversion TIME_OF_DAY to formatted STRING
  Format example : '%Thh:mm:ss.zzz'
*)
  VAR_INPUT
    in               : tod;
    format           : string [80];  (* format string*)
  END_VAR
END_FUNCTION

__DECL FUNCTION BOOL_TO_STRINGF : string
(*
  Conversion BOOL to formatted STRING
  Format example : '%b'
*)
  VAR_INPUT
    in               : bool;
    format           : string [80];  (* format string*)
  END_VAR
END_FUNCTION



{LIBFILE="LOCALLIB\TIMELIB_V15_20170216.MLB"}
(* Mosaic IDE library *)
(* File name : D:\TecoUserLibs\TimeLib_V15_20170216.mlb *)
(* Library : TimeLib 1.5 *)
(* Author : Teco a.s. *)
(* Copyright : (c) 2010 - 2017 Teco a.s. *)
(* IEC compiler version : 3.12.10.2 *)
(* Assembler version : 4.3.00 *)

//{Knihovna : TimeLib 1.5  }
(* History: *)
(*
v1.0 2010-11-18 Nem First edition
v1.1 2011-01-20 Nem Corrected function Year_of_DT()
v1.2 2011-06-10 Nem New function GetDateAndTime_RFC2822()
v1.3 2012-11-30 Nem Added new function WeekNumber() and TIME_TO_REALsec()
v1.4 2013-07-24 Byd Added functions for LONG_TIME
v1.5 2017-02-16 Byd Modified GetDateAndTime_RFC2822() function for negative UTC time offsets
*)

(*----------------------------------------------------------------------------*)

TYPE LONGTIME :
  STRUCT  (*Typ pro popis dlouhých èasových úsekù*)
    Days             : dint;  (*Number of days*)
    TimeOfDay        : time;  (*Time in day*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION DATE_OF_DT : date
(*Get DATE from variable DATE_AND_TIME*)
  VAR_INPUT
    in               : dt;  (*Input variable*)
  END_VAR
END_FUNCTION

__DECL FUNCTION TIME_OF_DT : time
(*Get DATE from variable DATE_AND_TIME*)
  VAR_INPUT
    in               : dt;  (*Input variable*)
  END_VAR
END_FUNCTION

__DECL FUNCTION YEAR_OF_DT : uint
(*Get year from variable DATE_AND_TIME*)
  VAR_INPUT
    in               : dt;  (*Input variable*)
  END_VAR
  VAR
    s                : string [30];
  END_VAR
END_FUNCTION

__DECL FUNCTION MONTH_OF_DT : usint
(*Get month from variable DATE_AND_TIME*)
  VAR_INPUT
    in               : dt;  (*Input variable*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DAY_OF_DT : usint
(*Get day from variable DATE_AND_TIME*)
  VAR_INPUT
    in               : dt;  (*Input variable*)
  END_VAR
END_FUNCTION

__DECL FUNCTION HOUR_OF_DT : usint
(*Get hours from variable DATE_AND_TIME*)
  VAR_INPUT
    in               : dt;  (*Input variable*)
  END_VAR
END_FUNCTION

__DECL FUNCTION MIN_OF_DT : usint
(*Get minutes from variable DATE_AND_TIME*)
  VAR_INPUT
    in               : dt;  (*Input variable*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SEC_OF_DT : usint
(*Get seconds from variable DATE_AND_TIME*)
  VAR_INPUT
    in               : dt;  (*Input variable*)
  END_VAR
END_FUNCTION

__DECL FUNCTION MSEC_OF_DT : uint
(*Get milliseconds from variable DATE_AND_TIME*)
  VAR_INPUT
    in               : dt;  (*Input variable*)
  END_VAR
END_FUNCTION

__DECL FUNCTION CutMSec_From_DT : dt
(*Cut milliseconds from variable DATE_AND_TIME*)
  VAR_INPUT
    in               : dt;  (*Input variable*)
  END_VAR
END_FUNCTION

__DECL FUNCTION CutSec_From_DT : dt
(*Cut seconds from variable DATE_AND_TIME*)
  VAR_INPUT
    in               : dt;  (*Input variable*)
  END_VAR
END_FUNCTION

__DECL FUNCTION YEAR_OF_DATE : uint
(*Get year from variable DATE*)
  VAR_INPUT
    in               : date;  (*Input variable*)
  END_VAR
END_FUNCTION

__DECL FUNCTION MONTH_OF_DATE : usint
(*Get month from variable DATE*)
  VAR_INPUT
    in               : date;  (*Input variable*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DAY_OF_DATE : usint
(*Get day from variable DATE*)
  VAR_INPUT
    in               : date;  (*Input variable*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DAY_OF_YEAR : uint
(*Get day of year from variable DATE*)
  VAR_INPUT
    in               : date;  (*Input variable*)
  END_VAR
  VAR
    year             : uint;
    tmp              : string [80];
    yearD            : date;
    secOfYear        : lreal;
  END_VAR
END_FUNCTION

__DECL FUNCTION HOUR_OF_TIME : usint
(*Get hours from variable TIME*)
  VAR_INPUT
    in               : time;  (*Input variable*)
  END_VAR
END_FUNCTION

__DECL FUNCTION MIN_OF_TIME : usint
(*Get minutes from variable TIME*)
  VAR_INPUT
    in               : time;  (*Input variable*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SEC_OF_TIME : usint
(*Get seconds from variable TIME*)
  VAR_INPUT
    in               : time;  (*Input variable*)
  END_VAR
END_FUNCTION

__DECL FUNCTION MSEC_OF_TIME : uint
(*Get milliseconds from variable TIME*)
  VAR_INPUT
    in               : time;  (*Input variable*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DecodeTime : bool
(*Convert TIME to hours, minutes, seconds and milliseconds*)
  VAR_INPUT
    in               : time;  (*Input variable*)
  END_VAR
  VAR_IN_OUT
    H                : usint;  (*Hours*)
    M                : usint;  (*Minutes*)
    S                : usint;  (*Seconds*)
    Ms               : uint;  (*Milliseconds*)
  END_VAR
END_FUNCTION

__DECL FUNCTION EncodeTime : time
(*Convert hours, minutes, seconds and milliseconds to TIME*)
  VAR_INPUT
    H                : usint;  (*Hours*)
    M                : usint;  (*Minutes*)
    S                : usint;  (*Seconds*)
    Ms               : uint;  (*Milliseconds*)
  END_VAR
END_FUNCTION

__DECL FUNCTION MUL_TIME_REAL : time
(*Returns result of multiplication of time IN1 by number IN2*)
  VAR_INPUT
    IN1              : time;  (*Time to be multiplied*)
    IN2              : real;  (*Multiplier*)
  END_VAR
END_FUNCTION

__DECL FUNCTION MUL_TIME_LREAL : time
(*Returns result of multiplication of time IN1 by number IN2*)
  VAR_INPUT
    IN1              : time;  (*Time to be multiplied*)
    IN2              : lreal;  (*Multiplier*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DIV_TIME_REAL : time
(*Returns result of division of time IN1 by number IN2*)
  VAR_INPUT
    IN1              : time;  (*Time to be divided*)
    IN2              : real;  (*Divisor*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DIV_TIME_LREAL : time
(*Returns result of division of time IN1 by number IN2*)
  VAR_INPUT
    IN1              : time;  (*Time to be divided*)
    IN2              : lreal;  (*Divisor*)
  END_VAR
END_FUNCTION

VAR_GLOBAL CONSTANT
 MonthsNamesRFC2822 : ARRAY [1..12] OF string [3] :=   ['Jan', 'Feb', 'Mar', 'Apr',
                                                       'May', 'Jun', 'Jul', 'Aug',
                                                       'Sep', 'Oct', 'Nov', 'Dec'];

END_VAR

__DECL FUNCTION GetDateAndTime_RFC2822 : string [26]
(*returns date and time according to RFC2822

  date time

  date            =       day month year
  year            =       4 DIGIT
  month           =       month-name
  month-name      =       "Jan" / "Feb" / "Mar" / "Apr" /
                          "May" / "Jun" / "Jul" / "Aug" /
                          "Sep" / "Oct" / "Nov" / "Dec"
  day             =       1-2 DIGIT
  time            =       time-of-day zone
  time-of-day     =       hour ":" minute ":" second
  hour            =       2 DIGIT
  minute          =       2 DIGIT
  second          =       2 DIGIT
  zone            =       (( "+" / "-" ) 4 DIGIT)*)
  VAR_INPUT
    UtcOff           : int;  (*Offset from UTC in minutes*)
  END_VAR
  VAR
    Format           : string [80];
  END_VAR
END_FUNCTION

__DECL FUNCTION WeekNumber : usint
(*Week number according to the ISO-8601 standard, weeks starting on Monday*)
  VAR_INPUT
    IN               : dt;  (*Time for calculation of week number*)
  END_VAR
END_FUNCTION

__DECL FUNCTION TIME_TO_REALsec : real
(*Conversion of time to seconds*)
  VAR_INPUT
    IN               : time;  (*Time*)
  END_VAR
END_FUNCTION

__DECL FUNCTION LONGTIME_TO_LREAL : lreal
(*Conversion of LONGTIME type to seconds*)
  VAR_INPUT
    IN               : LONGTIME;
  END_VAR
END_FUNCTION

__DECL FUNCTION LREAL_TO_LONGTIME : LONGTIME
(*Conversion of seconds to LONGTIME type*)
  VAR_INPUT
    IN               : lreal;
  END_VAR
END_FUNCTION

__DECL FUNCTION ADD_DT_LONGTIME : dt
(*Returns sum of IN1 and IN2 as DATE_AND_TIME*)
  VAR_INPUT
    IN1              : dt;  (*First time to sum*)
    IN2              : LONGTIME;  (*Second time to sum*)
  END_VAR
END_FUNCTION

__DECL FUNCTION ADD_LONGTIME : LONGTIME
(*Returns sum of IN1 and IN2 as LONGTIME*)
  VAR_INPUT
    IN1              : LONGTIME;  (*First time to sum*)
    IN2              : LONGTIME;
  END_VAR
END_FUNCTION

__DECL FUNCTION ADD_LONGTIME_TIME : LONGTIME
(*LONGTIME := LONGTIME + TIME;*)
  VAR_INPUT
    IN1              : LONGTIME;  (*First time to sum*)
    IN2              : time;  (*Second time to sum*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DIV_LONGTIME : LONGTIME
(*Returns result of division of time IN1 by number IN2*)
  VAR_INPUT
    IN1              : LONGTIME;  (*Time to be divided*)
    IN2              : real;  (*Divisor*)
  END_VAR
END_FUNCTION

__DECL FUNCTION EQ_LONGTIME : bool
(*Equality, returns TRUE if IN1 = IN2*)
  VAR_INPUT
    IN1              : LONGTIME;  (*First time for comparison*)
    IN2              : LONGTIME;  (*Second time for comparison*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GE_LONGTIME : bool
(*Greater than or equal, returns TRUE if IN1 >= IN2*)
  VAR_INPUT
    IN1              : LONGTIME;  (*First time for comparison*)
    IN2              : LONGTIME;  (*Second time for comparison*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GT_LONGTIME : bool
(*Greater than, returns TRUE if IN1 > IN2*)
  VAR_INPUT
    IN1              : LONGTIME;  (*First time for comparison*)
    IN2              : LONGTIME;  (*Second time for comparison*)
  END_VAR
END_FUNCTION

__DECL FUNCTION LE_LONGTIME : bool
(*Lesser than or equal, returns TRUE if IN1 <= IN2*)
  VAR_INPUT
    IN1              : LONGTIME;  (*First time for comparison*)
    IN2              : LONGTIME;  (*Second time for comparison*)
  END_VAR
END_FUNCTION

__DECL FUNCTION LT_LONGTIME : bool
(*Lesser than, returns TRUE if IN1 < IN2*)
  VAR_INPUT
    IN1              : LONGTIME;  (*First time for comparison*)
    IN2              : LONGTIME;  (*Second time for comparison*)
  END_VAR
END_FUNCTION

__DECL FUNCTION MUL_LONGTIME : LONGTIME
(*Returns result of multiplication of time IN1 by number IN2*)
  VAR_INPUT
    IN1              : LONGTIME;  (*Time to be multiplied*)
    IN2              : real;  (*Multiplier*)
  END_VAR
END_FUNCTION

__DECL FUNCTION NE_LONGTIME : bool
(*Inequality, returns TRUE if IN1 <> IN2*)
  VAR_INPUT
    IN1              : LONGTIME;  (*First time for comparison*)
    IN2              : LONGTIME;  (*Second time for comparison*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SUB_DATE_DATE_LONG : LONGTIME
(*Returns difference of IN1 and IN2 as LONGTIME*)
  VAR_INPUT
    IN1              : date;  (*Date from which is subtracted*)
    IN2              : date;  (*Date to be subtracted*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SUB_DT_DT_LONG : LONGTIME
(*Returns difference of IN1 and IN2 as LONGTIME*)
  VAR_INPUT
    IN1              : dt;  (*Date and time from which is subtracted*)
    IN2              : dt;  (*Date and time to be subtracted*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SUB_DT_LONGTIME : dt
(*Returns difference of IN1 and IN2 as LONGTIME*)
  VAR_INPUT
    IN1              : dt;  (*Date and time from which is subtracted*)
    IN2              : LONGTIME;  (*Time to be subtracted*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SUB_LONGTIME : LONGTIME
(*Returns difference of IN1 and IN2*)
  VAR_INPUT
    IN1              : LONGTIME;  (*Time from which is subtracted*)
    IN2              : LONGTIME;  (*Time to be subtracted*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SUB_LONGTIME_TIME : LONGTIME
(*Returns difference of IN1 and IN2*)
  VAR_INPUT
    IN1              : LONGTIME;  (*Time from which is subtracted*)
    IN2              : time;  (*Time to be subtracted*)
  END_VAR
END_FUNCTION

__DECL FUNCTION_BLOCK AbsoluteTON
(*On-delay Timer for long times
      Timer can continue even after power off, if the timestamp TS is defined as RETAIN and signal IN is still TRUE after power on*)
  VAR_INPUT
    IN               : bool;  (*input*)
    PT               : LONGTIME;  (*preset*)
  END_VAR
  VAR_IN_OUT
    TS               : dt;  (*time stamp (must be RETAIN)*)
  END_VAR
  VAR_OUTPUT
    Q                : bool;  (*output*)
    ET               : LONGTIME;  (*value*)
  END_VAR
  VAR
    RT               : R_TRIG;
  END_VAR
END_FUNCTION_BLOCK



{LIBFILE="LOCALLIB\CANVASOBJECTSLIB_V13_20180322.MLB"}
(* Mosaic IDE library *)
(* File name : D:\TecoUserLibsX\CanvasObjectsLib_V13_20180322.mlb *)
(* Library : CanvasObjectsLib 1.3 *)
(* Author : Teco a.s. *)
(* Copyright : (c) 2018 Teco a.s. *)
(* IEC compiler version : 4.1.3.0 *)
(* Assembler version : 4.3.00 *)

//{Knihovna : CanvasObjectsLib 1.3  }
(* History: *)
(*
v1.0 2016-03-24 nem first version
v1.1 2016-04-22 nem added blocks fbAnalogMeterFlat,
                    fbAnalogMeterModern, fbAnalogClockFace,
                    fbAnalogClockFlat
v1.2 2016-10-06 byd added block fbXYGraph1
                    added dependency on TimeLib
v1.3 2018-03-22 byd added block fbTouchArea
*)

(*----------------------------------------------------------------------------*)
// {LIBRARY="LOCALLIB\SYSLIB_V38_20170104.MLB"}
// {LIBRARY="LOCALLIB\MODELLIB_V22_20171205.MLB"}

__DECL FUNCTION_BLOCK CanObj_fbSetMinMax {HIDDEN}
(*Internal functional block of library
   find the minimum and maximum value*)
  VAR CONSTANT
    WebGraph_MIN_REAL {HIDDEN} : real :=  -1000000000.0;
    WebGraph_MAX_REAL {HIDDEN} : real :=   1000000000.0;
  END_VAR
  VAR_INPUT
    init             : bool;
    numViewCol       : int;
    bufY             : PTR_TO real;
  END_VAR
  VAR_OUTPUT
    minZ             : real;
    maxZ             : real;
  END_VAR
END_FUNCTION_BLOCK

TYPE  TGraphData64Real : ARRAY [1..64] OF real;
END_TYPE

__DECL FUNCTION InsertNewValToGraph : bool
(*Add value into REAL graph
   The function inserts a new value at the end of the buffer values for the graph
   The function returns TRUE if the graph should be redrawn*)
  VAR_INPUT
    save             : bool;  (*1 = vloit novou hodnotu*)
    newVal           : real;  (*vkládaná hodnota*)
    sizeBuf          : int;  (*velikost bufferu v bytech*)
  END_VAR
  VAR_IN_OUT
    buf              : TGraphData64Real;  (*buffer obsahující data pro graf*)
  END_VAR
END_FUNCTION

__DECL FUNCTION_BLOCK fbLineGraph1
(*Line graph 1*64 REAL values
  Line graph support for web page, show curve for 1 REAL variable, max 64 values
  X axis is type of REAL.*)
  VAR CONSTANT
    MAX_NUM_POINTS   : int :=   64;
    CANVAS_HEIGHT    : int :=  1000;
  END_VAR
  VAR_INPUT
    vis              : bool :=  TRUE;  (*viditelnost grafu*)
    refr             : bool R_EDGE;  (*poadavek na pøekreslení grafu*)
    fit              : bool;  (*nastavit min a max pro osu Y podle zobrazených dat*)
    zoom2x           : bool;  (*zvìtení osy X 2x + fit osy Y*)
    minX             : real;  (*min hodnota (osa X)*)
    maxX             : real;  (*max hodnota (osa X)*)
    minY             : real;  (*min hodnota (osa Y)*)
    maxY             : real;  (*max hodnota (osa Y)*)
    ratio            : real :=  1.5;  (*pomìr íøka : výka grafu (od 1.0 do 5.0)*)
    axisColor        : udint :=  GCOLOR_DKGRAY;  (*barva os a popiskù (GCOLOR_BLACK, ...)*)
    textSize         : usint :=  40;  (*velikost textu pro popisky*)
    maxPoints        : int :=  MAX_NUM_POINTS;  (*max poèet hodnot v grafu (max. 64)*)
    numPoints        : int;  (*poèet hodnot, které budou aktuálnì zobrazeny (max. 64)*)
    graphColor       : udint :=  GCOLOR_BLUE_A700;  (*barva èáry grafu*)
    fillColor        : udint :=  GCOLOR_BLUE_100;  (*barva výplnì grafu*)
    graphStyle       : usint :=  GGRAPH_LINE_FILL;  (*styl grafu (GGRAPH_LINE_INTERPOLATE, GGRAPH_LINE_FILL, ...)*)
  END_VAR
  VAR_IN_OUT
    bufY             : TGraphData64Real;  (*pole hodnot grafu*)
  END_VAR
  VAR_OUTPUT
    graphOK          : bool;  (*graf vykreslen OK*)
    canvasData       : TCanvasData384;  (*data pro canvas*)
    canvasLen        : uint;  (*aktuální délka grafickych dat v canvasData*)
  END_VAR
  VAR
    CANVAS_WIDTH     : int;
    GRAPH_HEIGHT     : int :=  1000;
    GRAPH_WIDTH      : int;
    refrView         : bool :=  TRUE;
    oldvis           : bool;
    oldfit           : bool;
    SetMinMaxY       : CanObj_fbSetMinMax;
    minZX            : real;
    maxZX            : real;
    minZY            : real;
    maxZY            : real;
    lastTouch        : int :=  -32767;
    cursorX          : int;
    cursorIndex      : int;  (*index poloeného kurzoru <1,maxPoints> !!! relativne ke startIndex*)
    cursorValue      : real;
    colSize          : real;
    actGraphLen      : int;
    zoom2on          : R_TRIG;
    zoom2off         : F_TRIG;
    startIndex       : int :=  1;
    actMaxPoints     : int;  (*max pocet hodnot v grafu (aktualni podle zoom)*)
    actNumPoints     : int;  (*pocet hodnot, ktere budou aktualne zobrazeny*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbLineGraph2
(*Line graph 2*64 REAL values
  Line graph support for web page, show curves for 2 REAL variables, max 64 values
  X axis is type of REAL.*)
  VAR CONSTANT
    MAX_NUM_POINTS   : int :=   64;
    CANVAS_HEIGHT    : int :=  1000;
  END_VAR
  VAR_INPUT
    vis              : bool :=  TRUE;  (*viditelnost grafu*)
    refr             : bool R_EDGE;  (*poadavek na pøekreslení grafu*)
    fit              : bool;  (*nastavit min a max pro osu Y podle zobrazených dat*)
    zoom2x           : bool;  (*zvìtení osy X 2x + fit osy Y*)
    minX             : real;  (*min hodnota (osa X)*)
    maxX             : real;  (*max hodnota (osa X)*)
    minY             : real;  (*min hodnota (osa Y)*)
    maxY             : real;  (*max hodnota (osa Y)*)
    ratio            : real :=  1.5;  (*pomìr íøka : výka grafu (od 1.0 do 5.0)*)
    axisColor        : udint :=  GCOLOR_DKGRAY;  (*barva os a popiskù (GCOLOR_BLACK, ...)*)
    textSize         : usint :=  40;  (*velikost textu pro popisky*)
    maxPoints        : int :=  MAX_NUM_POINTS;  (*max poèet hodnot v grafu (max. 64)*)
    numPoints1       : int;  (*poèet hodnot grafu 1, které budou aktuálnì zobrazeny (max. 64)*)
    graphColor1      : udint :=  GCOLOR_BLUE_A700;  (*barva èáry grafu 1*)
    fillColor1       : udint :=  GCOLOR_BLUE_100;  (*barva výplnì grafu 1*)
    graphStyle1      : usint :=  GGRAPH_LINE_FILL;  (*styl grafu 1 (GGRAPH_LINE_INTERPOLATE, GGRAPH_LINE_FILL, ...)*)
    numPoints2       : int;  (*poèet hodnot grafu 2, které budou aktuálnì zobrazeny (max. 64)*)
    graphColor2      : udint :=  GCOLOR_RED_A700;  (*barva èáry grafu 2*)
    fillColor2       : udint :=  GCOLOR_RED_100;  (*barva výplnì grafu 2*)
    graphStyle2      : usint :=  GGRAPH_LINE_FILL;  (*styl grafu 2 (GGRAPH_LINE_INTERPOLATE, GGRAPH_LINE_FILL, ...)*)
  END_VAR
  VAR_IN_OUT
    bufY1            : TGraphData64Real;  (*pole hodnot grafu 1*)
    bufY2            : TGraphData64Real;  (*pole hodnot grafu 2*)
  END_VAR
  VAR_OUTPUT
    graphOK          : bool;  (*graf vykreslen OK*)
    canvasData       : TCanvasData512;  (*data pro canvas*)
    canvasLen        : uint;  (*aktuální délka grafickych dat v canvasData*)
  END_VAR
  VAR
    CANVAS_WIDTH     : int;
    GRAPH_HEIGHT     : int :=  1000;
    GRAPH_WIDTH      : int;
    refrView         : bool :=  TRUE;
    oldvis           : bool;
    oldfit           : bool;
    SetMinMaxY       : CanObj_fbSetMinMax;
    minZX            : real;
    maxZX            : real;
    minZY            : real;
    maxZY            : real;
    lastTouch        : int :=  -32767;
    cursorX          : int;
    cursorIndex      : int;  (*index poloeného kurzoru <1,maxPoints> !!! relativne ke startIndex*)
    cursorValue1     : real;
    cursorValue2     : real;
    colSize          : real;
    actGraphLen      : int;
    actGraphLen1     : int;
    actGraphLen2     : int;
    zoom2on          : R_TRIG;
    zoom2off         : F_TRIG;
    startIndex       : int :=  1;
    actMaxPoints     : int;  (*max pocet hodnot v grafu (aktualni podle zoom)*)
    actNumPoints1    : int;  (*pocet hodnot, ktere budou aktualne zobrazeny*)
    actNumPoints2    : int;  (*pocet hodnot, ktere budou aktualne zobrazeny*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbBarGraph1
(*Bar graph 1*64 REAL values
  Bar graph support for web page, show curve for 1 REAL variable, max 64 values
  X axis is type of REAL.*)
  VAR CONSTANT
    MAX_NUM_POINTS   : int :=   64;
    CANVAS_HEIGHT    : int :=  1000;
  END_VAR
  VAR_INPUT
    vis              : bool :=  TRUE;  (*viditelnost grafu*)
    refr             : bool R_EDGE;  (*poadavek na pøekreslení grafu*)
    fit              : bool;  (*nastavit min a max pro osu Y podle zobrazených dat*)
    minX             : real;  (*min hodnota (osa X)*)
    maxX             : real;  (*max hodnota (osa X)*)
    minY             : real;  (*min hodnota (osa Y)*)
    maxY             : real;  (*max hodnota (osa Y)*)
    ratio            : real :=  1.5;  (*pomìr íøka : výka grafu (od 1.0 do 5.0)*)
    axisColor        : udint :=  GCOLOR_DKGRAY;  (*barva os a popiskù (GCOLOR_BLACK, ...)*)
    textSize         : usint :=  40;  (*velikost textu pro popisky*)
    maxPoints        : int :=  MAX_NUM_POINTS;  (*max poèet hodnot v grafu (max. 64)*)
    numPoints        : int;  (*poèet hodnot, které budou aktuálnì zobrazeny (max. 64)*)
    graphColor       : udint :=  GCOLOR_BLUE_A700;  (*barva obrysu sloupce*)
    fillColor        : udint :=  GCOLOR_BLUE_100;  (*barva výplnì sloupce*)
  END_VAR
  VAR_IN_OUT
    bufY             : TGraphData64Real;  (*pole hodnot grafu*)
  END_VAR
  VAR_OUTPUT
    graphOK          : bool;  (*graf vykreslen OK*)
    canvasData       : TCanvasData384;  (*data pro canvas*)
    canvasLen        : uint;  (*aktuální délka grafických dat v canvasData*)
  END_VAR
  VAR
    CANVAS_WIDTH     : int;
    GRAPH_HEIGHT     : int :=  1000;
    GRAPH_WIDTH      : int;
    refrView         : bool :=  TRUE;
    oldvis           : bool;
    oldfit           : bool;
    SetMinMaxY       : CanObj_fbSetMinMax;
    minZX            : real;
    maxZX            : real;
    minZY            : real;
    maxZY            : real;
    lastTouch        : int :=  -32767;
    cursorX          : int;
    cursorIndex      : int;  (*index poloeného kurzoru <1,maxPoints> !!! relativne ke startIndex*)
    cursorValue      : real;
    colSize          : real;
    actGraphLen      : int;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbBarGraph2
(*Bar graph 2*64 REAL values
  Bar graph support for web page, show curves for 2 REAL variables, max 64 values
  X axis is type of REAL.*)
  VAR CONSTANT
    MAX_NUM_POINTS   : int :=   64;
    CANVAS_HEIGHT    : int :=  1000;
  END_VAR
  VAR_INPUT
    vis              : bool :=  TRUE;  (*viditelnost grafu*)
    refr             : bool R_EDGE;  (*poadavek na pøekreslení grafu*)
    fit              : bool;  (*nastavit min a max pro osu Y podle zobrazených dat*)
    minX             : real;  (*min hodnota (osa X)*)
    maxX             : real;  (*max hodnota (osa X)*)
    minY             : real;  (*min hodnota (osa Y)*)
    maxY             : real;  (*max hodnota (osa Y)*)
    ratio            : real :=  1.5;  (*pomìr íøka : výka grafu (od 1.0 do 5.0)*)
    axisColor        : udint :=  GCOLOR_DKGRAY;  (*barva os a popiskù (GCOLOR_BLACK, ...)*)
    textSize         : usint :=  40;  (*velikost textu pro popisky*)
    maxPoints        : int :=  MAX_NUM_POINTS;  (*max poèet hodnot v grafu (max. 64)*)
    numPoints1       : int;  (*poèet hodnot grafu 1, které budou aktuálnì zobrazeny (max. 64)*)
    graphColor1      : udint :=  GCOLOR_BLUE_A700;  (*barva grafu 1*)
    numPoints2       : int;  (*poèet hodnot grafu 2, které budou aktuálnì zobrazeny (max. 64)*)
    graphColor2      : udint :=  GCOLOR_RED_A700;  (*barva grafu 2*)
  END_VAR
  VAR_IN_OUT
    bufY1            : TGraphData64Real;  (*pole hodnot grafu 1*)
    bufY2            : TGraphData64Real;  (*pole hodnot grafu 2*)
  END_VAR
  VAR_OUTPUT
    graphOK          : bool;  (*graf vykreslen OK*)
    canvasData       : TCanvasData512;  (*data pro canvas*)
    canvasLen        : uint;  (*aktuální délka grafickych dat v canvasData*)
  END_VAR
  VAR
    CANVAS_WIDTH     : int;
    GRAPH_HEIGHT     : int :=  1000;
    GRAPH_WIDTH      : int;
    refrView         : bool :=  TRUE;
    oldvis           : bool;
    oldfit           : bool;
    SetMinMaxY       : CanObj_fbSetMinMax;
    minZX            : real;
    maxZX            : real;
    minZY            : real;
    maxZY            : real;
    lastTouch        : int :=  -32767;
    cursorX          : int;
    cursorIndex      : int;  (*index poloeného kurzoru <1,maxPoints> !!! relativne ke startIndex*)
    cursorValue1     : real;
    cursorValue2     : real;
    colSize          : real;
    actGraphLen      : int;
    actGraphLen1     : int;
    actGraphLen2     : int;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbAnalogClockFace
  VAR_INPUT
    vis              : bool :=  TRUE;
    refr             : bool R_EDGE;
    clkTime          : time;
    markersColor     : udint :=  GCOLOR_BLACK + GCOLOR_TRANSPARENT1_2;
    hourHandColor    : udint :=  GCOLOR_BLACK;
    minuteHandColor  : udint :=  GCOLOR_BLACK;
    secondHandColor  : udint :=  GCOLOR_BLACK;
  END_VAR
  VAR_OUTPUT
    canvasOK         : bool;
    canvasData       : TCanvasData256;
    canvasLen        : uint;
  END_VAR
  VAR
    oldvis           : bool;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbAnalogClockFlat
  VAR_INPUT
    vis              : bool :=  TRUE;
    refr             : bool R_EDGE;
    dateTime         : dt;
    color            : udint :=  16#00669900;
    markersColor     : udint :=  GCOLOR_BLACK + GCOLOR_TRANSPARENT1_2;
    hourHandColor    : udint :=  GCOLOR_BLACK;
    minuteHandColor  : udint :=  GCOLOR_BLACK;
    secondHandColor  : udint :=  GCOLOR_BLACK;
    dayOfWeekNames   : ARRAY [1..7] OF string [10] :=  ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
    monthNames       : ARRAY [1..12] OF string [10] :=  ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  END_VAR
  VAR_OUTPUT
    canvasOK         : bool;
    canvasData       : TCanvasData256;
    canvasLen        : uint;
  END_VAR
  VAR
    tecoDateTime     : TTecoDateTime;
    oldvis           : bool;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbAnalogMeterFlat
  VAR_INPUT
    vis              : bool :=  TRUE;
    refr             : bool R_EDGE;
    currentVal       : real;
    fromVal          : real :=  0.0;
    toVal            : real :=  100.0;
    presetVal        : real :=  -1.0;
    majorStep        : real :=  5.0;
    stepDiv          : usint :=  5;
    label            : string [80] :=  '';
    color            : udint :=  GCOLOR_GRAY;
    markersColor     : udint :=  GCOLOR_BLACK;
    currValHandColor : udint :=  GCOLOR_BLACK;
    presetValHandColor : udint :=  GCOLOR_RED;
  END_VAR
  VAR
    oldvis           : bool;
  END_VAR
  VAR_OUTPUT
    canvasOK         : bool;
    canvasData       : TCanvasData256;
    canvasLen        : uint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbAnalogMeterModern
  VAR_INPUT
    vis              : bool :=  TRUE;
    refr             : bool R_EDGE;
    currentVal       : real;
    fromVal          : real :=  0.0;
    toVal            : real :=  100.0;
    presetVal        : real :=  -1.0;
    label            : string [80] :=  '';
    color            : udint :=  GCOLOR_CYAN;
    fontColor        : udint :=  GCOLOR_WHITE;
    image            : string [80] :=  '';
  END_VAR
  VAR
    oldvis           : bool;
  END_VAR
  VAR_OUTPUT
    canvasOK         : bool;
    canvasData       : TCanvasData256;
    canvasLen        : uint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbXYGraph1
(*XY graph 1*64 REAL values
  XY graph support for web page, show one curve defined by arrays of X and Y values, max 64 values*)
  VAR CONSTANT
    MAX_NUM_POINTS   : int :=   64;
    CANVAS_HEIGHT    : int :=  1000;
  END_VAR
  VAR_INPUT
    vis              : bool :=  TRUE;  (*visibility of the graph*)
    refr             : bool R_EDGE;  (*request to redraw the graph*)
    fit              : bool;  (*set minimum and maximum for the Y axis according to the displayed data*)
    zoom2x           : bool;  (*X-axis magnification 2x + fit Y-axis*)
    minX             : real;  (*minimum value (X-axis)*)
    maxX             : real;  (*maximum value (X-axis)*)
    minY             : real;  (*minimum value (Y-axis)*)
    maxY             : real;  (*maximum value (Y-axis)*)
    ratio            : real :=  1.5;  (*ratio graph width to height (from 1.0 to 5.0)*)
    axisColor        : udint :=  GCOLOR_DKGRAY;  (*color of text for labels (GCOLOR_BLACK, ...)*)
    textSize         : usint :=  40;  (*text size for labels*)
    maxPoints        : int :=  MAX_NUM_POINTS;  (*maximum number of values in graph (max 64)*)
    numPoints        : int;  (*the number of values currently displayed (max 64)*)
    graphColor       : udint :=  GCOLOR_BLUE_A700;  (*chart line color*)
    fillColor        : udint :=  GCOLOR_BLUE_100;  (*color fill graph*)
  END_VAR
  VAR_IN_OUT
    bufX             : TGraphData64Real;  (*array of chart values for the X axis*)
    bufY             : TGraphData64Real;  (*Y array plot value field*)
  END_VAR
  VAR_OUTPUT
    graphOK          : bool;  (*graph rendered OK*)
    canvasData       : TCanvasData768;  (*data for canvas*)
    canvasLen        : uint;  (*current length of graphical data in canvasData*)
  END_VAR
  VAR
    CANVAS_WIDTH     : int;
    GRAPH_HEIGHT     : int :=  1000;
    GRAPH_WIDTH      : int;
    refrView         : bool :=  TRUE;
    oldvis           : bool;
    oldfit           : bool;
    SetMinMaxY       : CanObj_fbSetMinMax;
    minZX            : real;
    maxZX            : real;
    minZY            : real;
    maxZY            : real;
    lastTouch        : int :=  -32767;
    cursorX          : int;
    cursorIndex      : int;  (*index poloeného kurzoru <1,maxPoints> !!! relativne ke startIndex*)
    cursorValueX     : real;
    cursorValue      : real;
    colSize          : real;
    actGraphLen      : int;
    zoom2on          : R_TRIG;
    zoom2off         : F_TRIG;
    startIndex       : int :=  1;
    actMaxPoints     : int;  (*max pocet hodnot v grafu (aktualni podle zoom)*)
    actNumPoints     : int;  (*pocet hodnot, ktere budou aktualne zobrazeny*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbTouchArea
(*Transparent area acting on touch - when pressed fills area with color.
Block has control timer for case when communication is lost (end of press is evaluated after two seconds without communication )*)
  VAR_INPUT
    color            : udint :=  GCOLOR_CYAN_A400+GCOLOR_TRANSPARENT3_4;  (*Color which is used to fill the area when touched*)
  END_VAR
  VAR
    lastState        : int;
    safetyTimer      : TON :=  (PT := T#2s);
    oldPressed       : bool;
  END_VAR
  VAR_OUTPUT
    pressed          : bool;  (*Stiskuto*)
    pressDn          : bool;  (*Zaèátek stisku*)
    pressUp          : bool;  (*Konec stisku*)
    grData           : TCanvasData16;  (*Data pro kreslící plátno*)
  END_VAR
  VAR CONSTANT
    TESTCOORD        : int :=  32767;  (*souradnice mimo bìné rozsahy pro test, e bylo do promìnné zapsáno*)
  END_VAR
END_FUNCTION_BLOCK



{LIBFILE="LOCALLIB\COMLIB_V31_20190507.MLB"}
(* Mosaic IDE library *)
(* File name : D:\MosaicLib\ComLib_V31_20190507.mlb *)
(* Library : ComLib 3.1 *)
(* Author : Teco a.s. *)
(* Copyright : (c) 2018 Teco a.s. *)
(* IEC compiler version : 4.2.4.0 *)
(* Assembler version : 4.3.00 *)

//{Knihovna : ComLib 3.1  }
(* History: *)
(*
v1.0 2009-03-23 Nem first edition
v1.1 2009-03-27 Nem corrected error when length of sending data is zero
v1.2 2009-06-24 Nem fbSendTo() and fbReceivedFrom() extended for ETH2
v1.3 2009-09-24 Nem function GetMACaddress is available for ETH2, added functions 
                    SetDHCPsupport(), STRING_TO_IPADR() a IPADR_TO_STRING() 
v1.4 2010-02-08 Nem added function GetChanStat() 18.02.2010 Nem added functions 
                    GetChanSettings() and SetChanSettings()
v1.5 2010-08-02 Nem all comments are in Czech and English version
v1.6 2011-08-08 Nem corrected TCP buffer overflow in fbSenfTo() 
v1.7 2012-01-23 Nem added functions SetDNS_IP(), GetDNS_IP() and fbRecvTxt()
v1.8 2012-04-18 Nem error output added to function block fbRecvTxt()
v1.9 2012-06-14 Nem added constants ETH3_uni0,...,ETH4_uni7 
		Byd added function block fbRecvTxtChar()
v2.0 2013-03-14 Nem added item link in structure TEthStat
                    (network cable connected)
v2.1 2013-05-28 Nem added global variables ETH3_STAT and ETH4_STAT
                    added function GetWebServerAccess()
                    and function block fbKeepAliveTCP() - required
                    version of firmware CPU is 7.7 or higher
     2013-08-22 Nem in block fb SendTo() max. length of sending data is checked 
                    correctly
v2.2 2015-07-03 Nem added functions SetRTS() and GetRTS()
v2.3 2016-10-19 Nem added function CheckGatewayIP()
v2.4 2016-12-12 Nem added function MACADR_TO_STRING()
v3.0 2018-12-20 Nem added support for communication of CP-2xxx
                    added constants for WLAN1, WLAN2 a LTE1 (CP-2xxx only) 
v3.1 2019-05-07 Nem added functions SetUniLog() and SetUniChanHostName()
*)

(*----------------------------------------------------------------------------*)

TYPE TUniDesc :
  STRUCT  (*description of channel in uni mode*)
    modeChan         : byte;  (*channel mode*)
    res              : byte;  (*if ETHx then res = protocol (UNI_TCP_CLIENT, UNI_TCP_SERVER, ...) else res= 0*)
    adrUniStat       : udint;  (*address of status*)
    lenUniStat       : uint;  (*length of status*)
    adrUniCont       : udint;  (*address of control*)
    lenUniCont       : uint;  (*length of control*)
    adrUniIn         : udint;  (*address of receiving buffer*)
    lenUniIn         : uint;  (*length of receiving buffer*)
    adrUniOut        : udint;  (*address of sending buffer*)
    lenUniOut        : uint;  (*length of sending buffer*)
  END_STRUCT;
END_TYPE

TYPE  TIPadr : ARRAY [0..3] OF usint;  (*IP address*)
END_TYPE

TYPE TLocalEthAdr :
  STRUCT  (*structure of local IP address*)
    IP               : TIPadr;  (*IP address*)
    IM               : TIPadr;  (*subnet mask*)
    GW               : TIPadr;  (*gateway address*)
  END_STRUCT;
END_TYPE

TYPE TRemoteEthAdr :
  STRUCT  (*structure of remote IP address*)
    remoteIP         : TIPadr;  (*remote IP address*)
    remotePort       : uint;  (*remote port*)
    localPort        : uint;  (*local port*)
  END_STRUCT;
END_TYPE

TYPE  TMacAdr : ARRAY [0..5] OF byte;  (*MAC address*)
END_TYPE

TYPE TSocketAdr {HIDDEN} :
  STRUCT
    IP               : TIPadr;  (*IP address*)
    port             : uint;  (*port number*)
  END_STRUCT;
END_TYPE

TYPE TChanSettings :
  STRUCT  (*structure of parameters for serial channel (uni mode only!)*)
    modeChan         : usint;  (*channel mode*)
    address          : usint;  (*address*)
    speed            : usint;  (*speed*)
    rxTimeout        : usint;  (*receiver timeout*)
    txTimeout        : usint;  (*transmitter timeout*)
    lineControl      : usint;  (*parity control*)
    modemControl     : usint;  (*modem control*)
    rez              : usint;  (*reserved*)
  END_STRUCT;
END_TYPE

VAR_GLOBAL CONSTANT
 MODE_OFF : usint :=  16#00;  (*channel is off*)
 MODE_PC : usint :=  16#02;  (*EPSNET slave*)
 MODE_UNI : usint :=  16#05;  (*universal mode*)
 MODE_MPC : usint :=  16#06;  (*EPSNET multimaster*)
 MODE_MDB : usint :=  16#07;  (*MODBUS slave*)
 MODE_PFB : usint :=  16#08;  (*PROFIBUS DP master*)
 BAUD_50 : usint :=  16#01;  (*50 Baud*)
 BAUD_100 : usint :=  16#02;  (*100 Baud*)
 BAUD_200 : usint :=  16#03;  (*200 Baud*)
 BAUD_300 : usint :=  16#04;  (*300 Baud*)
 BAUD_600 : usint :=  16#05;  (*600 Baud*)
 BAUD_1200 : usint :=  16#06;  (*1200 Baud*)
 BAUD_2400 : usint :=  16#07;  (*2400 Baud*)
 BAUD_4800 : usint :=  16#08;  (*4800 Baud*)
 BAUD_9600 : usint :=  16#0A;  (*9600 Baud*)
 BAUD_14400 : usint :=  16#0B;  (*14400 Baud*)
 BAUD_19200 : usint :=  16#0C;  (*19200 Baud*)
 BAUD_28800 : usint :=  16#0D;  (*28800 Baud*)
 BAUD_38400 : usint :=  16#0E;  (*38400 Baud*)
 BAUD_57600 : usint :=  16#10;  (*57600 Baud*)
 BAUD_76800 : usint :=  16#12;  (*76800 Baud*)
 BAUD_93750 : usint :=  16#13;  (*937500 Baud*)
 BAUD_115200 : usint :=  16#14;  (*115200 Baud*)
 NO_PARITY : usint :=  16#00;  (*no parity (lineControl code)*)
 PARITY_ODD : usint :=  16#08;  (*odd parity (lineControl code)*)
 PARITY_EVEN : usint :=  16#18;  (*even parity (lineControl code)*)
 PARITY_0 : usint :=  16#28;  (*fixed parity 0 (lineControl code)*)
 PARITY_1 : usint :=  16#38;  (*fixed parity 1 (lineControl code)*)
 SEVEN_BITS : usint :=  16#40;  (*7 bits in byte (lineControl code)*)
 EIGHT_BITS : usint :=  16#00;  (*8 bits in byte (lineControl code)*)
 ONE_STOP_BIT : usint :=  16#00;  (*1 stop bit (lineControl code)*)
 TWO_STOP_BITS : usint :=  16#80;  (*2 stop bits (lineControl code)*)
 RTS_0 : usint :=  16#00;  (*RTS fixed 0 (modemControl code)*)
 RTS_1 : usint :=  16#02;  (*RTS fixed 1 (modemControl code)*)
 RTS_MAN : usint :=  16#40;  (*RTS manual from user program (modemControl code)*)
 RTS_AUTO : usint :=  16#80;  (*RTS auto (modemControl code)*)
 RTS_CTS_AUTO : usint :=  16#C0;  (*RTS auto + condition CTS (modemControl code)*)
 HALF_DUPLEX : usint :=  16#08;  (*receiver is disabled during transmitting (modemControl code)*)

END_VAR

TYPE TCHxStatistic {HIDDEN} :
  STRUCT
    STAT             : usint;
    ERR              : usint;
    trueMes          : udint;
    falseMes         : udint;
  END_STRUCT;
END_TYPE

TYPE TCHxControl {HIDDEN} :
  STRUCT
    CONTROL          : uint;
  END_STRUCT;
END_TYPE

TYPE TUni_STAT :
  STRUCT
    DSR              : bool;
    CTS              : bool;
    dummy1           : bool;
    TRO              : bool;
    RCF              : bool;
    ROV              : bool;
    TRF              : bool;
    ARC              : bool;
  END_STRUCT;
END_TYPE

TYPE TUni_CONT {HIDDEN} :
  STRUCT
    dummy0           : bool;
    dummy1           : bool;
    dummy2           : bool;
    dummy3           : bool;
    dummy4           : bool;
    TRG              : bool;
    CLR              : bool;
    ACN              : bool;
  END_STRUCT;
END_TYPE

TYPE TUni_SIGN {HIDDEN} :
  STRUCT
    DTR              : bool;
    RTS              : bool;
  END_STRUCT;
END_TYPE

TYPE TUni_IN_STATUS :
  STRUCT  (*receiving data structure of channel in uni mode*)
    STAT             : TUni_STAT;  (*status of receving*)
    ERR              : usint;  (*error code*)
    NUMR             : uint;  (*number of received bytes*)
  END_STRUCT;
END_TYPE

TYPE  TUni_BUFF : ARRAY [0..1400] OF usint;
END_TYPE

TYPE TUni_IN {HIDDEN} :
  STRUCT  (*receiving data structure of channel in uni mode*)
    STAT             : TUni_STAT;  (*status of receving*)
    ERR              : usint;  (*error code*)
    NUMR             : uint;  (*number of received bytes*)
    DATA             : TUni_BUFF;  (*received data*)
  END_STRUCT;
END_TYPE

TYPE TUni_OUT_CONT :
  STRUCT  (*sending data structure of channel in uni mode*)
    CONT             : TUni_CONT;  (*control of transmitting*)
    SIGN             : TUni_SIGN;  (*control of modem signals*)
    NUMT             : uint;  (*mumber of transmitted bytes*)
  END_STRUCT;
END_TYPE

TYPE TUni_OUT {HIDDEN} :
  STRUCT  (*sending data structure of channel in uni mode*)
    CONT             : TUni_CONT;  (*control of transmitting*)
    SIGN             : TUni_SIGN;  (*control of modem signals*)
    NUMT             : uint;  (*mumber of transmitted bytes*)
    DATA             : TUni_BUFF;  (*transmitted data*)
  END_STRUCT;
END_TYPE

TYPE TEthStat :
  STRUCT  (*status of Ethernet channel*)
    chan_present     : bool;  (*channel is present*)
    DHCP_enabled     : bool;  (*DHCP on*)
    IP_obtained      : bool;  (*IP address obtained from DHCP server*)
    IP_expired       : bool;  (*IP address expired*)
    link             : bool;  (*network cable connected*)
    reserved         : usint;  (*reserved*)
    trueMes          : udint;  (*suma of good messages*)
    falseMes         : udint;  (*suma of bad messages*)
  END_STRUCT;
END_TYPE

VAR_GLOBAL
 ETH1_STAT AT %S356 : TEthStat;  (*status of Ethernet channel ETH1*)
 ETH2_STAT AT %S368 : TEthStat;  (*status of Ethernet channel ETH2*)
 ETH3_STAT AT %S380 : TEthStat;  (*status of Ethernet channel ETH3*)
 ETH4_STAT AT %S392 : TEthStat;  (*status of Ethernet channel ETH4*)
 WLAN1_STAT AT %S440 : TEthStat;  (*status of Ethernet channel WLAN1*)
 WLAN2_STAT AT %S452 : TEthStat;  (*status of Ethernet channel WLAN2*)
 LTE1_STAT AT %S464 : TEthStat;  (*status of Ethernet channel LTE1*)

END_VAR

VAR_GLOBAL CONSTANT
 ANY_IP : TIPadr :=  [0];  (*IP address 0.0.0.0*)
 ANY_uni : uint :=  16#00E0;  (*Any Interface, mode uni*)
 ETH1_uni : uint :=  16#00E1;  (*Ethernet ETH1, mode uni*)
 ETH2_uni : uint :=  16#00E2;  (*Ethernet ETH2, mode uni*)
 ETH3_uni : uint :=  16#00E3;  (*Ethernet ETH3, mode uni*)
 ETH4_uni : uint :=  16#00E4;  (*Ethernet ETH4, mode uni*)
 WLAN1_uni : uint :=  16#00E8;  (*WiFi WLAN1,    mode uni*)
 WLAN2_uni : uint :=  16#00E9;  (*WiFi WLAN2,    mode uni*)
 LTE1_uni : uint :=  16#00EA;  (*modem LTE1,    mode uni*)
 ETH1_uni0 : uint :=  16#07E1;  (*Ethernet ETH1, mode uni, connection uni0*)
 ETH1_uni1 : uint :=  16#17E1;  (*Ethernet ETH1, mode uni, connection uni1*)
 ETH1_uni2 : uint :=  16#27E1;  (*Ethernet ETH1, mode uni, connection uni2*)
 ETH1_uni3 : uint :=  16#37E1;  (*Ethernet ETH1, mode uni, connection uni3*)
 ETH1_uni4 : uint :=  16#47E1;  (*Ethernet ETH1, mode uni, connection uni4*)
 ETH1_uni5 : uint :=  16#57E1;  (*Ethernet ETH1, mode uni, connection uni5*)
 ETH1_uni6 : uint :=  16#67E1;  (*Ethernet ETH1, mode uni, connection uni6*)
 ETH1_uni7 : uint :=  16#77E1;  (*Ethernet ETH1, mode uni, connection uni7*)
 ETH2_uni0 : uint :=  16#07E2;  (*Ethernet ETH2, mode uni, connection uni0*)
 ETH2_uni1 : uint :=  16#17E2;  (*Ethernet ETH2, mode uni, connection uni1*)
 ETH2_uni2 : uint :=  16#27E2;  (*Ethernet ETH2, mode uni, connection uni2*)
 ETH2_uni3 : uint :=  16#37E2;  (*Ethernet ETH2, mode uni, connection uni3*)
 ETH2_uni4 : uint :=  16#47E2;  (*Ethernet ETH2, mode uni, connection uni4*)
 ETH2_uni5 : uint :=  16#57E2;  (*Ethernet ETH2, mode uni, connection uni5*)
 ETH2_uni6 : uint :=  16#67E2;  (*Ethernet ETH2, mode uni, connection uni6*)
 ETH2_uni7 : uint :=  16#77E2;  (*Ethernet ETH2, mode uni, connection uni7*)
 ETH3_uni0 : uint :=  16#07E3;  (*Ethernet ETH3, mode uni, connection uni0*)
 ETH3_uni1 : uint :=  16#17E3;  (*Ethernet ETH3, mode uni, connection uni1*)
 ETH3_uni2 : uint :=  16#27E3;  (*Ethernet ETH3, mode uni, connection uni2*)
 ETH3_uni3 : uint :=  16#37E3;  (*Ethernet ETH3, mode uni, connection uni3*)
 ETH3_uni4 : uint :=  16#47E3;  (*Ethernet ETH3, mode uni, connection uni4*)
 ETH3_uni5 : uint :=  16#57E3;  (*Ethernet ETH3, mode uni, connection uni5*)
 ETH3_uni6 : uint :=  16#67E3;  (*Ethernet ETH3, mode uni, connection uni6*)
 ETH3_uni7 : uint :=  16#77E3;  (*Ethernet ETH3, mode uni, connection uni7*)
 ETH4_uni0 : uint :=  16#07E4;  (*Ethernet ETH4, mode uni, connection uni0*)
 ETH4_uni1 : uint :=  16#17E4;  (*Ethernet ETH4, mode uni, connection uni1*)
 ETH4_uni2 : uint :=  16#27E4;  (*Ethernet ETH4, mode uni, connection uni2*)
 ETH4_uni3 : uint :=  16#37E4;  (*Ethernet ETH4, mode uni, connection uni3*)
 ETH4_uni4 : uint :=  16#47E4;  (*Ethernet ETH4, mode uni, connection uni4*)
 ETH4_uni5 : uint :=  16#57E4;  (*Ethernet ETH4, mode uni, connection uni5*)
 ETH4_uni6 : uint :=  16#67E4;  (*Ethernet ETH4, mode uni, connection uni6*)
 ETH4_uni7 : uint :=  16#77E4;  (*Ethernet ETH4, mode uni, connection uni7*)
 WLAN1_uni0 : uint :=  16#07E8;  (*WiFi WLAN1, mode uni, connection uni0*)
 WLAN1_uni1 : uint :=  16#17E8;  (*WiFi WLAN1, mode uni, connection uni1*)
 WLAN1_uni2 : uint :=  16#27E8;  (*WiFi WLAN1, mode uni, connection uni2*)
 WLAN1_uni3 : uint :=  16#37E8;  (*WiFi WLAN1, mode uni, connection uni3*)
 WLAN1_uni4 : uint :=  16#47E8;  (*WiFi WLAN1, mode uni, connection uni4*)
 WLAN1_uni5 : uint :=  16#57E8;  (*WiFi WLAN1, mode uni, connection uni5*)
 WLAN1_uni6 : uint :=  16#67E8;  (*WiFi WLAN1, mode uni, connection uni6*)
 WLAN1_uni7 : uint :=  16#77E8;  (*WiFi WLAN1, mode uni, connection uni7*)
 WLAN2_uni0 : uint :=  16#07E9;  (*WiFi WLAN2, mode uni, connection uni0*)
 WLAN2_uni1 : uint :=  16#17E9;  (*WiFi WLAN2, mode uni, connection uni1*)
 WLAN2_uni2 : uint :=  16#27E9;  (*WiFi WLAN2, mode uni, connection uni2*)
 WLAN2_uni3 : uint :=  16#37E9;  (*WiFi WLAN2, mode uni, connection uni3*)
 WLAN2_uni4 : uint :=  16#47E9;  (*WiFi WLAN2, mode uni, connection uni4*)
 WLAN2_uni5 : uint :=  16#57E9;  (*WiFi WLAN2, mode uni, connection uni5*)
 WLAN2_uni6 : uint :=  16#67E9;  (*WiFi WLAN2, mode uni, connection uni6*)
 WLAN2_uni7 : uint :=  16#77E9;  (*WiFi WLAN2, mode uni, connection uni7*)
 LTE1_uni0 : uint :=  16#07EA;  (*modem LTE1, mode uni, connection uni0*)
 LTE1_uni1 : uint :=  16#17EA;  (*modem LTE1, mode uni, connection uni1*)
 LTE1_uni2 : uint :=  16#27EA;  (*modem LTE1, mode uni, connection uni2*)
 LTE1_uni3 : uint :=  16#37EA;  (*modem LTE1, mode uni, connection uni3*)
 LTE1_uni4 : uint :=  16#47EA;  (*modem LTE1, mode uni, connection uni4*)
 LTE1_uni5 : uint :=  16#57EA;  (*modem LTE1, mode uni, connection uni5*)
 LTE1_uni6 : uint :=  16#67EA;  (*modem LTE1, mode uni, connection uni6*)
 LTE1_uni7 : uint :=  16#77EA;  (*modem LTE1, mode uni, connection uni7*)
 CH1_uni : uint :=  16#0101;  (*Serial channel CH1, mode uni*)
 CH2_uni : uint :=  16#0202;  (*Serial channel CH2, mode uni*)
 CH3_uni : uint :=  16#0103;  (*Serial channel CH3, mode uni*)
 CH4_uni : uint :=  16#0204;  (*Serial channel CH4, mode uni*)
 CH5_uni : uint :=  16#0105;  (*Serial channel CH5, mode uni*)
 CH6_uni : uint :=  16#0206;  (*Serial channel CH6, mode uni*)
 CH7_uni : uint :=  16#0107;  (*Serial channel CH7, mode uni*)
 CH8_uni : uint :=  16#0208;  (*Serial channel CH8, mode uni*)
 CH9_uni : uint :=  16#0109;  (*Serial channel CH9, mode uni*)
 CH10_uni : uint :=  16#020A;  (*Serial channel CH10, mode uni*)
 ETH1 : usint :=  16#E1;  (*Ethernet ETH1*)
 ETH2 : usint :=  16#E2;  (*Ethernet ETH2*)
 ETH3 : usint :=  16#E3;  (*Ethernet ETH3*)
 ETH4 : usint :=  16#E4;  (*Ethernet ETH4*)
 WLAN1 : usint :=  16#E8;  (*WiFi WLAN1*)
 WLAN2 : usint :=  16#E9;  (*WiFi WLAN2*)
 LTE1 : usint :=  16#EA;  (*Modem LTE1*)
 SCH1 : usint :=  16#01;  (*serial channel CH1*)
 SCH2 : usint :=  16#02;  (*serial channel CH2*)
 SCH3 : usint :=  16#03;  (*serial channel CH3*)
 SCH4 : usint :=  16#04;  (*serial channel CH4*)
 SCH5 : usint :=  16#05;  (*serial channel CH5*)
 SCH6 : usint :=  16#06;  (*serial channel CH6*)
 SCH7 : usint :=  16#07;  (*serial channel CH7*)
 SCH8 : usint :=  16#08;  (*serial channel CH8*)
 SCH9 : usint :=  16#09;  (*serial channel CH9*)
 SCH10 : usint :=  16#0A;  (*serial channel CH10*)
 ONE_TIME_LOG : uint :=  16#0000;  (**)
 CYCLIC_LOG : uint :=  16#4000;  (**)
 HEX_LOG_ONLY : uint :=  16#2000;  (**)
 TEXT_LOG_ONLY : uint :=  16#1000;  (**)
 COM_OK : usint :=  0;  (*no error*)
 COM_ERR1 : usint :=  1;  (*channel is not in uni mode*)
 COM_ERR2 : usint :=  2;  (*sending data are too long*)
 COM_ERR3 : usint :=  3;  (*received data are too long*)
 COM_ERR4 : usint :=  4;  (*channel is not supported (wrong channel code)*)
 COM_ERR5 : usint :=  5;  (*previous message is not sent yet*)
 COM_ERR6 : usint :=  6;  (*no data for sending*)
 COM_ERR7 : usint :=  7;  (*invalid communication speed*)
 COM_ERR8 : usint :=  8;  (*channel is disabled*)
 COM_ERR16 : usint :=  16#10;  (*Invalid start delimiter*)
 COM_ERR17 : usint :=  16#11;  (*Parity error*)
 COM_ERR18 : usint :=  16#12;  (*Maximum message length exceeded*)
 COM_ERR19 : usint :=  16#13;  (*Invalid second byte of acknowledgment*)
 COM_ERR20 : usint :=  16#14;  (*Invalid second byte of end delimiter*)
 COM_ERR24 : usint :=  16#18;  (*Check sum error*)
 COM_ERR25 : usint :=  16#19;  (*Invalid end delimiter*)
 COM_ERR49 : usint :=  16#31;  (*Invalid length of sent data*)
 COM_ERR50 : usint :=  16#32;  (*Sent data zero length*)
 COM_ERR64 : usint :=  16#40;  (*Timeout not held*)
 COM_ERRc6 : usint :=  16#C6;  (*Invalid channel mode*)

END_VAR

VAR_GLOBAL CONSTANT
 UNI_UDP : usint :=  16#10;  (*protocol type = UDP*)
 UNI_TCP_CLIENT : usint :=  16#21;  (*protocol type = TCP client*)
 UNI_TCP_SERVER : usint :=  16#22;  (*protocol type = TCP server*)
 UNI_SSL_CLIENT : usint :=  16#23;  (*protocol type = TLS/SSL client*)
 UNI_SSL_SERVER : usint :=  16#24;  (*protocol type = TLS/SSL server*)

END_VAR

__DECL FUNCTION OpenUniSocket : uint
(*Open UDP or TCP socket (for Foxtrot CP-2xxx only)
 Returns handle of socket (0 means there is no free socket).
 Handle can be used as chanCode parameter for fbRecvFrom and fbSendTo*)
  VAR_INPUT
    myIP             : TIPadr;  (*local IP address*)
    myPort           : uint;  (*local port*)
    hisIP            : TIPadr;  (*remote IP address*)
    hisPort          : uint;  (*remote port*)
    protocol         : usint;  (*protocol : UNI_UDP, UNI_TCP_CLIENT, ...*)
  END_VAR
END_FUNCTION

__DECL FUNCTION CloseUniSocket : bool
(*Close socket (which is opened by OpenUniSocket) and clear chanHandle*)
  VAR_IN_OUT
    chanHandle       : uint;  (*channel handle*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GetUniSocketStatistic {HIDDEN} : bool
(*Get statistic of uni socket (which is opened by OpenUniSocket)*)
  VAR_INPUT
    chanHandle       : uint;  (*channel handle*)
  END_VAR
  VAR_IN_OUT
    uniEthStat       : TCHxStatistic;
  END_VAR
END_FUNCTION

__DECL FUNCTION GetUniSocketControl {HIDDEN} : bool
(*Get control word of uni socket (which is opened by OpenUniSocket)*)
  VAR_INPUT
    chanHandle       : uint;  (*channel handle*)
  END_VAR
  VAR_IN_OUT
    uniEthCont       : TCHxControl;
  END_VAR
END_FUNCTION

__DECL FUNCTION SetUniSocketControl {HIDDEN} : bool
(*Set control word of uni socket (which is opened by OpenUniSocket)*)
  VAR_INPUT
    chanHandle       : uint;  (*channel handle*)
  END_VAR
  VAR_IN_OUT
    uniEthCont       : TCHxControl;
  END_VAR
END_FUNCTION

__DECL FUNCTION GetUniChanStatus {HIDDEN} : bool
(*Get status of uni channel (which is opened by OpenUniSocket)*)
  VAR_INPUT
    chanHandle       : uint;  (*channel handle*)
  END_VAR
  VAR_IN_OUT
    uniInStat        : TUni_IN_STATUS;
  END_VAR
END_FUNCTION

__DECL FUNCTION GetUniChanStatusEx {HIDDEN} : bool
(*Get status of uni channel (which is opened by OpenUniSocket)*)
  VAR_INPUT
    chanHandle       : uint;  (*channel handle*)
    dataMaxLen       : uint;  (*max length of rx buffer*)
  END_VAR
  VAR_IN_OUT
    uniInStat        : TUni_IN_STATUS;
  END_VAR
END_FUNCTION

__DECL FUNCTION GetUniChanRxData {HIDDEN} : bool
(*Get data from rx buffer of uni channel (which is opened by OpenUniSocket)*)
  VAR_INPUT
    chanHandle       : uint;  (*channel handle*)
    dataLen          : uint;
  END_VAR
  VAR_IN_OUT
    uniRxData        : usint;
  END_VAR
END_FUNCTION

__DECL FUNCTION GetUniChanControl {HIDDEN} : bool
(*Get control of uni channel (which is opened by OpenUniSocket)*)
  VAR_INPUT
    chanHandle       : uint;  (*channel handle*)
  END_VAR
  VAR_IN_OUT
    uniOutCont       : TUni_OUT_CONT;
  END_VAR
END_FUNCTION

__DECL FUNCTION SetUniChanControl {HIDDEN} : bool
(*Set control of uni channel (which is opened by OpenUniSocket)*)
  VAR_INPUT
    chanHandle       : uint;  (*channel handle*)
  END_VAR
  VAR_IN_OUT
    uniOutCont       : TUni_OUT_CONT;
  END_VAR
END_FUNCTION

__DECL FUNCTION SetUniChanTxData {HIDDEN} : bool
(*Set data to tx buffer of uni channel (which is opened by OpenUniSocket)*)
  VAR_INPUT
    chanHandle       : uint;  (*channel handle*)
    dataLen          : uint;
  END_VAR
  VAR_IN_OUT
    uniTxData        : usint;
  END_VAR
END_FUNCTION

__DECL FUNCTION GetUniChanTxData {HIDDEN} : bool
(*Get data from tx buffer of uni channel (which is opened by OpenUniSocket)*)
  VAR_INPUT
    chanHandle       : uint;  (*channel handle*)
    dataLen          : uint;
  END_VAR
  VAR_IN_OUT
    uniTxData        : usint;
  END_VAR
END_FUNCTION

TYPE TUniSocketsInfo :
  STRUCT
    numUniMdl        : uint;  (*max. poèet uni kanálù, které lze zaloit pomocí IOconfigurátoru (#module)*)
    freeUniMdl       : uint;  (*poèet volných uni kanálù, které lze zaloit pomocí IOconfigurátoru*)
    numUniChan       : uint;  (*max. poèet uni kanálù, které lze zaloit pomocí OpenUniSocket*)
    freeUniChan      : uint;  (*poèet volných uni kanálù, které lze zaloit pomocí OpenUniSocket*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION GetUniSocketsInfo : bool
(*Function returns information about ethernet channels*)
  VAR_IN_OUT
    uniInfo          : TUniSocketsInfo;
  END_VAR
END_FUNCTION

__DECL FUNCTION SetUniLog : bool
(*Record of communication to the file*)
  VAR_INPUT
    chanHandle       : uint;  (*channel handle*)
    logMode          : uint;  (*log mode: ONE_TIME_LOG x CYCLIC_LOG*)
    logSizeKB        : udint;  (*max log size [kB]*)
    logName          : string [80];  (*name of log file [kB]*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SetUniChanHostName : bool
(*Function sets the server name indication ClientHello extension to contain the value hostName.
 Using for uni SSL/TLS client only*)
  VAR_INPUT
    chanHandle       : uint;  (*channel handle*)
    hostName         : string [80];  (*server host name*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GetChanDesc {HIDDEN} : TUniDesc
(*Get a descriptor of the communication channel
     For channels which are opened by OpenUniSocket function
     returns items .modeChan and .res, others items are zero.
     Function tests memory mapping of com channel.
     This function is for internal using in library.
     Function returns channel descriptor (TUniDesc).*)
  VAR_INPUT
    chanCode         : uint;  (*channel code (ETH1_uni0, ..., ETH1_uni7, ETH2_uni0, ..., ETH2_uni7)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GetChanIndex {HIDDEN} : int
(*Test the existence of a communication channel
   Function checks validity of chanCode.
   This function is for internal using in library.
   Function returns positive channel index
   when chanCode is valid, otherwise result is -1.
   Function returns -1 for channels which are opened by OpenUniSocket*)
  VAR_INPUT
    chanCode         : uint;  (*channel code*)
  END_VAR
END_FUNCTION

VAR_GLOBAL CONSTANT
 ComErrorString : ARRAY [0..20] OF string [40] :=  [
       'No error                                ',
       'Channel is not in uni mode              ',
       'Sending data are too long               ',
       'Received data are too long              ',
       'Wrong channel code                      ',
       'Previous message is not sent yet        ',
       'Zero message length                     ',
       'Invalid communication speed             ',
       'Channel is disabled                     ',
       'Invalid start delimiter                 ',
       'Parity error                            ',
       'Maximum message length exceeded         ',
       'Invalid second byte of acknowledgment   ',
       'Invalid second byte of end delimiter    ',
       'Check sum error                         ',
       'Invalid end delimiter                   ',
       'Invalid length of sent data             ',
       'Sent data zero length                   ',
       'Timeout not held                        ',
       'Invalid channel mode                    ',
       'Unknown error                           '];

END_VAR

__DECL FUNCTION GetLastComErrTxt : string
(*errCode : USINT;         error code*)
  VAR_INPUT
    errCode          : usint;  (*error code*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GetChanSettings : bool
(*The test configuration of the serial channel
   Function tests actual settings of serial channel
   (channel must be in uni mode!).
   Function returns TRUE when successful and
   actual channels settings are set to variable chanSet.*)
  VAR_INPUT
    serChan          : usint;  (*number of serial channel (SCH1, ..., SCH10)*)
  END_VAR
  VAR_IN_OUT
    chanSet          : TChanSettings;  (*actual settings for serial channel*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SetChanSettings : usint
(*Set serial port parameters
   Function sets new parameters for serial channel
   (communication speed, parity, ...).
   Function returns 0 when successful,
   in other case function returns error number.*)
  VAR_INPUT
    rq               : bool;  (*request for new settings*)
    serChan          : usint;  (*number of serial channel (SCH1, ..., SCH10)*)
  END_VAR
  VAR_IN_OUT
    chanSet          : TChanSettings;  (*new settings for serial channel*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GetChanStat : TUni_STAT
(*Test status of the communication channel
   Function returns TUni_STAT structure.*)
  VAR CONSTANT
    initStat         : TUni_STAT :=  ( DSR := false,  CTS := false,  dummy1 := false,  TRO := false,
                              RCF := false,  ROV := false,  TRF := false,  ARC := false);
  END_VAR
  VAR_INPUT
    chanCode         : uint;  (*channel code (CH1_uni, ..., CH10_uni, ETH1_uni0, ..., ETH1_uni7, ETH2_uni0, ..., ETH2_uni7)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION EstabTCPconnection : usint
(*Establish a TCP connection
   Function starts to establish TCP connection.
   This operation takes some time.
   Function returns 0 when successful.
   If it is fails function returns error code.*)
  VAR_INPUT
    chanCode         : uint;  (*channel code (ETH1_uni0, ..., ETH1_uni7, ETH2_uni0, ..., ETH2_uni7)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION CloseTCPconnection : usint
(*Close TCP connection
   Function starts to close TCP connection.
   This operation takes some time.
   Function returns 0 when successful.
   If it is fails function returns error code.*)
  VAR_INPUT
    chanCode         : uint;  (*channel code (ETH1_uni0, ..., ETH1_uni7, ETH2_uni0, ..., ETH2_uni7)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION IsEstabTCPconnection : bool
(*Test the state of TCP connections
   Function returns TRUE when TCP connection is established,
   in other case function returns FALSE.*)
  VAR_INPUT
    chanCode         : uint;  (*channel code (ETH1_uni0, ..., ETH1_uni7, ETH2_uni0, ..., ETH2_uni7)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SetRemoteIPaddress : bool
(*Set the destination IP address
   Function sets new remote IP address,
   remote port and local port of chanCode.
   Function returns TRUE when successful,
   in other case function returns FALSE.*)
  VAR_INPUT
    rq               : bool;  (*request for new settings*)
    chanCode         : uint;  (*channel code (ETH1_uni0, ..., ETH1_uni7)*)
  END_VAR
  VAR_IN_OUT
    ethAdr           : TRemoteEthAdr;  (*new settings*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GetRemoteIPaddress : bool
(*Test the destination IP address
   Function tests actual remote IP address,
   remote port and local port of chanCode.
   Function returns TRUE when successful.
   Actual remote IP address, remote port and
   local port are set to variable ethAdr.*)
  VAR_INPUT
    chanCode         : uint;  (*channel code (ETH1_uni0, ..., ETH1_uni7)*)
  END_VAR
  VAR_IN_OUT
    ethAdr           : TRemoteEthAdr;  (*actual settings*)
  END_VAR
END_FUNCTION

VAR_GLOBAL CONSTANT
 MAX_LENGHT_OF_WEB_USER_NAME : usint :=  10;
 HTTP_URI_SIZE : usint :=  65;

END_VAR

TYPE T_SESSION_STATE : 
  (SESSION_EMPTY,
   SESSION_LOGIN,
   SESSION_LOGIN_RUN,
   SESSION_ACTIVE,
   SESSION_LOGOUT 
  );
END_TYPE

TYPE TWebServerAccess :
  STRUCT
    state            : T_SESSION_STATE;  (*session state*)
    user             : string [10];  (*user name*)
    level            : usint;  (*level of access*)
    error            : usint;  (*error code*)
    IP               : TIPadr;  (*IP address of user*)
    lastFile         : string [65];  (*name of last requested file*)
  END_STRUCT;
END_TYPE

TYPE  TWebServerAccessTable : ARRAY [0..7] OF TWebServerAccess;  (*access table of web server*)
END_TYPE

__DECL FUNCTION GetWebServerAccess : bool
(*Get information about access to web server*)
  VAR_IN_OUT
    accessTable      : TWebServerAccessTable;
  END_VAR
END_FUNCTION

__DECL FUNCTION SetRTS : bool
(*Set of RTS signal (for serial channel)
   Function returns TRUE when successful
   !!! Option "depends on SIGN.1" have to be selected
    for Control mode of RTS signal in HW configuration*)
  VAR_INPUT
    chanCode         : uint;  (*channel code (CH1_uni, ..., CH10_uni)*)
    value            : bool;  (*RTS value*)
  END_VAR
  VAR
    pUniOut          : PTR_TO TUni_OUT;
  END_VAR
END_FUNCTION

__DECL FUNCTION GetRTS : bool
(*Get state of RTS signal (for serial channel)
   Function returns state of RTS signal*)
  VAR_INPUT
    chanCode         : uint;  (*channel code (CH1_uni, ..., CH10_uni)*)
  END_VAR
  VAR
    pUniOut          : PTR_TO TUni_OUT;
  END_VAR
END_FUNCTION

__DECL FUNCTION MACADR_TO_STRING : string [18]
(*Convert MAC addresses to a text string*)
  VAR_INPUT
    macAdr           : TMacAdr;  (*MAC address array*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GetIPaddress : bool
(*Test current IP address
   Function tests actual IP address, subnet mask
   and gateway of EthChan.
   Function returns TRUE when successful and
   actual IP address, subnet mask and gateway address
   are set to variable EthAdr.*)
  VAR_INPUT
    ethChan          : usint;  (*number of Ethernet channel (ETH1, ETH2, ETH3)*)
  END_VAR
  VAR_IN_OUT
    ethAdr           : TLocalEthAdr;  (*actual IP address, subnet mask and gateway address*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SetIPaddress : bool
(*Setting up your own IP address
   Function sets new IP address, subnet mask
   and gateway of ethChan.
   Function returns TRUE when successful,
   in other case function returns FALSE.*)
  VAR_INPUT
    rq               : bool;  (*request for new settings*)
    ethChan          : usint;  (*number of Ethernet channel (ETH1, ETH2, ETH3)*)
  END_VAR
  VAR_IN_OUT
    ethAdr           : TLocalEthAdr;  (*new IP address, subnet mask and gateway address*)
  END_VAR
END_FUNCTION

__DECL FUNCTION OpenUniChannel : uint
(*Open communication channel (for Foxtrot CP-2xxx only)
           Returns handle of socket (0 means there is no free socket or there was any error).
           Handle can be used as chanCode parameter for fbRecvFrom and fbSendTo*)
  VAR_INPUT
    chanCode         : uint;  (*channel code : ANY_uni, ETH1_uni, ETH2_uni, WLAN1_uni, WLAN2_uni, LTE1_uni*)
    myPort           : uint;  (*local port*)
    hisIP            : TIPadr;  (*remote IP address*)
    hisPort          : uint;  (*remote port*)
    protocol         : usint;  (*protocol : UNI_UDP, UNI_TCP_CLIENT, UNI_TCP_SERVER, UNI_SSL_CLIENT*)
  END_VAR
END_FUNCTION

__DECL FUNCTION CloseUniChannel : bool
(*Close channel (which is opened by OpenUniChannel) and clear chanHandle*)
  VAR_IN_OUT
    chanHandle       : uint;  (*channel handle*)
  END_VAR
END_FUNCTION

__DECL FUNCTION_BLOCK fbSendTo
(*Transmit data over the communication channel
   Function block sends array data[] to communication
   channel specified by chanCode. Data length is specified
   by variable lenTx.
   Function block returns information about
   sending message. If there is no error,
   variable error is 0.*)
  VAR_INPUT
    rq               : bool;  (*request to send*)
    chanCode         : uint;  (*channel code (CH1_uni, ..., CH10_uni, ETH1_uni0, ..., ETH1_uni7, ETH2_uni0, ..., ETH4_uni7)*)
    lenTx            : uint;  (*message size (number of bytes)*)
  END_VAR
  VAR_IN_OUT
    data             : TUni_BUFF;  (*buffer for send message*)
  END_VAR
  VAR_OUTPUT
    mesSent          : bool;  (*sending of message was started*)
    error            : usint;  (*error code*)
    lenData          : uint;  (*size of sending message*)
  END_VAR
  VAR
    pUniOut          : PTR_TO TUni_OUT;
    pUniIn           : PTR_TO TUni_IN;
    pUniOutData      : PTR_TO usint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbRecvFrom
(*Receiving data from the communication channel
   Function block receives message from communication
   channel specified by chanCode. Received data are
   saved to array data[]. Length of received message
   is specified by variable lenData.
   Function block returns information about
   received message. If there is no error,
   variable error is 0.*)
  VAR_INPUT
    rq               : bool;  (*request to receive*)
    chanCode         : uint;  (*channel code (CH1_uni, ..., CH10_uni, ETH1_uni0, ..., ETH1_uni7, ETH2_uni0, ..., ETH4_uni7)*)
    lenRx            : uint;  (*max. data size (number of bytes)*)
  END_VAR
  VAR_IN_OUT
    data             : TUni_BUFF;  (*buffer for received message*)
  END_VAR
  VAR_OUTPUT
    mesRec           : bool;  (*new message flag*)
    error            : usint;  (*error code*)
    lenData          : uint;  (*number of received bytes*)
  END_VAR
  VAR
    pUniIn           : PTR_TO TUni_IN;
    pUniInData       : PTR_TO usint;
    oldARC           : bool;  (*ARRAY[0..39] OF BOOL;*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbRecvTxt
(*Receives data from communication channel delimited by CR LF*)
  VAR_INPUT
    getMes           : bool;  (*Gets message from buffer*)
    reset            : bool;  (*Flushes buffer*)
    chanCode         : uint;  (*Channel code (CH1_uni, ..., CH10_uni, ETH1_uni0, ..., ETH1_uni7, ETH2_uni0, ..., ETH4_uni7)*)
    lenBuf           : uint;  (*Lenght of buffer*)
    lenTxt           : uint;  (*Lenght of txtMes*)
  END_VAR
  VAR_OUTPUT
    full             : bool;  (*Buffer is full, messages were not taken fast enought*)
    lenMes           : uint;  (*Message length*)
    error            : usint;  (*error code*)
  END_VAR
  VAR
    actPos           : uint;
    RecvFrom         : fbRecvFrom;
  END_VAR
  VAR_IN_OUT
    buffer           : usint;  (*First byte of working buffer*)
    txtMes           : usint;  (*First byte of received text*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbRecvTxtChar
(*Receives data from communication channel delimited by charachter specified by input 'delimiter'*)
  VAR_INPUT
    getMes           : bool;  (*Gets message from buffer*)
    reset            : bool;  (*Flushes buffer*)
    chanCode         : uint;  (*Channel code (CH1_uni, ..., CH10_uni, ETH1_uni0, ..., ETH1_uni7, ETH2_uni0, ..., ETH4_uni7)*)
    lenBuf           : uint;  (*Lenght of buffer*)
    lenTxt           : uint;  (*Lenght of txtMes*)
    delimiter        : byte;  (*delimiter*)
  END_VAR
  VAR_OUTPUT
    full             : bool;  (*Buffer is full, messages were not taken fast enought*)
    lenMes           : uint;  (*Message length*)
    error            : usint;  (*error code*)
  END_VAR
  VAR
    actPos           : uint;
    RecvFrom         : fbRecvFrom;
  END_VAR
  VAR_IN_OUT
    buffer           : usint;  (*First byte of working buffer*)
    txtMes           : usint;  (*First byte of received text*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION GetMACaddress : bool
(*Test MAC address
   Function tests actual MAC address of ethChan.
   Function returns TRUE when successful and
   actual MAC address is set to variable MacAdr.*)
  VAR_INPUT
    ethChan          : usint;  (*number of Ethernet channel (ETH1, ETH2, ETH3)*)
  END_VAR
  VAR_IN_OUT
    MacAdr           : TMacAdr;  (*actual MAC address*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SetDHCPsupport : bool
(*Turn on support for DHCP
   Function sets DHCP support.
   IP address will obtain from DHCP server automatically.
   Function returns TRUE when successful,
   in other case function returns FALSE.*)
  VAR_INPUT
    rq               : bool;  (*request for DHCP support*)
    ethChan          : usint;  (*number of Ethernet channel (ETH1 only)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GetDNS_IP : TIPadr
(*Function returns IP address of DNS server*)
  VAR_INPUT
    ethChan          : usint;  (*number of Ethernet channel (ETH1 only)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SetDNS_IP : bool
(*Function sets Ip address of DNS server
   Function returns TRUE when successful,
   in other case function returns FALSE.*)
  VAR_INPUT
    rq               : bool;  (*request for new settings of DNS IP*)
    ethChan          : usint;  (*number of Ethernet channel (ETH1 only)*)
    DNS_IP           : TIPadr;  (*IP address of DNS server*)
  END_VAR
END_FUNCTION

__DECL FUNCTION STRING_TO_IPADR : TIPadr
(*Convert text string to IP address*)
  VAR_INPUT
    IPAdr            : string [80];  (*IP address string*)
  END_VAR
END_FUNCTION

__DECL FUNCTION IPADR_TO_STRING : string
  VAR_INPUT
    IPAdr            : TIPadr;  (*IP address array*)
  END_VAR
END_FUNCTION

__DECL FUNCTION_BLOCK fbKeepAliveTCP
(*Keep alive TCP connection
   In order to keep connection alive,
   function block sends ACK packets
   when TCP connection is established
   and there are no data to transmit.
   Function returns 0 when successful.
   If it is fails function returns error code.*)
  VAR_INPUT
    rq               : bool;  (*request to keep alive*)
    chanCode         : uint;  (*channel code (ETH1_uni0, ..., ETH1_uni7, ETH2_uni0, ..., ETH2_uni7)*)
    PT               : time;  (*keep alive interval (T#5s...T#60s)*)
  END_VAR
  VAR_OUTPUT
    error            : usint;  (*error code*)
  END_VAR
  VAR
    tick             : fbTick;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION CheckGatewayIP : bool
(*Check if IP address of gateway in PLC is valid*)
  VAR_INPUT
    ethChan          : usint;  (*number of Ethernet channel (ETH1, ETH2, ETH3)*)
  END_VAR
END_FUNCTION



{LIBFILE="LOCALLIB\FILELIB_V25_20190605.MLB"}
(* Mosaic IDE library *)
(* File name : D:\MosaicLib\FileLib_V25_20190605.mlb *)
(* Library : FileLib 2.5 *)
(* Author : Teco a.s. *)
(* Copyright : (c) 2010 - 2019 Teco a.s. *)
(* IEC compiler version : 4.2.4.0 *)
(* Assembler version : 4.3.00 *)

//{Knihovna : FileLib 2.5  }
(* History: *)
(*
v1.0            nem   first version
v1.1            nem   added function DiskInfo()
v1.2            nem   added function FindFreeCluster() and new function block 
CreatePath()
                      function FindFreeCluster() used in CreatePath() and WriteFile
() too
v1.3            nem   clearing idle time in WriteToFile() when busy is FALSE
                      new function block WriteDbxToFile()
                      new function block ReadDbxFromFile()
v1.4            nem   help of function DirCreate() was corrected
v1.5            nem   switch parameters order of FileOpen()   
                      new function block WriteToFileSeq ()
v1.6            nem   max cycle time was automatically increased in functions 
                      DirCreate() and FileClose() (because these functions can
                      spend more time depends on SD card)
v1.7 2010-10-26 nem   library dependency added
v1.8 2011-06-14 nem   added function FileInfo()
v1.9 2012-12-11 nem   added functions CloseAllFiles() a OpenFilesCount()
                      (FW v7.5 is required)
                      better test end of file in function blocks 
                      ReadFromFile() and ReadDbxFromFile()
v2.0 2013-12-03 nem   added function block DeleteDirectories()
v2.1 2015-10-02 byd   added function block fbReadLineFromFile()
v2.2 2016-03-16 byd   WriteToFile() and WriteDbxToFile() was modified -
                      before opening new file actual opened file is closed
v2.3 2018-01-16 nem   added function SetFileAttr()
v2.4 2019-04-10 nem   new functions FileMove(), FileRename() 
                      and ForceDirs() (for CP-2xxx only)
v2.5 2019-06-05 nem   new function DisconnectUsb() (for CP-2xxx only)
*)

(*----------------------------------------------------------------------------*)

TYPE  HANDLE : udint;  (*file identificator*)
END_TYPE

TYPE TDirStack :
  STRUCT
    hDir             : HANDLE;
    sDir             : string [12];
  END_STRUCT;
END_TYPE

VAR_GLOBAL CONSTANT
 INVALID_HANDLE_VALUE : HANDLE :=  0;  (*invalid handle value*)
 MAX_PATH : uint :=  65;  (*max size of path (number of bytes)*)
 MAX_COUNT_OPEN_FILES : uint :=  16;  (*max count of concurrently open files*)
 DIR_STACK_MAX_LEVEL : usint :=  4;  (*max number of subdirectories for deletting*)

END_VAR

TYPE TFileInfo :
  STRUCT
    creationTime     : dt;  (*file creation time*)
    modifyTime       : dt;  (*time of last modification*)
    fileSize         : udint;  (*size of file (number of bytes)*)
    attrib           : dword;  (*file attributes*)
    fileName         : string [80];  (*name of file*)
    empty {HIDDEN}   : byte;
  END_STRUCT;
END_TYPE

TYPE TDiskInfo :
  STRUCT
    TotalNumberOfKBytes : udint;  (*disc size (number of kilobytes)*)
    TotalNumberOfFreeKBytes : udint;  (*free space (number of kilobytes)*)
  END_STRUCT;
END_TYPE

TYPE TF_MODE : 
  (F_READ,
   F_WRITE,
   F_APPEND,
   F_READ_PLUS 
  );
END_TYPE

__DECL FUNCTION FileOpen : HANDLE
(*Open file

   FileOpen initializes the data structures needed to read or write a file.
   Specify the file's name as the string at file,
   and the kind of access you need to the file with mode parameter.
   Three fundamental kinds of access are available: read, write, and append.
   mode must be one of the constant: F_READ, F_WRITE or F_APPEND, to select one of these:

   F_READ        Open the file for reading. The operation will fail if the file
                 does not exist, or if the host system does not permit you to read it.
   F_WRITE       Open the file for writing from the beginning of the file ( effectively,
                 this always creates a new file). If the file whose name you specified
                 already existed, its old contents are discarded.
   F_APPEND      Open the file for appending data, that is writing from the end of file.
                 When you open a file this way, all data always goes to the current
                 end of file. It mens you cannot change this using FileSetPos.

   FileOpen returns a file indicator which you can use for other file operations,
   unless the file you requested could not be opened. In that situation, the result
   is INVALID_HANDLE_VALUE.*)
  VAR_INPUT
    mode             : TF_MODE;  (*kinds of access (F_READ / F_WRITE / F_APPEND)*)
  END_VAR
  VAR_IN_OUT
    fileName         : string [80];  (*file name (including path)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION FileClose : bool
(*Closing file

   If the file identified by hFile is open,
   FileClose closes it.

   FileClose returns TRUE if successful otherwise,
   it returns FALSE.*)
  VAR_INPUT
    hFile            : HANDLE;  (*file identificator*)
  END_VAR
END_FUNCTION

__DECL FUNCTION FileDelete : bool
(*Deleting a file

   Use FileDelete to delete the file specified by fileName.
   You can use this function to delete directory as well,
   but only in case when the directory is empty.

   FileDelete returns TRUE if it succeeds, FALSE if it fails.*)
  VAR_IN_OUT
    fileName         : string [80];  (*file name (including path)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION FileRead : udint
(*Read file

   FileRead attempts to copy, from the file identified by hFile,
   count elements (each of size size) into memory, starting at adrBuf.
   FileRead may copy fewer elements than count if an error, or end of file, intervenes.
   FileRead also advances the file position indicator (if any) for hFile
   by the number of characters actually read.

   The result of FileRead is the number of elements it succeeded in reading.*)
  VAR_INPUT
    hFile            : HANDLE;  (*file identificator*)
    adrBuf           : udint;  (*destination variable*)
    size             : udint;  (*data length (number of bytes)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION FileWrite : udint
(*Write to a file

   FileWrite attempts to copy, starting from the memory location adrBuf,
   count elements (each of size size) into the file identified by hFile.
   FileWrite may copy fewer elements than count if an error intervenes.
   FileWrite also advances the file position indicator (if any) for hFile
   by the number of characters actually written.

   If FileWrite succeeds in writing all the elements you specify,
   the result is the same as the argument count.
   In any event, the result is the number of complete elements
   that FileWrite copied to the file.*)
  VAR_INPUT
    hFile            : HANDLE;  (*file identificator*)
    adrBuf           : udint;  (*variable address*)
    size             : udint;  (*data length (number of bytes)*)
  END_VAR
END_FUNCTION

VAR_GLOBAL CONSTANT
 BEGIN_POS : udint :=  0;  (*begin position in file*)
 END_POS : udint :=  16#FFFF_FFFF;  (*end position in file*)

END_VAR

__DECL FUNCTION FileSetPos : bool
(*Set file position

   Objects of type FILE can have a "position" that records
   how much of the file your program has already read.
   You can use FileSetPos to set the position for the file identified by hFile.
   BEGIN_POS and END_POS are constants to set position at begin or end of file.

   FileSetPos returns TRUE when successful.
   If FileSetPos fails, the result is FALSE.*)
  VAR_INPUT
    hFile            : HANDLE;  (*file identificator*)
    offset           : udint;  (*data offset in file*)
  END_VAR
END_FUNCTION

__DECL FUNCTION FileExists : bool
(*Test for existence of file

   Use FileExist to test if file or directory identified by fileName exists.

   FileExist returns TRUE if file exists otherwise, it returns FALSE.*)
  VAR_IN_OUT
    fileName         : string [80];  (*file name (including path)*)
  END_VAR
END_FUNCTION

VAR_GLOBAL CONSTANT
 UNKNOWN_SIZE : udint :=  16#FFFF_FFFF;  (*unknown size*)

END_VAR

__DECL FUNCTION FileSize : udint
(*Find file size

   Use FileSize to test size of file identified by hFile.

   FileSize returns size of file if successful otherwise,
   it returns 16#FFFF_FFFF.*)
  VAR_INPUT
    hFile            : HANDLE;  (*file identificator*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DirOpen : HANDLE
(*Open Directory

   Use DirOpen to open the directory specified by dirName.
   Then function find out information about first file in dir
   and these information are saved to variable dirInfo.
   For information about next file use function DirRead

   DirOpen returns identificator of directory when operation is succefull,
   otherwise invalid identificator (INVALID_HANDLE_VALUE).
   Function DirOpen sets all items in variable dirInfo
   which have to be type of TFileInfo*)
  VAR_IN_OUT
    dirName          : string [80];  (*dir name (including path)*)
    dirInfo          : TFileInfo;  (*structure contains information about first file in dir*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DirClose : bool
(*Closing directory

   If the directory identified by hDir is open, DirClose closes it.

   DirClose returns TRUE if successful otherwise, it returns FALSE.*)
  VAR_INPUT
    hDir             : HANDLE;  (*file identificator*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DirRead : bool
(*Read from directory

   Use DirRead to read next item in the directory specified by hDdir.
   Directory have to be open by function DirOpen.

   DirRead returns TRUE if it succeeds, FALSE if it fails.
   Function DirRead sets all items in variable dirInfo
   which have to be type of TFileInfo*)
  VAR_INPUT
    hDir             : HANDLE;  (*file identificator*)
  END_VAR
  VAR_IN_OUT
    dirInfo          : TFileInfo;  (*structure contains information about next file in dir*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DirCreate : bool
(*Create a directory

   If the directory specified by dirName does not exist,
   DirCreate creates it.

   DirCreate returns TRUE if successful otherwise,
   it returns FALSE.*)
  VAR_IN_OUT
    dirName          : string [80];  (*directory name (including path)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DirDelete : bool
(*Delete directory

   Use DirDelete to delete the directory specified by dirName.
   You have to be sure the directory is empty.

   DirDelete returns TRUE if it succeeds, FALSE if it fails.*)
  VAR_IN_OUT
    dirName          : string [80];  (*directory name (including path)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GetLastErr : udint
(*Get the last error code

   The file functions maintain an global error indicator,
   to record last read or write errors have occurred.
   Use GetLastErr to query this indicator.

   GetLastErr returns 0 if no errors have occurred.
   It returns a nonzero value otherwise.*)
END_FUNCTION

__DECL FUNCTION GetLastErrTxt : bool
(*Description
   Use GetLastErrTxt to get description of error specified by errCode.

   Returns
   GetLastErr returns description of error as a string.*)
  VAR_INPUT
    errCode          : udint;  (*error code*)
  END_VAR
  VAR_IN_OUT
    errMessage       : string [80];  (*error description*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DiskInfo : bool
(*Get information about disk

   Use DiskInfo to find out size of disk specified by diskName.
   If the diskName is empty, default disk is selected.

   DiskInfo returns TRUE if it succeeds, FALSE if it fails.
   Function DiskInfo sets items TotalNumberOfKBytes and
   TotalNumberOfFreeKBytes in variable diskDesc*)
  VAR_IN_OUT
    diskName         : string [80];  (*disk name (empty string for default disk)*)
    diskDesc         : TDiskInfo;  (*disk description*)
  END_VAR
END_FUNCTION

__DECL FUNCTION FindFreeCluster : byte
(*Find free disk space

   Use FindFreeCluster to find free space to accelerate disk write.

   FindFreeCluster returns 0 if free cluster found,
   13 if function still not finished, otherwise error.*)
  VAR_IN_OUT
    fileName         : string [80];  (*file name (including path)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION FileInfo : bool
(*Get information about file

   Use DirRead to read following information about specified file:
   file creation time, time of last modification,
   size of file (number of bytes) and file attributes
   This information is stored to fileDesc variable.
   DirRead returns TRUE if it succeeds, FALSE if it fails.*)
  VAR_IN_OUT
    fileName         : string [80];  (*dir name (including path)*)
    fileDesc         : TFileInfo;  (*structure contains information about file*)
  END_VAR
END_FUNCTION

__DECL FUNCTION CloseAllFiles : bool
(*Closing all open files*)
END_FUNCTION

__DECL FUNCTION OpenFilesCount : uint
(*Number of open files

   OpenFilesCount returns Number of open files.*)
END_FUNCTION

__DECL FUNCTION FileMove : bool
(*Move/rename file

   FileMove changes the name of the file specified by oldName to newName.
   If oldName and newName specify different paths the file is moved to the new location.
   This function is supported in system Foxtrot CP-2xxx only.

   The result of FileMove is true if the file is successfully renamed.*)
  VAR_IN_OUT
    oldName          : string [80];  (*old file name (including path)*)
    newName          : string [80];  (*new file name (including path)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION FileRename : bool
(*Move/rename file

   FileMove changes the name of the file specified by oldName to newName.
   If oldName and newName specify different paths the file is moved to the new location.
   This function is supported in system Foxtrot CP-2xxx only.

   The result of FileMove is true if the file is successfully renamed.*)
  VAR_IN_OUT
    oldName          : string [80];  (*old file name (including path)*)
    newName          : string [80];  (*new file name (including path)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SetFileAttr : bool
(*Set file attributes
   FAT FILE SYTEM :
   AM_RDO	16#01	 Read Only
   AM_HID	16#02	 Hidden
   AM_SYS	16#04	 System
   AM_VOL	16#08	 Volume Label
   AM_DIR	16#10	 Directory
   AM_ARC	16#20	 Archive*)
  VAR_INPUT
    attrib           : dword;  (*attributes*)
  END_VAR
  VAR_IN_OUT
    fileName         : string [80];  (*file name (including path)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION ForceDirs : bool
(*Create full path (CP-2xxx only)
   DirCreate returns TRUE if successful otherwise,
   it returns FALSE.*)
  VAR_IN_OUT
    fileName         : string [80];  (*file name (including path)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION_BLOCK ReadFromFile
(*Copy data from file to variable

   Returns
   Busy is TRUE during file reading.
   Done is TRUE when reading is finished.
   If reading failed, err output is TRUE
   and errID output contains code of error*)
  VAR_IN_OUT
    fileName         : string [80];  (*file name (including path)*)
    dstVar           : udint;  (*address of destination variable*)
  END_VAR
  VAR_INPUT
    exec             : bool;  (*read request (rising edge)*)
    seek             : udint;  (*data offset in file*)
    size             : udint;  (*data length <= size of variable (number of bytes)*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*action is done*)
    busy             : bool;  (*action in progress*)
    err              : bool;  (*error flag*)
    errID            : udint;  (*error number (0 = no error)*)
    actSize          : udint;  (*number of bytes really read*)
  END_VAR
  VAR
    execTrig         : R_TRIG;
    errTrig          : R_TRIG;
    hnd              : HANDLE;
    adrVar           : udint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK WriteToFile
(*Copy data from variable to file
   
   If file does not exist new file is created.
   If file exists file content is overwitten.

   Returns
   Busy is TRUE during file writing.
   Done is TRUE when writing is finished.
   If writing failed, err output is TRUE
   and errID output contains code of error*)
  VAR_IN_OUT
    fileName         : string [80];  (*file name (including path)*)
    srcVar           : udint;  (*address of source variable*)
  END_VAR
  VAR_INPUT
    exec             : bool;  (*write request (rising edge)*)
    seek             : udint;  (*data offset in file*)
    size             : udint;  (*data length (number of bytes)*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*action is done*)
    busy             : bool;  (*action in progress*)
    err              : bool;  (*error flag*)
    errID            : udint;  (*error number (0 = no error)*)
    actSize          : udint;  (*number of bytes really written*)
  END_VAR
  VAR
    eTrig            : R_TRIG;
    errTrig          : R_TRIG;
    hnd              : HANDLE;
    adrVar           : udint;
    idle             : uint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK CreatePath
(*Create a directory (including path)

   Check path and create it if does not exist
   
   Returns
   Busy is TRUE during path creating.
   Done is TRUE when path creating is finished.
   If path creating failed, err output is TRUE
   and errID output contains code of error*)
  VAR_INPUT
    exec             : bool;  (*request (rising edge)*)
  END_VAR
  VAR_IN_OUT
    fileName         : string [80];  (*dir name including path (e.g. WWW/NEW_DIR/)*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*action is done*)
    busy             : bool;  (*action in progress*)
    err              : bool;  (*error flag*)
    errID            : udint;  (*error number (0 = no error)*)
  END_VAR
  VAR
    eTrig            : R_TRIG;  (*rising edge of exec*)
    errTrig          : R_TRIG;  (*rising edge of err*)
    createDir        : bool;
    path             : string [80];
    copy             : string [80];
    idle             : uint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK WriteDbxToFile
(*Copy data from databox to file
   
   If file does not exist new file is created.
   If file exists file content is overwitten.
   Supported on CPM type K version 4.5 and higher

   Returns
   Busy is TRUE during file writing.
   Done is TRUE when writing is finished.
   If writing failed, err output is TRUE
   and errID output contains code of error*)
  VAR_IN_OUT
    fileName         : string [80];  (*file name (including path)*)
  END_VAR
  VAR_INPUT
    exec             : bool;  (*request (rising edge)*)
    seek             : udint;  (*data offset in file*)
    srcAdr           : udint;  (*databox address*)
    size             : udint;  (*data length (number of bytes)*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*action is done*)
    busy             : bool;  (*action in progress*)
    err              : bool;  (*error flag*)
    errID            : udint;  (*error number (0 = no error)*)
    actSize          : udint;  (*number of bytes really written*)
  END_VAR
  VAR
    eTrig            : R_TRIG;
    errTrig          : R_TRIG;
    hnd              : HANDLE;
    adrVar           : udint;
    idle             : uint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK ReadDbxFromFile
(*Copy data from a file to DataBox memory

   Copy data from file to databox
   Supported on CPM type K version 4.5 and higher

   Returns
   Busy is TRUE during file reading.
   Done is TRUE when reading is finished.
   If reading failed, err output is TRUE
   and errID output contains code of error*)
  VAR_IN_OUT
    fileName         : string [80];  (*file name (including path)*)
  END_VAR
  VAR_INPUT
    exec             : bool;  (*request (rising edge)*)
    seek             : udint;  (*data offset in file*)
    dstAdr           : udint;  (*databox address*)
    size             : udint;  (*data length <= size of variable (number of bytes)*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*action is done*)
    busy             : bool;  (*action in progress*)
    err              : bool;  (*error flag*)
    errID            : udint;  (*error number (0 = no error)*)
    actSize          : udint;  (*number of bytes really read*)
  END_VAR
  VAR
    execTrig         : R_TRIG;
    errTrig          : R_TRIG;
    hnd              : HANDLE;
    adrVar           : udint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK WriteToFileSeq
(*Sequential write data to file

   Copy data from variable to file sequentaly each time
   the write variable is set to true.
   If file does not exist new file is created.
   If file exists file content is overwitten.

   Returns
   Open is TRUE whyn file is open.
   If writing failed, err output is TRUE
   and errID output contains code of error*)
  VAR_IN_OUT
    fileName         : string [80];  (*file name (including path)*)
    srcVar           : udint;  (*address of source variable*)
  END_VAR
  VAR_INPUT
    write            : bool;  (*request*)
    close            : bool;  (*close opened file*)
    size             : udint;  (*data length (number of bytes)*)
  END_VAR
  VAR_OUTPUT
    open             : bool;  (*file is open, next data will be appended to rest*)
    err              : bool;  (*error flag*)
    errID            : udint;  (*error number (0 = no error)*)
    actSize          : udint;  (*actual file size (number of bytes)*)
  END_VAR
  VAR
    errTrig          : R_TRIG;
    wrSize           : udint;
    hnd              : HANDLE;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK DeleteDirectories
(*Delete content of directory including content of nested directories

   Delete all files in directory.
   Max. number of nested directories = 4*)
  VAR_INPUT
    exec             : bool R_EDGE;  (*request (rising edge)*)
  END_VAR
  VAR_IN_OUT
    dirName          : string [80];  (*dir name (including path)*)
  END_VAR
  VAR
    dirStack         : ARRAY [0..4] OF TDirStack;
    CurrFile         : string [80];
    dirStackLev      : usint;
    i                : usint;
    lLocalFileInfo   : TFileInfo;
  END_VAR
  VAR_OUTPUT
    Done             : bool;
    Busy             : bool;
    Err              : bool;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK ReadLine
(*Read line from file
        Number of desired line is defined by input line.
        First line in file has number 1.
        Desired line is stored in variable txtLine including characters CR and LF.
        Variable txtLine have to be of type STRING with lenght equal or greater than maxLen.
        Finding of line in file may take more than one PLC cycle.
        Output busy is set to TRUE during searching.
        When line is found, outpud done is set to TRUE (for one cycle of PLC).
        If the line is longer than maxLen, output lineContinues is set and line is passed in multiple parts.
        Every PLC cycle one part of line is passed, last part is passed with lineContinues set to FALSE.
        (Output done is set to TRUE during passing of all parts).
        If there is any error, output errID contains error code and output errTxt description of error.
        Function block ReadLine assume that lines ends with characters CRLF (16#0D,16#0A).*)
  VAR_INPUT
    line             : udint;  (*Number of requested line (1..n)*)
    maxLen           : udint;  (*Maximal length of line*)
  END_VAR
  VAR_IN_OUT
    fileName         : string [80];  (*Filename (including path)*)
    txtLine          : string [255];  (*Line from file*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*Reading from a file is closed*)
    busy             : bool;  (*Busy reading from a file*)
    err              : bool;  (*Error flag*)
    lineContinues    : bool;  (*Line was longer than maximum lenght and will continue*)
    actLine          : udint;  (*Actual line number*)
    errID            : udint;  (*Error code (0 = no error)*)
    errTxt           : string [80];  (*The last error text*)
  END_VAR
  VAR
    lastLine         : udint;  (*cislo naposled hledaneho radku*)
    lastFile         : string [80];  (*jmeno souboru, se kterym se naposledy pracovalo*)
    actPos           : udint;  (*aktualni pozice v souboru (offset od zacatku)*)
    actSize          : udint;  (*pocet znaku nactenych ze souboru*)
    i                : int;
    index            : int;
    outidx           : uint;
    bufTxtReady      : bool;
    newFile          : bool;
    newFileTest      : bool;
    fileInf          : TFileInfo;  (*struktura s informacemi o souboru*)
    empty            : word;
    ReadFile         : ReadFromFile;
  END_VAR
  VAR CONSTANT
    SEPARATOR        : ARRAY [0..1] OF byte :=  [ 16#0A, 0];
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION DisconnectUsbDisk : bool
(*Unmounting USB Flash disk (CP-2xxx only)*)
END_FUNCTION



{LIBFILE="LOCALLIB\DATABOXLIB_V16_20160713.MLB"}
(* Mosaic IDE library *)
(* File name : C:\TecoLib\DataBoxLib_V16_20160713.mlb *)
(* Library : DataBoxLib 1.6 *)
(* Author : Teco a.s. Kolin *)
(* Copyright : (c) 2004, 2016 Teco a.s. *)
(* IEC compiler version : 3.11.8.1 *)
(* Assembler version : 4.3.00 *)

//{Knihovna : DataBoxLib 1.6  }
(* History: *)
(*
v1.0 2004-02-17 Nem First edition
v1.1 2004-09-09 Nem Rewrited without using directive system_fc on
v1.2 2007-08-30 Nem Compiled with new version of ST compiler (v3.3.2.0)
v1.3 2010-01-11 Nem Order of input variables changed : 
                    functions ReadBlockFromDBx and WriteBlockToDBx 
                    (it is better for LD a FBD languages)
v1.4 2010-09-02 Nem Dependency on the libraries added
v1.5 2013-11-18 Nem Corrected bug in case when address of variable is > %R65535
                    (Foxtrot firmware v8.1 or higher is necessary)  
v1.6 2016-07-13 Nem New functions ReadFromDBx() and WriteToDBx()
                    (Foxtrot firmware v8.7 or higher is necessary)
*)

(*----------------------------------------------------------------------------*)

VAR_GLOBAL CONSTANT
 MAX_LENGTH_DATABOX_BLOCK : int :=  10000;

END_VAR

TYPE TDataBoxPar :
  STRUCT
    databoxAddress   : udint;
    registerIndex    : uint;
    blockLength      : usint;
  END_STRUCT;
END_TYPE

TYPE  TPtrNaPole : ARRAY [0..10000] OF usint;
END_TYPE

__DECL FUNCTION ReadBlockFromDBx : usint
(*Transfer of data block from DataBox memory to variable

         Maximal block size is 255 bytes
         Return value : number of transfered bytes*)
  VAR_INPUT
    dataBoxAddress   : udint;  (*source address (DataBox)*)
    length           : usint;  (*size of data block (number of bytes, max 255)*)
  END_VAR
  VAR_IN_OUT
    variable         : usint;  (*destination address (variable)*)
  END_VAR
  VAR
    par              : TDataBoxPar;
  END_VAR
END_FUNCTION

__DECL FUNCTION WriteBlockToDBx : usint
(*Transfers of data block from variable to DataBox memory

         Maximal block size is 255 bytes
         Return value : number of transfered bytes*)
  VAR_INPUT
    dataBoxAddress   : udint;  (*destination address (DataBox)*)
    length           : usint;  (*size of data block (number of bytes, max 255)*)
  END_VAR
  VAR_IN_OUT
    variable         : usint;  (*source address (variable)*)
  END_VAR
  VAR
    par              : TDataBoxPar;
  END_VAR
END_FUNCTION

__DECL FUNCTION ReadFromDataBox : bool
(*Transfer of data block from DataBox memory to variable

         Maximal block size is 10000 bytes
         Return value : TRUE if all data was transfered
         Warning !!!
         - variable must be allocated inside %M or %R !!!
         - variable's data type can not be BOOL or ARRAY[] OF BOOL !!!*)
  VAR_INPUT
    dataBoxAddress   : udint;  (*source address (DataBox)*)
    length           : uint;  (*size of data block (number of bytes, max 10000)*)
  END_VAR
  VAR_IN_OUT
    variable         : TPtrNaPole;  (*destination address (variable)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION WriteToDataBox : bool
(*Transfer of data block from variable to DataBox memory

         Maximal block size is 10000 bytes
         Return value : TRUE if all data was transfered
         Warning !!!
         - variable must be allocated inside %M or %R !!!
         - variable's data type can not be BOOL or ARRAY[] OF BOOL !!!*)
  VAR_INPUT
    dataBoxAddress   : udint;  (*destination address (DataBox)*)
    length           : uint;  (*size of data block (number of bytes, max 10000)*)
  END_VAR
  VAR_IN_OUT
    variable         : TPtrNaPole;  (*source address (variable)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SizeOfDataBox : uint
(*DataBox memory size identification

         Return value : DataBox memory size [kilobytes]*)
END_FUNCTION

__DECL FUNCTION ReadFromDBx : bool
(*Transfer of data block from DataBox memory to variable
         Return value is TRUE if all data was transferred
         Warning !!!
         - function requires Foxtrot with FW v8.7 or higher
         - variable's data type can not be BOOL or ARRAY[] OF BOOL !!!*)
  VAR_INPUT
    dataBoxAddress   : udint;  (*source address (address in DataBox)*)
    length           : udint;  (*size of data block (number of bytes)*)
    varAddress       : udint;  (*destination address (address of variable)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION WriteToDBx : bool
(*Transfers of data block from variable to DataBox memory
         Return value is TRUE if all data was transferred
         Warning !!!
         - function requires Foxtrot with FW v8.7 or higher
         - variable's data type can not be BOOL or ARRAY[] OF BOOL !!!*)
  VAR_INPUT
    dataBoxAddress   : udint;  (*source address (address in DataBox)*)
    length           : udint;  (*size of data block (number of bytes)*)
    varAddress       : udint;  (*destination address (address of variable)*)
  END_VAR
END_FUNCTION



{LIBFILE="LOCALLIB\ENCRYPTLIB_V12_20160923.MLB"}
(* Mosaic IDE library *)
(* File name : D:\TecoUserLibs\EncryptLib_V12_20160923.mlb *)
(* Library : EncryptLib 1.2 *)
(* Author : Teco a.s. *)
(* Copyright : (c) 2016 Teco a.s. *)
(* IEC compiler version : 3.11.8.1 *)
(* Assembler version : 4.3.00 *)

//{Knihovna : EncryptLib 1.2  }
(* History: *)
(*
v1.0 2014-06-22 nem first version of library
                    functions: AES128_encrypt() and AES128_decrypt(),  RC4(),
                               SHA1_hash(), Base64_encode(), Base64_decode() 
                    Foxtrot firmware v8.8 or higher is needed
v1.1 2016-01-19 nem added function SHA256_hash(), which needs
                    Foxtrot firmware v9.7 or higher
v1.2 2016-09-23 byd added function Base64_encode_string and Base64_encode_ptr_string for coding text and data strings to base64 strings
*)

(*----------------------------------------------------------------------------*)
// {LIBRARY="LOCALLIB\SYSLIB_V33_20130621.MLB"}

__DECL FUNCTION AES128_encrypt : uint
(*AES-128 CBC encryption*)
  VAR_INPUT
    dataLen          : uint;  (*Length of data in bytes (must be divisible by 16)*)
    bufferLen        : uint;  (*Size of output buffer in bytes*)
  END_VAR
  VAR_IN_OUT
    key              : usint;  (*Encryption key (16 bytes)*)
    iv               : usint;  (*Encryption init vector for CBC mode (16 bytes)*)
    data             : usint;  (*Data to encrypt in-place*)
  END_VAR
END_FUNCTION

__DECL FUNCTION AES128_decrypt : uint
(*AES-128 CBC decryption*)
  VAR_INPUT
    dataLen          : uint;  (*Length of data in bytes (must be divisible by 16)*)
  END_VAR
  VAR_IN_OUT
    key              : usint;  (*Decryption key (16 bytes)*)
    iv               : usint;  (*Decryption init vector for CBC mode (16 bytes)*)
    data             : usint;  (*Data to decrypt in-place*)
  END_VAR
END_FUNCTION

__DECL FUNCTION RC4 : uint
(*RC4 encryption / decryption*)
  VAR_INPUT
    dataLen          : uint;  (*Length of data in bytes*)
    keyLen           : uint;  (*Length of the encryption/decryption key in bytes*)
    skip             : uint;  (*How many bytes from the RC4 generator are skipped*)
  END_VAR
  VAR_IN_OUT
    key              : usint;  (*Encryption / decryption key*)
    data             : usint;  (*Data to encrypt / decrypt in-place*)
  END_VAR
END_FUNCTION

__DECL FUNCTION Base64_encode : uint
(*Binary-to-text encoding
         Function returns size of encoded text in bytes*)
  VAR_INPUT
    dataLen          : uint;  (*Length of data in bytes*)
    bufferLen        : uint;  (*Size of output buffer in bytes*)
  END_VAR
  VAR_IN_OUT
    data             : usint;  (*Data to encode*)
    out              : usint;  (*encoded output*)
  END_VAR
END_FUNCTION

__DECL FUNCTION Base64_decode : uint
(*text-to-binary decoding
         Function returns size of decoded data in bytes*)
  VAR_INPUT
    dataLen          : uint;  (*Length of data in bytes*)
  END_VAR
  VAR_IN_OUT
    data             : usint;  (*Data to decode*)
    out              : usint;  (*decoded output*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SHA1_hash : uint
(*Secure Hash Algorithm
         SHA1_hash produces a 160-bit hash value which is rendered to output as a string of hexadecimal numbers, 40 digits long
         Function returns size of produced hash in bytes
         Size of hash variable must be 41 bytes or more. In other cases function returns 0.*)
  VAR_INPUT
    dataLen          : uint;  (*Length of data in bytes*)
    bufferLen        : uint;  (*Size of output buffer in bytes*)
  END_VAR
  VAR_IN_OUT
    data             : usint;  (*Data to encode*)
    hash             : string [80];  (*output*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SHA256_hash : uint
(*Secure Hash Algorithm SHA256
         SHA1_hash produces a 256-bit hash value which is rendered to output as a string of hexadecimal numbers, 64 digits long
         Function returns size of produced hash in bytes
         Size of hash variable must be 65 bytes or more. In other cases function returns 0.*)
  VAR_INPUT
    dataLen          : uint;  (*Length of data in bytes*)
    bufferLen        : uint;  (*Size of output buffer in bytes*)
  END_VAR
  VAR_IN_OUT
    data             : usint;  (*Data to encode*)
    hash             : string [80];  (*output*)
  END_VAR
END_FUNCTION

__DECL FUNCTION HMAC_SHA256 : uint
(*Secure Hash Algorithm HMAC-SHA256
         HMAC-SHA256 produces a 256-bit hash value which is rendered to output as byte array, 32 bytes long
         Function returns size of produced hash in bytes
         Size of hash variable must be 32 bytes or more. In other cases function returns 0.*)
  VAR_INPUT
    keyLen           : uint;  (*Length of key in bytes*)
    dataLen          : uint;  (*Length of data in bytes*)
    bufferLen        : uint;  (*Size of output buffer in bytes*)
  END_VAR
  VAR_IN_OUT
    key              : usint;  (*key code*)
    data             : usint;  (*Data to encode*)
    hash             : string [80];  (*output*)
  END_VAR
END_FUNCTION

__DECL FUNCTION Base64_encode_string : string
(*Encode ASCII String to Base64 String*)
  VAR_INPUT
    data             : string [60];  (*input ASCII string of maximum length 60 characters*)
  END_VAR
END_FUNCTION

__DECL FUNCTION Base64_encode_ptr_string : string
(*Encode ASCII String to Base64 String*)
  VAR_INPUT
    data             : PTR_TO usint;  (*ukazatel na první byte dat ke kódování*)
    dataLen          : uint;  (*length of data in bytes (max. 60)*)
  END_VAR
END_FUNCTION



{LIBFILE="LOCALLIB\INTERNETLIB_V48_20190902.MLB"}
(* Mosaic IDE library *)
(* File name : D:\MosaicLib\InternetLib_V48_20190902.mlb *)
(* Library : InternetLib 4.8 *)
(* Author : Teco a.s. *)
(* Copyright : (c) 2010 - 2019 *)
(* IEC compiler version : 4.2.7.0 *)
(* Assembler version : 4.3.00 *)

//{Knihovna : InternetLib 4.8  }
(* History: *)
(*
v4.8 02.09.2019 Nem
  Block fbPing corrected for using on central unit CP-2xxx (Foxtrot 2 family)
v4.7 11.06.2019 Byd
  fbSmtp - fixed behaviour of Send output
  fbHttpRequest - corrected receiving of HTTP header (when it is fragmented)
v4.6 30.10.2018 Nem
  Modification of fbSplitUrlAddress for URL starting with https://
  Byd 
  Added fbSmtpDbx - same as fbSmtp but attachement is from the databox instead of a file
  Changed processing of multiline replies for fbRetriveFromFtp
v4.5 2018-04-16 Byd
  Fixed handling of fractions of seconds in function block fbSntp
v4.4 2018-03-08 Byd
  fbStoreToFtp: input append added. It allows to switch file transfer from mode that overwrites target files to mode that appends new data to the end of existing files or create new if there is no such file
v4.3 2018-01-22 Byd 
  fbNsLookEx: added detection, when an IP address is passed instead of a domain name
v4.2 2017-11-01 Nem
  fbSplitUrlAddress : Size of variable Action was changed to STRING[255]
v4.1 2017-05-02 Byd
  fbSmtp: Added option to assign attachement type and generate Message-ID
  fbSmtp: Fixed boundary definition that was longer than recommended 80 characters
  fbSmtp: Base64-encoded attachment lines are truncated to 76 characters to comply with common standard
v4.0 2017-02-16 Byd
  Modified block fbSmtp for negative UTC offsets
v3.9 2016-12-09 Byd
  Added block for retrieving file from FTP server fbRetriveFromFtp
v3.8 2016-10-19 Nem
  Added blocks fbPingIP and fbPing (requires Foxtrot FW v9.9 or more)
v3.7 2016-09-23 Byd
  Encoding to Base64 is using EncryptLib - firmware v8.8 is mandatory
  Added block fbRetriveFromFtp for obtaining file from FTP server
  Modified block fbSplitUrlAddress to be able to work with address including name and password for basic authentication
  Added possibility to actively close connection for blocks fbHttpRequest, fbHttpRequestL and fbHttpRequestL2
  For block fbSmtp it's now possible to specify charset, which is used for subject and body of mail
v3.6 2016-05-16 Byd
  Block fbSmtp expanded to allow blind copy (address, in front of which is put a full 
stop, won't be displayed to recipient)
v3.5 2015-11-20 Byd
  Blocks HttpRequest set output Busy in the same cycle, when they are leaving Idle 
state
v3.4 2015-10-2 Byd
  Added block fbSplitUrlAddress
v3.3 2015-09-18
  Modification of fbSMTP block - use of EHLO instead of HELO
v3.2 2015-09-04 Byd
  Ommited KeyID and Message Authentication Code from SNTP
v3.1 2014-04-22 Byd
  fbStoreToFtp blok checks overflow of TCP sending buffer (requires ComLib 1.4)
v3.0 2014-04-02 Byd
  Output Done of block fbSmtp was set even if message was not sucessfully sent.
  Faster coding to Base64
  Fixed hazard when sending long attachments from version 2.8
v2.9 2013-10-22 Byd
  Added function blok fbHttpRequestL2 with option to add content type (Content-Type)
v2.8 2013-06-06 Byd
  Block fbStoreToFtp maintains control connections during data transmission 
(requires firmware 7.7)
  Block fbSmtp supports multi-line server responses
v2.7 2013-05-29 Byd
  During access to non-existent file block fbStoreToFtp accepts all negative reply 
codes 5xx
  Blocking timeout for transfer of large files 
v2.6 2013-02-27 Byd
  Modifacation of fbSntp for negative offset from UTC
  Longer timeout for HTTP protocol
v2.5 2013-01-16 Byd
  Fixed error in fbHttpRequestL from version 2.4 (block sent only header)
V2.4 2012-10-05 Byd
  Added support for basic authentication passed in URI name:password@domain 
V2.3 2012-08-21 Byd
  Creating path at FTP server
  Posibility to upload whole directories to FTP
V2.2 2012-03-06 Byd
  Empty command leaved out of communication with SMTP server (some servers returned 
negative reply)
V2.1 2012-02-13 Byd
  Block NsLookUpEx added for translation of domain names with firmware support
  (require firmware 7.1 or higher)
  Corrected behaviour of outputs Done and Err in fbStoreToFtp  
V2.0 2011-12-01 Byd
  Function GetDateAndTime_RFC2822 moved to library TimeLib  
V1.9 2011-04-08 Byd
  Lenght checking added for sending via HTTP
  Block fbHttpRequestL for sending long data via method POST added.
  Block fbStringStream for filling work buffer from STRING variables added.
V1.8 2010-03-17 Byd
  Time stamp added for sending via SMTP 
V1.7 2010-12-8 Byd
V1.6 2010-12-1 Byd
  Added reply code 125 if connection to FTP server is already established. 
V1.5 2010-09-02 Byd
  Dependency on the libraries added.
V1.4 Byd
  fbStoreToFtp - missing closing of file in case of transmission error added. It 
could lead to blocked file system.
V1.3 Byd
  fbStoreToFtp - block for transfering file to FTP server 
V1.2 Byd
  NsLookUp - expanded error numbers from 2 to 16 equal ResponseCode RFC1035 + 1
V1.1 Byd
  Smtp blok checks overflow of TCP sending buffer (requires ComLib 1.4)
*)

(*----------------------------------------------------------------------------*)

VAR_GLOBAL CONSTANT
 INTERNETLIB_END_OF_LINE_ {HIDDEN} : string [2] :=  '$r$l';
 INTERNETLIB_EMPTY_STRING_ {HIDDEN} : string [1] :=  '';

END_VAR

__DECL FUNCTION _FindNextPathSeparator {HIDDEN} : bool
  VAR_IN_OUT
    In               : string [80];  (*string with path*)
    Pos              : udint;  (*start with zero*)
  END_VAR
END_FUNCTION

TYPE TDnsReplyHeader :
  STRUCT
    TransactionID    : uint;
    Recursion_des    : bool;
    Truncated        : bool;
    Authoritative    : bool;
    OpCode_0         : bool;
    OpCode_1         : bool;
    OpCode_2         : bool;
    OpCode_3         : bool;
    Response         : bool;
    ReplyCode_0      : bool;
    ReplyCode_1      : bool;
    ReplyCode_2      : bool;
    ReplyCode_3      : bool;
    Empty            : bool;
    Autheticated     : bool;
    Reseved          : bool;
    Recursion_ava    : bool;
    Question         : uint;
    AnswerRRs        : uint;
    AuthorityRRs     : uint;
    AdditionalRRs    : uint;
  END_STRUCT;
END_TYPE

TYPE TDnsReply :
  STRUCT
    Header           : TDnsReplyHeader;
    Data             : ARRAY [0..511] OF usint;
  END_STRUCT;
END_TYPE

TYPE TDnsQueryHeader :
  STRUCT
    TransactionID    : uint;
    Recursion_des    : bool;
    Truncated        : bool;
    Empty_6          : bool;
    OpCode_0         : bool;
    OpCode_1         : bool;
    OpCode_2         : bool;
    OpCode_3         : bool;
    Query            : bool;
    Empty_0          : bool;
    Empty_1          : bool;
    Empty_2          : bool;
    Empty_3          : bool;
    NonAutheticated  : bool;
    Empty_4          : bool;
    Reseved          : bool;
    Empty_5          : bool;
    Question         : uint;
    AnswerRRs        : uint;
    AuthorityRRs     : uint;
    AdditionalRRs    : uint;
  END_STRUCT;
END_TYPE

TYPE TDnsQuery :
  STRUCT
    Header           : TDnsQueryHeader;
    QueryString      : string [80];
  END_STRUCT;
END_TYPE

__DECL FUNCTION _internetlib_DnsLenOfDomainName {HIDDEN} : udint
  VAR_INPUT
    IN               : PTR_TO usint;
  END_VAR
END_FUNCTION

__DECL FUNCTION _internetlib_DnsCodeDomainName {HIDDEN} : string
(*Code name of domain*)
  VAR_INPUT
    IN               : string [80];
  END_VAR
  VAR
    I                : int;
  END_VAR
END_FUNCTION

__DECL FUNCTION _internetlib_DnsDecodeDomainName {HIDDEN} : string
(*Decode name of domain*)
  VAR_INPUT
    IN               : PTR_TO usint;
    BG               : PTR_TO usint;
  END_VAR
END_FUNCTION

__DECL FUNCTION_BLOCK fbNsLookUp
(*Gets IP address of the provided domain name*)
  VAR_INPUT
    getIP            : bool R_EDGE;  (*Get IP address by Name*)
    chanCode         : uint;  (*UNI channel  UDP, lport: 0, rport: 53, in: 524, out: 93*)
    DnsIP            : TIPadr;  (*DNS server IP address*)
  END_VAR
  VAR_IN_OUT
    Name             : string [80];  (*Domain name*)
    IP               : TIPadr;  (*Obtained IP address*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*IP address successfully obtained*)
    Busy             : bool;  (*Operation pending*)
    Err              : bool;  (*Error occured*)
    ErrId            : usint;  (*Error number*)
  END_VAR
  VAR
    RecvFrom         : fbRecvFrom;
    SendTo           : fbSendTo;
    timeout          : TON;
    timeout2         : TON;
    netDnsQuery      : TDnsQuery;
    netDnsReply      : TDnsReply;
    TransID          : uint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbNsLookUpEx
(*Gets IP address of the provided domain name*)
  VAR_INPUT
    getIP            : bool R_EDGE;  (*Get IP address by Name*)
    dnsIP            : TIPadr;  (*DNS server IP address*)
    Name             : string [80];  (*Domain name*)
  END_VAR
  VAR_IN_OUT
    IP               : TIPadr;  (*Obtained IP address*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*IP address successfully obtained*)
    Busy             : bool;  (*Operation pending*)
    Err              : bool;  (*Error occured*)
    ErrId            : usint;  (*Error number*)
  END_VAR
  VAR
    CurrName         : string [80];  (*current domain name*)
  END_VAR
  VAR CONSTANT
    HTTP_IP_NULL     : TIPadr :=  [0,0,0,0];
  END_VAR
END_FUNCTION_BLOCK

TYPE  THttpBuffer : ARRAY [0..511] OF usint;
END_TYPE

TYPE THttpState : 
  (hs_HttpIdle,
   hs_HttpSetIP,
   hs_HttpConnect,
   hs_HttpSend,
   hs_HttpReceivingData,
   hs_HttpSendPost 
  );
END_TYPE

__DECL FUNCTION_BLOCK fbHttpRequest
(*Sends POST and GET metods via HTTP*)
  VAR_INPUT
    Post             : bool R_EDGE;  (*Send data via method POST*)
    Get              : bool R_EDGE;  (*Get data via method GET*)
    Cancel           : bool R_EDGE;  (*Cancel pending operation*)
    chanCode         : uint;  (*UNI channel TCP master in: 512, out: 512*)
    IPadr            : TIPadr;  (*IP address of remote server*)
    port             : uint :=  80;  (*Port of remote server*)
    Close            : bool;  (*If set, block don't wait for server to close connection and close it actively after receiving all data*)
  END_VAR
  VAR_IN_OUT
    Action           : string [255];  (*Path to a data on the server (always starts with character '/')*)
    Host             : string [80];  (*Host name*)
    Data             : string [80];  (*POST data*)
    RecvData         : THttpBuffer;  (*Data buffer 512 bytes*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*Operation done*)
    Busy             : bool;  (*Operation pending*)
    Err              : bool;  (*Communication error*)
    ErrId            : usint;  (*Error number*)
    DataReady        : bool;  (*New data received*)
    DataLen          : uint;  (*Data length*)
    State            : THttpState;  (*State of communication*)
    Result           : int;  (*HTTP Code*)
    Progress         : sint;  (*Progress of data downloading*)
  END_VAR
  VAR
    ResRecv          : bool;
    LenRecv          : bool;
    HeaderRecv       : bool;
    TimeOutTon       : TON;
    helpstring       : string [255];
    RecvFrom         : fbRecvFrom;
    SendTo           : fbSendTo;
    ContLen          : dint;
    WholeLen         : dint;
    lHost            : string [80];
    sOff             : uint;
    rLen             : uint;
  END_VAR
END_FUNCTION_BLOCK

TYPE TSmtpState : 
  (ss_SmtpInit,
   ss_SmtpIdle,
   ss_SmtpSetIP,
   ss_SmtpTxConnect,
   ss_SmtpRxConnect,
   ss_SmtpTxHelo,
   ss_SmtpRxHelo,
   ss_SmtpTxAuthlogin,
   ss_SmtpRxAuthlogin,
   ss_SmtpTxUserName,
   ss_SmtpRxUserName,
   ss_SmtpTxPassword,
   ss_SmtpRxPassword,
   ss_SmtpTxMailFrom,
   ss_SmtpRxMailFrom,
   ss_SmtpTxRcptTo,
   ss_SmtpRxRcptTo,
   ss_SmtpTxData,
   ss_SmtpRxData,
   ss_SmtpTxDataFrom,
   ss_SmtpTxDataTo,
   ss_SmtpTxDataSubject,
   ss_SmtpTxMultipart,
   ss_SmtpTxDataText,
   ss_SmtpTxAttachement,
   ss_SmtpTxAttachementBody,
   ss_SmtpTxEndOfMail,
   ss_SmtpRxAck,
   ss_SmtpTxQuit,
   ss_SmtpRxClose,
   ss_SmtpRxTimeout,
   ss_SmtpRxError,
   ss_SmtpTxDate,
   ss_SmtpTxContentType,
   ss_SmtpTxMessageId 
  );
END_TYPE

VAR_GLOBAL CONSTANT
 SMTP_END_OF_LINE_2_ {HIDDEN} : string [3] :=  '>$r$l';

END_VAR

__DECL FUNCTION_BLOCK fbSmtp
(*Sends email messages via SMTP*)
  VAR_INPUT
    Send             : bool R_EDGE;  (*starts sending of email*)
    Auth             : bool;  (*authetification requiered?*)
    Cancel           : bool R_EDGE;  (*cancel action*)
    chanCode         : uint;  (*channel code  TCP Master, in: 255, out: 255*)
    IPadr            : TIPadr;  (*IP address of SMTP server*)
    port             : uint :=  25;  (*Port of SMTP server*)
    Lines            : usint;  (*number of lines*)
    UtcOff           : int;  (*offset from UTC in minutes*)
    charset          : string [16];  (*charset of Email body ('windows-1250', 'UTF-8',...)*)
    attachementType  : string [32];  (*user defined MINE type of attachement. If not specified, 'application/octet-stream' is used (other possible values are 'image/jpeg', 'image/png', 'text/plain; charset=windows-1250',...)*)
    genMessageID     : bool;  (*generate unique Message-ID*)
  END_VAR
  VAR_IN_OUT
    Sender           : string [80];  (*sender address*)
    SendName         : string [80];  (*sender name*)
    Rcpt             : string [80];  (*recipient address*)
    Subject          : string [80];  (*subject*)
    Text             : string [80];  (*first line of email body*)
    Attach           : string [80];  (*file name of attachement*)
    Username         : string [80];  (*user name for SMTP server*)
    Password         : string [80];  (*password  for SMTP server*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*trueafter email was sent successfully*)
    Busy             : bool;  (*truewhen sending is in progress*)
    Err              : bool;  (*truewhen sending failed*)
    ErrId            : usint;  (*number of error*)
    ReplyCode        : uint;  (*server reply code*)
    State            : TSmtpState;  (*communication state*)
  END_VAR
  VAR CONSTANT
    SMTP_BASE64_LEN_ : udint :=  57;  (*60*)
    SMTP_BASE64_LEN2_ : udint :=  SMTP_BASE64_LEN_*2;  (*120*)
    SMTP_MAXIMUM_FILE_LINE_LENGTH_ : udint :=  SMTP_BASE64_LEN_*3;  (*180;*)
  END_VAR
  VAR
    timeout_cntr     : TON;  (*detekce timeoutu pri komunikaci*)
    cmd              : string [255];
    buff             : ARRAY [0..511] OF usint;
    copy_rcpt        : string [255];
    temp_rcpt        : string [180];
    body_rcpt        : string [80];
    ptrText          : PTR_TO string [80];
    body_lines       : sint;
    Recv_from        : fbRecvTxt;  (*FB pro prijem*)
    Send_to          : fbSendTo;  (*FB pro vysilani*)
    h                : HANDLE;
    TRO              : bool;  (*buffer overflow*)
    lAuth            : bool;  (*byla pozadovana autorizace*)
    mesRec           : bool;
    lSend            : bool;
  END_VAR
END_FUNCTION_BLOCK

TYPE TNtpMessage {HIDDEN} :
  STRUCT
    Flags            : byte :=  2#00_011_011;  (*|  LI1 | LI0 | VN2 | VN1 | VN0 |Mode2|Mode1|Mode0|*)
    Stratum          : usint :=  15;
    Polling          : sint :=  8;
    Precision        : sint :=  -8;
    RootDelay        : udint;
    RootDispersion   : udint;
    RefIdentifier    : udint;
    ReferenceTS      : udint;
    ReferenceTSFrac  : udint;
    OriginateTS      : udint;
    OriginateTSFrac  : udint;
    ReceiveTS        : udint;
    ReceiveTSFrac    : udint;
    TransmitTS       : udint;
    TransmitTSFrac   : udint;
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK fbSntp
(*Gets time offset from remote time server
Names of time servers groups
  
  pool.ntp.org
  europe.pool.ntp.org
  cz.pool.ntp.org*)
  VAR_INPUT
    Get              : bool R_EDGE;  (*Get new time offset from time server*)
    Accept           : bool R_EDGE;  (*Accept new time from server*)
    chanCode         : uint;  (*UNI UDP chanel (60 bytes IN/OUT)*)
    IPadr            : TIPadr;  (*IP address of NTP server*)
    port             : uint :=  123;  (*Port of NTP server*)
    UtcOff           : int;  (*Offset from UTC in minutes*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*Time offset successfully acquired*)
    Busy             : bool;  (*Communication in progress*)
    TimeSet          : bool;  (*New time set to RTC*)
    Err              : bool;  (*Error during communication*)
    ErrId            : usint;  (*Number of error*)
    Offset           : lreal;  (*Acquried offset [s]*)
    Error            : lreal;  (*Maximum error of acquired offset [s]*)
  END_VAR
  VAR
    Recv             : bool;
    SettingTime      : bool;
    Now              : dt;
    NowLocal         : dt;
    NowTeco          : ARRAY [0..6] OF usint;
    NowMili          : uint;
    NtpPacket        : TNtpMessage;
    SendTo           : fbSendTo;
    RecvFrom         : fbRecvFrom;
    Attemps          : udint;
    Success          : udint;
    Delay            : TON;
    ShortTimeout     : TON;
    Timeout          : TON;
    maxSW22          : uint;
  END_VAR
  VAR CONSTANT
    _fbSntp_EMPTY_NTP_MESSAGE_ : TNtpMessage :=  (RootDispersion:= 0);
  END_VAR
END_FUNCTION_BLOCK

TYPE TNsLookUpItem :
  STRUCT
    Request          : bool;
    Set              : bool;
    Done             : bool;
    Err              : bool;
    IP               : TIPadr;
    Name             : string [80];
  END_STRUCT;
END_TYPE

TYPE  TNsLookUpTable : ARRAY [0..15] OF TNsLookUpItem;
END_TYPE

__DECL FUNCTION_BLOCK fbNsLookUpByTable
(*Gets IP address of the domain names in the table*)
  VAR_INPUT
    chanCode         : uint;  (*UNI channel UDP, lport: 0, rport: 53, in: 524, out: 93*)
    DnsIP            : TIPadr;  (*DNS server IP address*)
  END_VAR
  VAR_IN_OUT
    NsLookUpTable    : TNsLookUpTable;  (*Table of domain names*)
  END_VAR
  VAR_OUTPUT
    Busy             : bool;  (*Communication in progress*)
    Err              : bool;  (*Communication error*)
    ErrId            : usint;  (*Error number*)
  END_VAR
  VAR
    i                : uint;
    j                : uint;
    NsLookUp         : fbNsLookUp;
    NsLookUpItem     : TNsLookUpItem;
  END_VAR
END_FUNCTION_BLOCK

TYPE TFtpStoreState : 
  (fss_Init,
   fss_Idle,
   fss_OpenFile,
   fss_IpCom,
   fss_Connect,
   fss_Rx220,
   fss_TxUser,
   fss_RxUser,
   fss_TxPass,
   fss_RxPass,
   fss_TxType,
   fss_RxType,
   fss_TxPasv,
   fss_RxPasv,
   fss_TxStor,
   fss_IpDat,
   fss_WaitForOpen,
   fss_TxData,
   fss_RxComplete,
   fss_TxQuit,
   fss_RxQuit,
   fss_Close,
   fss_Error,
   fss_UnexpectedReply,
   fss_TxCreateDir,
   fss_RxCreateDir,
   fss_ReadDir,
   fss_TxRetr,
   fss_RxData,
   fss_TxSize,
   fss_RxSize 
  );
END_TYPE

VAR_GLOBAL CONSTANT
 FTP_DIR_STACK_ {HIDDEN} : usint :=  4;

END_VAR

TYPE TFtpDirStack {HIDDEN} :
  STRUCT
    hDir             : HANDLE;
    sDir             : string [12];
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK fbStoreToFtp
(*Stores files from memory card to FTP server*)
  VAR_INPUT
    Send             : bool R_EDGE;  (*Sends file/directory to FTP*)
    IPadr            : TIPadr;  (*IP address of FTP server*)
    port             : uint :=  21;  (*Port of FTP server*)
    chanCodeCom      : uint;  (*Channel code*)
    chanCodeDat      : uint;  (*Channel code*)
    append           : bool;  (*If file on server exists data will be appended to that file*)
  END_VAR
  VAR_IN_OUT
    User             : string [80];  (*User name*)
    Pass             : string [80];  (*Password*)
    LocalName        : string [80];  (*Name of file or directory at the memory card*)
    RemotName        : string [80];  (*Name of file or directory at FTP server*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*File was stored to FTP server*)
    Busy             : bool;  (*File is storing to FTP server*)
    Err              : bool;  (*Error occured*)
    ErrId            : usint;  (*Error number*)
    ReplyCode        : uint;  (*Reply code*)
    State            : TFtpStoreState;  (*State of communication*)
    CurrFile         : string [80];  (*Name of currently uploaded file*)
    Progress         : usint;  (*Progress of file uploading in percent*)
  END_VAR
  VAR
    Send_To_Com      : fbSendTo;
    Recv_From_Com    : fbRecvFrom;
    KeepAliveTCP     : fbKeepAliveTCP;
    rea              : TRemoteEthAdr;
    cmdCom           : string [255];
    lRemotName       : string [80];
    lLocalFileInfo   : TFileInfo;
    idPos            : udint;
    lSize            : udint;
    lTrans           : udint;
    dirStack         : ARRAY [0..4] OF TFtpDirStack;
    dirStackLev      : usint;
    i                : usint;
    eErrId           : usint;
    Send_To_Dat      : fbSendTo;
    cmdDat           : ARRAY [0..254] OF usint;
    timeoutCom       : TON;
    data             : udint;
    h                : HANDLE :=  INVALID_HANDLE_VALUE;
    pasvDat          : ARRAY [0..5] OF usint;
    TRO              : bool;
    mesRec           : bool;
    iniDir           : bool;
    endDir           : bool;
    TRO_com          : bool;
    TRO_dat          : bool;
  END_VAR
END_FUNCTION_BLOCK

TYPE  THttpPostData : ARRAY [0..1535] OF usint;
END_TYPE

__DECL FUNCTION_BLOCK fbHttpRequestL
(*Sends POST and GET metods via HTTP*)
  VAR_INPUT
    Post             : bool R_EDGE;  (*Send data via method POST*)
    Get              : bool R_EDGE;  (*Get data via method GET*)
    Cancel           : bool R_EDGE;  (*Cancel pending operation*)
    chanCode         : uint;  (*UNI channel TCP master in: 512, out: 512*)
    IPadr            : TIPadr;  (*IP address of remote server*)
    port             : uint :=  80;  (*Port of remote server*)
    postLen          : uint;  (*Lenght of data to POST*)
    Close            : bool;  (*If set, block don't wait for server to close connection and close it actively after receiving all data*)
  END_VAR
  VAR_IN_OUT
    Action           : string [255];  (*Path to the data on the server (always starts with character '/')*)
    Host             : string [80];  (*Host name*)
    Data             : THttpPostData;  (*First byte of data to POST*)
    RecvData         : THttpBuffer;  (*Data buffer 512 bytes*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*Operation done*)
    Busy             : bool;  (*Operation pending*)
    Err              : bool;  (*Communication error*)
    ErrId            : usint;  (*Error number*)
    DataReady        : bool;  (*New data received*)
    DataLen          : uint;  (*Data length*)
    State            : THttpState;  (*State of communication*)
    Result           : int;  (*HTTP Code*)
    Progress         : sint;  (*Progress of data downloading*)
  END_VAR
  VAR
    ResRecv          : bool;
    LenRecv          : bool;
    HeaderRecv       : bool;
    WasEOL           : bool;
    TimeOutTon       : TON;
    helpstring       : string [255];
    RecvFrom         : fbRecvFrom;
    SendTo           : fbSendTo;
    ContLen          : dint;
    WholeLen         : dint;
    lPostLen         : uint;
    lHost            : string [80];
    BodyLen          : uint;
    sOff             : uint;
    rLen             : uint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbHttpRequestL2
(*Sends POST and GET metods via HTTP with option to set content type (Content-Type)*)
  VAR_INPUT
    Post             : bool R_EDGE;  (*Send data via method POST*)
    Get              : bool R_EDGE;  (*Get data via method GET*)
    Cancel           : bool R_EDGE;  (*Cancel pending operation*)
    chanCode         : uint;  (*UNI channel TCP master in: 512, out: 512*)
    IPadr            : TIPadr;  (*IP address of remote server*)
    port             : uint :=  80;  (*Port of remote server*)
    postLen          : uint;  (*Lenght of data to POST*)
    Close            : bool;  (*If set, block don't wait for server to close connection and close it actively after receiving all data*)
  END_VAR
  VAR_IN_OUT
    Action           : string [255];  (*Path to the data on the server (always starts with character '/')*)
    Host             : string [80];  (*Host name*)
    Data             : THttpPostData;  (*First byte of data to POST*)
    ContentType      : string [80];  (*Content-Type*)
    RecvData         : THttpBuffer;  (*Data buffer 512 bytes*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*Operation done*)
    Busy             : bool;  (*Operation pending*)
    Err              : bool;  (*Communication error*)
    ErrId            : usint;  (*Error number*)
    DataReady        : bool;  (*New data received*)
    DataLen          : uint;  (*Data length*)
    State            : THttpState;  (*State of communication*)
    Result           : int;  (*HTTP Code*)
    Progress         : sint;  (*Progress of data downloading*)
  END_VAR
  VAR
    ResRecv          : bool;
    LenRecv          : bool;
    HeaderRecv       : bool;
    WasEOL           : bool;
    TimeOutTon       : TON;
    helpstring       : string [255];
    RecvFrom         : fbRecvFrom;
    SendTo           : fbSendTo;
    ContLen          : dint;
    WholeLen         : dint;
    lPostLen         : uint;
    lHost            : string [80];
    BodyLen          : uint;
    sOff             : uint;
    rLen             : uint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbSplitUrlAddress
(*Function block fbSplitUrlAddress splits specified URL address to items required by blocks fbHttpRequest, fbHttpRequestL and fbHttpRequestL2.
  Input of the block is a variable, that carries a URL as it appears in the web browser, passed through urlAddress.*)
  VAR_INPUT
    split            : bool R_EDGE;  (*Split URL address*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*URL address splitted and IP address successfully obtained*)
    busy             : bool;  (*Operation pending*)
    err              : bool;  (*Error occured*)
    errId            : usint;  (*Error number*)
  END_VAR
  VAR_IN_OUT
    urlAddress       : string [255];  (*URL as it appears in a web browser*)
    host             : string [80];  (*Host name*)
    action           : string [255];  (*Path to the data on the server (always starts with character '/')*)
    ipAdr            : TIPadr;  (*IP address of remote server*)
    port             : uint;  (*Port of remote server*)
  END_VAR
  VAR
    NsLookUp         : fbNsLookUpEx;
  END_VAR
  VAR CONSTANT
    HTTP_IP_NULL     : TIPadr :=  [0,0,0,0];
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbRetriveFromFtp
(*Retrive file from FTP server and saves it to memory card*)
  VAR_INPUT
    Retrieve         : bool R_EDGE;  (*Retrieves file from FTP*)
    IPadr            : TIPadr;  (*IP address of FTP server*)
    port             : uint :=  21;  (*Port of FTP server*)
    chanCodeCom      : uint;  (*Channel code*)
    chanCodeDat      : uint;  (*Channel code*)
  END_VAR
  VAR_IN_OUT
    User             : string [80];  (*User name*)
    Pass             : string [80];  (*Password*)
    LocalName        : string [80];  (*Name of file at the memory card*)
    RemotName        : string [80];  (*Name of file at FTP server*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*File was stored to memory card*)
    Busy             : bool;  (*File is being stored to memory card*)
    Err              : bool;  (*Error occured*)
    ErrId            : usint;  (*Error number*)
    ReplyCode        : uint;  (*Reply code*)
    State            : TFtpStoreState;  (*State of communication*)
    Progress         : usint;  (*Progress of file uploading in percent*)
  END_VAR
  VAR
    Send_To_Com      : fbSendTo;
    Recv_From_Com    : fbRecvTxt;  (*fbRecvFrom;*)
    KeepAliveTCP     : fbKeepAliveTCP;
    rea              : TRemoteEthAdr;
    cmdCom           : string [255];
    lRemotName       : string [80];
    lLocalFileInfo   : TFileInfo;
    idPos            : udint;
    lSize            : udint;
    lTrans           : udint;
    i                : usint;
    eErrId           : usint;
    Recv_From_Dat    : fbRecvFrom;
    WTFS             : WriteToFileSeq;
    cmdBuffer        : ARRAY [0..254] OF usint;
    cmdDat           : ARRAY [0..254] OF usint;
    timeoutCom       : TON;
    data             : udint;
    h                : HANDLE :=  INVALID_HANDLE_VALUE;
    pasvDat          : ARRAY [0..5] OF usint;
    TRO              : bool;
    mesRec           : bool;
    TRO_com          : bool;
    TRO_dat          : bool;
  END_VAR
END_FUNCTION_BLOCK

TYPE T_PING_INFO :
  STRUCT
    result           : dint;  (*result 0=busy, 1=done without errors, -1=error*)
    hostIP           : TIPadr;  (*host IP*)
    responseTime     : time;  (*response time*)
    pingNumber       : udint;  (*ping number*)
    dataLen          : udint;  (*length of data*)
    ttl              : usint;  (*response TTL*)
    errMsg           : string [80];  (*error message*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK fbPingIP
(*Check the connection between the PLC and the network interface with given IP address*)
  VAR_INPUT
    rqPing           : bool R_EDGE;  (*Ping request*)
    hostIP           : TIPadr;  (*Host IP*)
    ttl              : usint;  (*Time to live TTL*)
    timeLimit        : time;  (*Time limit for reply*)
    dataLen          : uint;  (*Length of data*)
  END_VAR
  VAR_IN_OUT
    pingInfo         : T_PING_INFO;  (*Ping information*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*Operation successfully completed*)
    busy             : bool;  (*Operation pending*)
    err              : bool;  (*Error occured*)
  END_VAR
  VAR
    timeout          : TON;
    waitArp          : bool;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbPing
(*Check the connection between the PLC and the host of given name*)
  VAR_INPUT
    rqPing           : bool R_EDGE;  (*Ping request*)
    hostName         : string [80];  (*Host name*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*Operation successfully completed*)
    busy             : bool;  (*Operation pending*)
    err              : bool;  (*Error occured*)
    pingInfo         : T_PING_INFO;  (*Ping information*)
  END_VAR
  VAR
    rqSplit          : bool;
    SplitUrlAdr      : fbSplitUrlAddress;
    PingIP           : fbPingIP;
    host             : string [80];  (*Jméno hostitele*)
    action           : string [80];  (*Poadovaná stránka napøíklad "/index.xml"*)
    ipAdr            : TIPadr;  (*IP adresa vzdáleneho serveru*)
    port             : uint;  (*Èíslo portu vzdáleného serveru*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbSmtpDbx
(*Sends email messages via SMTP*)
  VAR_INPUT
    Send             : bool R_EDGE;  (*starts sending of email*)
    Auth             : bool;  (*authetification requiered?*)
    Cancel           : bool R_EDGE;  (*cancel action*)
    chanCode         : uint;  (*channel code  TCP Master, in: 255, out: 255*)
    IPadr            : TIPadr;  (*IP address of SMTP server*)
    port             : uint :=  25;  (*Port of SMTP server*)
    Lines            : usint;  (*number of lines*)
    UtcOff           : int;  (*offset from UTC in minutes*)
    charset          : string [16];  (*charset of Email body ('windows-1250', 'UTF-8',...)*)
    attachementType  : string [32];  (*user defined MINE type of attachement. If not specified, 'application/octet-stream' is used (other possible values are 'image/jpeg', 'image/png', 'text/plain; charset=windows-1250',...)*)
    genMessageID     : bool;  (*generate unique Message-ID*)
    Attachement      : bool;  (*send with attachemnt*)
    AttachAdr        : udint;  (*address of attachemnt in databox*)
    AttachLen        : udint;  (*length of attachement in databox*)
  END_VAR
  VAR_IN_OUT
    Sender           : string [80];  (*sender address*)
    SendName         : string [80];  (*sender name*)
    Rcpt             : string [80];  (*recipient address*)
    Subject          : string [80];  (*subject*)
    Text             : string [80];  (*first line of email body*)
    Attach           : string [80];  (*file name of attachement*)
    Username         : string [80];  (*user name for SMTP server*)
    Password         : string [80];  (*password  for SMTP server*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*trueafter email was sent successfully*)
    Busy             : bool;  (*truewhen sending is in progress*)
    Err              : bool;  (*truewhen sending failed*)
    ErrId            : usint;  (*number of error*)
    ReplyCode        : uint;  (*server reply code*)
    State            : TSmtpState;  (*communication state*)
  END_VAR
  VAR CONSTANT
    SMTP_BASE64_LEN_ : udint :=  57;  (*60*)
    SMTP_BASE64_LEN2_ : udint :=  SMTP_BASE64_LEN_*2;  (*120*)
    SMTP_MAXIMUM_FILE_LINE_LENGTH_ : udint :=  SMTP_BASE64_LEN_*3;  (*180;*)
  END_VAR
  VAR
    timeout_cntr     : TON;  (*detekce timeoutu pri komunikaci*)
    cmd              : string [255];
    buff             : ARRAY [0..511] OF usint;
    copy_rcpt        : string [255];
    temp_rcpt        : string [180];
    body_rcpt        : string [80];
    ptrText          : PTR_TO string [80];
    body_lines       : sint;
    Recv_from        : fbRecvTxt;  (*FB pro prijem*)
    Send_to          : fbSendTo;  (*FB pro vysilani*)
    lAttachLen       : udint;
    oAttachLen       : udint;
    TRO              : bool;  (*buffer overflow*)
    lAuth            : bool;  (*byla pozadovana autorizace*)
    mesRec           : bool;
    lSend            : bool;
  END_VAR
END_FUNCTION_BLOCK



{LIBFILE="LOCALLIB\JSONLIBEX_V17_20190625.MLB"}
(* Mosaic IDE library *)
(* File name : D:\MosaicLib\JsonLibEx_V17_20190625.mlb *)
(* Library : JsonLibEx 1.7 *)
(* Author : Teco a.s. *)
(* Copyright : (c) 2012 - 2019 Teco a.s. *)
(* IEC compiler version : 4.2.4.0 *)
(* Assembler version : 4.3.00 *)

//{Knihovna : JsonLibEx 1.7  }
(* History: *)
(*
v1.0 2012-11-16 Nem First edition
v1.1 2014-11-28 Ciz Added blocks fbJsonParserEx(),
                    fbJsonFileParser() and fbJsonPageParser()
v1.2 2015-07-08 Nem Connection with server is closed 
                    when parsing error occurred
v1.3 2015-10-26 Nem fbJsonPageParser() uses block
                    fbSplitUrlAddress() from InternetLib_v34 
v1.4 2017-10-26 Nem in fbJsonPageParser() was changed size 
                    of internal variable Action to STRING[255] 
                    - because of fbSplitUrlAddress() from InternetLib_v42
v1.4 2018-11-27 Nem Tested with Foxtrot CP-2xxx v1.1.011
v1.5 2019-01-07 Nem Better start of parsing in fbJsonPageParser
v1.6 2019-04-25 Nem new functions GetLastJsonError(),
                    VarApiToJsonBuf(), JsonBufToVarApi(),
                    VarApiToJsonFile() ans JsonFileToVarApi()
                    (for CP-2xxx only)
v1.7 2019-06-25 Nem new function block fbGetJsonAndSetVar()
*)

(*----------------------------------------------------------------------------*)
// {LIBRARY="LOCALLIB\ENCRYPTLIB_V12_20160923.MLB"}

__DECL FUNCTION GetLastJsonError : string
END_FUNCTION

__DECL FUNCTION VarApiToJsonBuf : udint
(*Writes JSON with variables description into buffer in PLC memory. Returns number of written characters.*)
  VAR_IN_OUT
    varNames         : string [80];  (*names of variables seoarated by &*)
    buffer           : usint;  (*name of buffer for json*)
  END_VAR
  VAR_INPUT
    maxBufLen        : udint;  (*buffer size*)
  END_VAR
END_FUNCTION

__DECL FUNCTION JsonBufToVarApi : udint
(*Sets values of variables according JSON buffer. Returns number of processed characters.*)
  VAR_IN_OUT
    buffer           : usint;  (*name of json buffer*)
  END_VAR
  VAR_INPUT
    strict           : bool;  (*TRUE means strictly mode*)
  END_VAR
END_FUNCTION

__DECL FUNCTION VarApiToJsonFile : udint
(*Writes JSON with variables description into file in PLC. Returns number of written characters.*)
  VAR_IN_OUT
    varNames         : string [80];  (*names of variables seoarated by &*)
    fileName         : string [80];  (*file name (including path)*)
  END_VAR
  VAR_INPUT
    formatted        : bool;  (*TRUE means formatted json, FALSE is unformatted json*)
  END_VAR
END_FUNCTION

__DECL FUNCTION JsonFileToVarApi : udint
(*Sets values of variables according JSON file. Returns number of processed characters.*)
  VAR_IN_OUT
    fileName         : string [80];  (*file name (including path)*)
  END_VAR
  VAR_INPUT
    strict           : bool;  (*TRUE means strictly mode*)
  END_VAR
END_FUNCTION

VAR_GLOBAL CONSTANT
 JSON_MAX_STACK_LEVEL : sint :=  9;  (*max level of JSON stack*)

END_VAR

TYPE TJsonItem :
  STRUCT
    name             : string [255];  (*full name of item*)
    value            : string [255];  (*value of item*)
  END_STRUCT;
END_TYPE

TYPE TJsonParserStat : 
  (json_none,
   json_object_name,
   json_object_value 
  );
END_TYPE

TYPE TJsonStackItem :
  STRUCT
    stat             : TJsonParserStat;  (*state of parsing*)
    isArray          : bool;  (*array flag*)
    arrayIndex       : uint;  (*index of array*)
    name             : string [31];  (*name of item*)
  END_STRUCT;
END_TYPE

TYPE TJsonStack :
  STRUCT
    done {ALIGNED}   : bool;  (*next item is avalable*)
    eod {ALIGNED}    : bool;  (*end of document*)
    error            : usint;  (*error code*)
    errTxt           : string [32];  (*error description*)
    maxLevel {HIDDEN} : sint;  (*max stack level*)
    level            : sint;  (*stack level*)
    item             : ARRAY [0..9] OF TJsonStackItem;
  END_STRUCT;
END_TYPE

__DECL FUNCTION JSON_MemcpyPtr {HIDDEN} : udint
(*Function memcpy copies a block of n bytes from source to dest.
  Function returns number of copied bytes.*)
  VAR_INPUT
    source           : PTR_TO usint;  (*source*)
    dest             : PTR_TO usint;  (*destination*)
    length           : udint;  (*number of bytes*)
  END_VAR
END_FUNCTION

__DECL FUNCTION_BLOCK fbJsonParser
(*Converts one item from JSON document into a TJsonItem structure*)
  VAR_INPUT
    start            : bool;  (*TRUE means start of parsing at the begin of JSON document, FALSE means continue*)
    shrink           : bool;  (**)
    size             : udint;  (**)
  END_VAR
  VAR_IN_OUT
    sourceJSON       : usint;  (*begin of JSON document*)
    jsonItem         : TJsonItem;  (*JSON parser output*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*new item is ready*)
    eod              : bool;  (*end of JSON document*)
    error            : usint;  (*error code*)
    restLen          : uint;  (*number of bytes remaining to be processed*)
    jsonStack        : TJsonStack;  (*stack for parsing*)
  END_VAR
  VAR
    i                : sint;
    index            : udint;
    src              : PTR_TO usint;
    end              : PTR_TO usint;
    char             : usint;
    break            : bool;
  END_VAR
END_FUNCTION_BLOCK

TYPE TJsonInfo :
  STRUCT
    item             : TJsonItem;  (*JSON parser output*)
    stack            : TJsonStack;  (*stack for parsing*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK fbJsonParserEx
(*Converts one item from JSON document into a TJsonInfo structure*)
  VAR_INPUT
    start            : bool;  (*TRUE means start of parsing at the begin of JSON document, FALSE means continue*)
    shrink           : bool;  (*value = TRUE, removed from the buffer processed portion of the file. Unprocessed remnants of the buffer moves to the beginning the buffer*)
    size             : udint;  (*buffer size with the JSON document*)
  END_VAR
  VAR_IN_OUT
    sourceJSON       : usint;  (*begin of JSON document*)
    JsonInfo         : TJsonInfo;  (*JSON parser output*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*new item is ready*)
    eod              : bool;  (*end of JSON document*)
    error            : usint;  (*error code*)
    restLen          : uint;  (*number of bytes remaining to be processed*)
  END_VAR
  VAR
    i                : sint;
    index            : udint;
    src              : PTR_TO usint;
    end              : PTR_TO usint;
    char             : usint;
    break            : bool;
    tmp              : udint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbJsonFileParser
(*Parsing of JSON document from file. Information about JSON element is saved into TJsonInfo structure.*)
  VAR CONSTANT
    JSON_BUMPER      : uint :=  256;  (*bumper of JSON buffer*)
    JSON_BUFFER_SIZE : uint :=  768;  (*size of JSON buffer*)
  END_VAR
  VAR_INPUT
    exec             : bool;  (*request for parsing*)
  END_VAR
  VAR_IN_OUT
    fileName         : string [80];  (*mame of JSON file*)
    JsonInfo         : TJsonInfo;  (*result of parsing*)
  END_VAR
  VAR_OUTPUT
    start            : bool;  (*initialization flag*)
    done             : bool;  (*new item is ready in JSONItem*)
    busy             : bool;  (*block is busy*)
    eof              : bool;  (*end of file*)
    break            : bool;  (*buffer processed, continue next cycle*)
    err              : bool;  (*error flag*)
    errTxt           : string [80];  (*error description*)
    fileSize         : udint;  (*size of file*)
    processed        : udint;  (*processed*)
  END_VAR
  VAR
    rqInit           : bool;
    rqFile           : bool;
    rqParse          : bool;
    rqStart          : bool;
    trgExecOn        : R_TRIG;
    ReadFile         : ReadFromFile;
    JsonParser       : fbJsonParserEx;
    JsonBuffer       : ARRAY [0..768] OF usint;
    sumaLen          : udint;  (*kolik nacteno ze souboru*)
    actLen           : udint;  (*aktualni velikost JSON bufferu*)
    restLen          : uint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbJsonPageParser
(*Parsing of JSON document file from web site. Information about json element is saved into TjsonInfo structure.*)
  VAR CONSTANT
    JSON_BUMPER      : uint :=  256;  (*bumper of json buffer*)
    JSON_BUFFER_SIZE : uint :=  768;  (*size of json buffer*)
  END_VAR
  VAR_INPUT
    exec             : bool;  (*request for parsing*)
    chanCode         : uint;  (*channel code (ETH1_uni0, ETH1_uni1,...)*)
  END_VAR
  VAR_IN_OUT
    pageName         : string [255];  (*mame of web page with json file*)
    JsonInfo         : TJsonInfo;  (*result of parsing*)
  END_VAR
  VAR_OUTPUT
    start            : bool;  (*initialization flag*)
    done             : bool;  (*new item is ready in jsonItem*)
    busy             : bool;  (*block is busy*)
    eof              : bool;  (*end of file*)
    break            : bool;  (*buffer processed, continue next cycle*)
    err              : bool;  (*error flag*)
    errTxt           : string [80];  (*error description*)
    fileSize         : udint;  (*size of file*)
    processed        : udint;  (*processed*)
  END_VAR
  VAR
    rqShrink         : bool;
    rqFile           : bool;
    rqParse          : bool;
    rqStart          : bool;
    trgExecOn        : R_TRIG;
    JsonParser       : fbJsonParserEx;
    JsonBuffer       : ARRAY [0..768] OF usint;
    sumaLen          : udint;  (*kolik nacteno ze souboru*)
    actLen           : udint;  (*aktualni velikost json bufferu*)
    restLen          : uint;
    pos              : int;
    HttpIP           : TIPadr;
    HttpPort         : uint;
    HttpName         : string [80];
    Action           : string [255];
    Empty            : string [1];
    dnsRequest       : bool;
    SplitUrlAddress  : fbSplitUrlAddress;
    HttpRequest      : fbHttpRequest;
  END_VAR
  VAR CONSTANT
    HTTP_IP_NULL     : TIPadr :=  [0,0,0,0];
  END_VAR
END_FUNCTION_BLOCK

TYPE JSONLIB_T_VAR_DESC {HIDDEN} :
  STRUCT
    addr             : udint;
    size             : udint;
    typ              : usint;
    isArray          : bool;
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK fbGetJsonAndSetVar
(*Reading of JSON file from web site and setting PLC variables according JSON.*)
  VAR_INPUT
    exec             : bool R_EDGE;  (*reading of JSON starts on rising edge of exec*)
    logSizeKB        : usint;  (*size of log file, 0 = no log*)
    pageUrl          : string [255];  (*url address of JSON*)
    varName          : string [80];  (*name of variable which value is set according JSON*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*all is done ok*)
    busy             : bool;  (*block is busy*)
    err              : bool;  (*error flag*)
    errTxt           : string [80];  (*error description*)
    numVar           : uint;  (*number of set variables*)
  END_VAR
  VAR
    JsonParser       : fbJsonPageParser;  (*FB pro parsovani odpovedi na API dotaz*)
    json             : TJsonInfo;  (*struktura pro vysledky parsovani*)
    rqGet            : bool;  (*vyslat GET*)
    parseEnable      : bool;  (*pomocna pro parsovani*)
    chanHandle       : uint;  (*handle kanalu*)
    varDesc          : JSONLIB_T_VAR_DESC;
  END_VAR
END_FUNCTION_BLOCK



{LIBFILE="LOCALLIB\CONVERTLIB_V21_20170222.MLB"}
(* Mosaic IDE library *)
(* File name : D:\TecoUserLibs\ConvertLib_V21_20170222.mlb *)
(* Library : ConvertLib 2.1 *)
(* Author : Teco a.s. *)
(* Copyright : (c) 2017 Teco a.s. *)
(* IEC compiler version : 3.12.10.2 *)
(* Assembler version : 4.3.00 *)

//{Knihovna : ConvertLib 2.1  }
(* History: *)
(*
v1.0 2010-11-17 Nem First edition
v1.1 2011-07-22 Nem Functions STRING_TO_UPPER() a STRING_TO_LOWER()
                    returns length of converted string
v1.2 2012-02-13 Nem New function ISO8859_2_TO_CP1250()
v1.3 2012-04-27 Nem New function ReplaceChar()
v1.4 2012-09-03 Nem New functions DT_TO_DT_RFC822() a DT_RFC822_TO_DT()
v1.5 2013-06-02 Nem Fix bug for june and july in DT_RFC822_TO_DT()
v1.6 2013-09-23 Byd New functions WindDirectionT115Deg, WindDirectionT115StringCs, 
                    WindDirectionT115StringEn and function blocks 
                    fbMeterCounter, fbMeterPulse
v1.7 2013-10-14 Byd DT_RFC822_TO_DT fixed for month October
v1.8 2014-10-31 Nem New functions STRING_TO_INT_EX, STRING_TO_REAL_EX, 
                    STRING_TO_LREAL_EX
v1.9 2016-01-18 Nem New functions DT_TO_DT_HTTP() and UTF8_TO_CP125x()
                    DT_RFC822_TO_DT fixed for PM
v2.0 2017-01-19 Byd Fixed block fbMeterCounter for MaxPeriod less than 1000ms
v2.1 22.02.2017 Byd Added functions CP1250_TO_UTF8, CP1251_TO_UTF8, CP1252_TO_UTF8, CP1253_TO_UTF8, CP1254_TO_UTF8, CP1255_TO_UTF8
*)

(*----------------------------------------------------------------------------*)
// {LIBRARY="LOCALLIB\STDLIB_V21_20140514.MLB"}

__DECL FUNCTION STRING_TO_UPPER : uint
(*Convert lowercase letters to uppercase.Returns length of string.*)
  VAR_IN_OUT
    input            : string [80];
  END_VAR
END_FUNCTION

__DECL FUNCTION STRING_TO_LOWER : uint
(*Convert uppercase letters to lowercase. Returns length of string.*)
  VAR_IN_OUT
    input            : string [80];
  END_VAR
END_FUNCTION

__DECL FUNCTION STRING_HEX_TO_UDINT : udint
(*Convert STRING (HEX NUMBER ONLY) TO UDINT
  
  Permissible characters : '0123456789abcdefABCDEF'*)
  VAR_INPUT
    input            : string [80];
  END_VAR
  VAR
    tmp              : string [8] :=  '00000000';
  END_VAR
END_FUNCTION

__DECL FUNCTION DEG_TO_RAD : lreal
(*Convert degrees to radians*)
  VAR_INPUT
    angle            : lreal;  (*Angle in degrees*)
  END_VAR
  VAR CONSTANT
    _180_pi          : lreal :=  3.1415926535897931/180.0;
  END_VAR
END_FUNCTION

__DECL FUNCTION RAD_TO_DEG : lreal
(*Convert radians to degrees*)
  VAR_INPUT
    angle            : lreal;  (*Angle in radians*)
  END_VAR
  VAR CONSTANT
    _pi_180          : lreal :=  180.0/3.1415926535897931;
  END_VAR
END_FUNCTION

__DECL FUNCTION DEGREES_TO_ANGLE : lreal
(*Convert angle (degrees, minutes, seconds) to degrees*)
  VAR_INPUT
    degrees          : int;  (*Degrees*)
    minutes          : int;  (*Minutes*)
    seconds          : int;  (*Seconds*)
  END_VAR
END_FUNCTION

__DECL FUNCTION FAHRENHEIT_TO_CELSIUS : real
(*Convert temperature from Fahrenheit to Celsius*)
  VAR_INPUT
    temp             : real;  (*temperature °F*)
  END_VAR
END_FUNCTION

__DECL FUNCTION CELSIUS_TO_FAHRENHEIT : real
(*Convert temperature from Celsius to Fahrenheit*)
  VAR_INPUT
    temp             : real;  (*temperature °C*)
  END_VAR
END_FUNCTION

__DECL FUNCTION ANGLE_TO_DEGREES : bool
(*Convert angle in degrees to degrees/minutes/seconds*)
  VAR_INPUT
    angle            : lreal;  (*angle (degrees)*)
  END_VAR
  VAR_IN_OUT
    degrees          : int;  (*Degrees*)
    minutes          : int;  (*Minutes*)
    seconds          : int;  (*Seconds*)
  END_VAR
END_FUNCTION

__DECL FUNCTION ISO8859_2_TO_CP1250 : udint
(*Convert characters from ISO 8859-2 to CP-1250*)
  VAR_IN_OUT
    src              : usint;  (*first byte of string for conversion*)
  END_VAR
  VAR
    ps               : PTR_TO usint;
    s                : usint;
  END_VAR
  VAR CONSTANT
    ISO8859_2_TO_CP1250_161_190 : ARRAY [161..190] OF usint :=  [
      165, 162, 163, 164, 188, 140,
      167, 168, 138, 170, 141, 143,
      173, 142, 175, 176, 185, 178,
      179, 180, 190, 156, 183, 184,
      154, 186, 157, 159, 189, 158
    ];
  END_VAR
END_FUNCTION

__DECL FUNCTION REPLACE_CHAR : uint
(*Replace all character C1 with character C2
Returns len of STRING*)
  VAR_INPUT
    C1               : byte;  (*ASCII value of character to be replaced*)
    C2               : byte;  (*ASCII value of character used for replacement*)
  END_VAR
  VAR_IN_OUT
    input            : string [255];  (*String where there characters will be replaced*)
  END_VAR
END_FUNCTION

TYPE TypeTecoDateTime {HIDDEN} :
  STRUCT
    year             : usint;  (*rok     (poslední dvì èíslice letopoètu)*)
    month            : usint;  (*mìsíc   (1 .. 12)*)
    day              : usint;  (*den     (1 .. 28/29/30/31)*)
    hour             : usint;  (*hodina  (0 .. 23)*)
    min              : usint;  (*minuta  (0 .. 59)*)
    sec              : usint;  (*sekunda (0 .. 59)*)
    dayOfWeek        : usint;  (*den v týdnu (1 = pondìlí, 7 = nedìle)*)
    milisec          : uint;  (*milisekunda*)
  END_STRUCT;
END_TYPE

VAR_GLOBAL CONSTANT
 MonthsNamesRFC822 : ARRAY [1..12] OF string [3] :=   ['Jan', 'Feb', 'Mar', 'Apr',
                                                       'May', 'Jun', 'Jul', 'Aug',
                                                       'Sep', 'Oct', 'Nov', 'Dec'];

END_VAR

__DECL FUNCTION DT_TO_DT_RFC822 : string [26]
(*returns date and time according to RFC822

  date and time according to RFC822

  date            =       day month year
  year            =       4 DIGIT
  month           =       month-name
  month-name      =       "Jan" / "Feb" / "Mar" / "Apr" /
                          "May" / "Jun" / "Jul" / "Aug" /
                          "Sep" / "Oct" / "Nov" / "Dec"
  day             =       1-2 DIGIT
  time            =       time-of-day zone
  time-of-day     =       hour ":" minute ":" second
  hour            =       2 DIGIT
  minute          =       2 DIGIT
  second          =       2 DIGIT
  zone            =       (( "+" / "-" ) 4 DIGIT)*)
  VAR_INPUT
    dateTime         : dt;  (*Date and time in IEC DT format*)
    UtcOff           : uint;  (*Offset from UTC in minutes*)
  END_VAR
  VAR
    tmpDT            : TypeTecoDateTime;
    tmpTime          : time;
    Format           : string [80];
  END_VAR
END_FUNCTION

__DECL FUNCTION DT_RFC822_TO_DT : dt
(*Conversion date and time according to RFC822 to IEC format DATE_AND_TIME
  Returns standard IEC DT format

  date and time according to RFC822

  date            =       day month year
  year            =       4 DIGIT
  month           =       month-name
  month-name      =       "Jan" / "Feb" / "Mar" / "Apr" /
                          "May" / "Jun" / "Jul" / "Aug" /
                          "Sep" / "Oct" / "Nov" / "Dec"
  day             =       1-2 DIGIT
  time            =       time-of-day zone
  time-of-day     =       hour ":" minute ":" second
  hour            =       2 DIGIT
  minute          =       2 DIGIT
  second          =       2 DIGIT
  zone            =       (( "+" / "-" ) 4 DIGIT)*)
  VAR_INPUT
    dateTime         : string [80];  (*Date and time according to RFC822 (for example Tue, 28 Aug 2012 7:58 am)*)
  END_VAR
  VAR
    tmpDT            : TypeTecoDateTime;
  END_VAR
END_FUNCTION

__DECL FUNCTION WindDirectionT115Deg : real
(*Conversion of resistivity measured of wind indicator T115 to degrees*)
  VAR_INPUT
    R                : real;
  END_VAR
  VAR CONSTANT
    directionDeg     : ARRAY [0..7] OF real :=  [90,135,180,45,225,0,315,270];
  END_VAR
END_FUNCTION

__DECL FUNCTION WindDirectionT115StringCs : string [2]
(*Conversion of measured resistivity of wind indicator T115 to Czech description of direction*)
  VAR_INPUT
    R                : real;  (*Measured resistivity of wind indicator T115*)
  END_VAR
  VAR
    direction        : ARRAY [0..7] OF string [2] :=  ['V','JV','J','SV','JZ','S','SZ','Z'];
  END_VAR
END_FUNCTION

__DECL FUNCTION WindDirectionT115StringEn : string [2]
(*Conversion of measured resistivity of wind indicator T115 to English description of direction*)
  VAR_INPUT
    R                : real;  (*Measured resistivity of wind indicator T115*)
  END_VAR
  VAR
    direction        : ARRAY [0..7] OF string [2] :=  ['E','SE','S','NE','SW','N','NW','W'];
  END_VAR
END_FUNCTION

VAR_GLOBAL CONSTANT
 DayNamesRFC1123 : ARRAY [1..7] OF string [3] :=   [ 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];

END_VAR

__DECL FUNCTION DT_TO_DT_HTTP : string
(*dateTime : DT;            Date and time in IEC DT format*)
  VAR_INPUT
    dateTime         : dt;  (*Date and time in IEC DT format*)
    UtcOff           : uint;  (*Offset from UTC in minutes*)
  END_VAR
  VAR
    gmtDT            : dt;
    tmpDT            : TypeTecoDateTime;
    tmpTime          : time;
  END_VAR
END_FUNCTION

__DECL FUNCTION UTF8_TO_CP125x : uint
(*Convert characters from UTF8 to CP-1250,...,CP1255
        Returns the size of the resulting string*)
  VAR_IN_OUT
    str              : string [255];  (*string to be converted from UTF8 to CP125x*)
  END_VAR
  VAR_INPUT
    codePage         : uint;  (*code page = 1250,...,1255*)
  END_VAR
END_FUNCTION

__DECL FUNCTION_BLOCK fbMeterPulse
(*Counts pulses and estaminates their frequency*)
  VAR_INPUT
    Pulse            : bool R_EDGE;  (*Pulses*)
    Reset            : bool R_EDGE;  (*Reset pulse counter*)
    Freeze           : bool;  (*Stops counting and set frequency to zero*)
    Filter           : time :=  T#2s;  (*Time constant of filter for frequency*)
    MaxPeriod        : time :=  T#1m;  (*Maximum period between pulses*)
    Base             : time :=  T#1s;  (*Base time period for estaminating frequency*)
  END_VAR
  VAR_OUTPUT
    PulseOut         : bool;  (*Copy of input pulses*)
    Overflow         : bool;  (*Pulse counter overflow, set Reset to logical 1*)
    Frequency        : real;  (*Frequency [1/Base]*)
  END_VAR
  VAR_IN_OUT
    Counter          : udint;  (*Pulse counter (have to be RETAIN!)*)
  END_VAR
  VAR
    RawFrequncy      : real;
    LastPulseTim     : time;
    PulseLen         : real;
    LastPulseLen     : real;
    Exp1             : real;
    LastFilterTime   : time;
    OldFilter        : time;
    MaxPulseLen      : real;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbMeterCounter
(*Counts pulses and estaminates their frequency*)
  VAR_INPUT
    Cnt              : uint;  (*Counter of pulses*)
    Reset            : bool R_EDGE;  (*Reset pulse counter*)
    Freeze           : bool;  (*Stops counting and set frequency to zero*)
    Filter           : time :=  T#2s;  (*Time constant of filter for frequency*)
    MaxPeriod        : time :=  T#1m;  (*Maximum period between pulses*)
    Base             : time :=  T#1s;  (*Base time period for estaminating frequency*)
  END_VAR
  VAR_OUTPUT
    Change           : bool;  (*Counter of pulses changed value*)
    Overflow         : bool;  (*Pulse counter overflow, set Reset to logical 1*)
    Frequency        : real;  (*Frequency [1/Base]*)
  END_VAR
  VAR_IN_OUT
    Counter          : dint;  (*Pulse counter (have to be RETAIN!)*)
  END_VAR
  VAR
    RawFrequncy      : real;
    LastPulseTim     : time;
    PulseLen         : real;
    LastPulseLen     : real;
    Exp1             : real;
    LastFilterTime   : time;
    OldFilter        : time;
    MaxPulseLen      : real;
    Dif              : dint;
    MaxDif           : dint;
    CntOld           : uint;
    Init             : bool;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION STRING_TO_REAL_EX : real
(*Conversion STRING to REAL, spaces and comma in number are enabled*)
  VAR_INPUT
    input            : string [80];
  END_VAR
  VAR
    pchar1           : PTR_TO byte;
    pchar2           : PTR_TO byte;
    Buffer           : string [80];
    value1           : byte;  (*pomocna hodnota*)
  END_VAR
END_FUNCTION

__DECL FUNCTION STRING_TO_LREAL_EX : lreal
(*Conversion STRING to LREAL, spaces and comma in number are enabled*)
  VAR_INPUT
    input            : string [80];
  END_VAR
  VAR
    pchar1           : PTR_TO byte;
    pchar2           : PTR_TO byte;
    Buffer           : string [80];
    value1           : byte;  (*pomocna hodnota*)
  END_VAR
END_FUNCTION

__DECL FUNCTION STRING_TO_INT_EX : int
(*Conversion STRING to REAL, spaces in number are enabled*)
  VAR_INPUT
    input            : string [80];
  END_VAR
  VAR
    pchar1           : PTR_TO byte;
    pchar2           : PTR_TO byte;
    Buffer           : string [80];
    value1           : byte;  (*pomocna hodnota*)
  END_VAR
END_FUNCTION

__DECL FUNCTION CP125x_TO_UTF8 {HIDDEN} : udint
  VAR_INPUT
    maxLen           : udint;  (*maximum len of output buffer including end zero*)
    TO_UTF8_128_255  : PTR_TO dword;
  END_VAR
  VAR_IN_OUT
    cp125x           : string [255];
    utf8             : string [255];
  END_VAR
END_FUNCTION

__DECL FUNCTION CP1250_TO_UTF8 : udint
  VAR_INPUT
    maxLen           : udint;  (*maximum len of output buffer including end zero*)
  END_VAR
  VAR
    TO_UTF8_128_255  : ARRAY [128..255] OF dword :=  [
      16#00AC82E2,16#00BDBFEF,16#009A80E2,16#00BDBFEF,16#009E80E2,16#00A680E2,16#00A080E2,16#00A180E2,
      16#00BDBFEF,16#00B080E2,16#0000A0C5,16#00B980E2,16#00009AC5,16#0000A4C5,16#0000BDC5,16#0000B9C5,
      16#00BDBFEF,16#009880E2,16#009980E2,16#009C80E2,16#009D80E2,16#00A280E2,16#009380E2,16#009480E2,
      16#00BDBFEF,16#00A284E2,16#0000A1C5,16#00BA80E2,16#00009BC5,16#0000A5C5,16#0000BEC5,16#0000BAC5,
      16#0000A0C2,16#000087CB,16#000098CB,16#000081C5,16#0000A4C2,16#000084C4,16#0000A6C2,16#0000A7C2,
      16#0000A8C2,16#0000A9C2,16#00009EC5,16#0000ABC2,16#0000ACC2,16#0000ADC2,16#0000AEC2,16#0000BBC5,
      16#0000B0C2,16#0000B1C2,16#00009BCB,16#000082C5,16#0000B4C2,16#0000B5C2,16#0000B6C2,16#0000B7C2,
      16#0000B8C2,16#000085C4,16#00009FC5,16#0000BBC2,16#0000BDC4,16#00009DCB,16#0000BEC4,16#0000BCC5,
      16#000094C5,16#000081C3,16#000082C3,16#000082C4,16#000084C3,16#0000B9C4,16#000086C4,16#000087C3,
      16#00008CC4,16#000089C3,16#000098C4,16#00008BC3,16#00009AC4,16#00008DC3,16#00008EC3,16#00008EC4,
      16#000090C4,16#000083C5,16#000087C5,16#000093C3,16#000094C3,16#000090C5,16#000096C3,16#000097C3,
      16#000098C5,16#0000AEC5,16#00009AC3,16#0000B0C5,16#00009CC3,16#00009DC3,16#0000A2C5,16#00009FC3,
      16#000095C5,16#0000A1C3,16#0000A2C3,16#000083C4,16#0000A4C3,16#0000BAC4,16#000087C4,16#0000A7C3,
      16#00008DC4,16#0000A9C3,16#000099C4,16#0000ABC3,16#00009BC4,16#0000ADC3,16#0000AEC3,16#00008FC4,
      16#000091C4,16#000084C5,16#000088C5,16#0000B3C3,16#0000B4C3,16#000091C5,16#0000B6C3,16#0000B7C3,
      16#000099C5,16#0000AFC5,16#0000BAC3,16#0000B1C5,16#0000BCC3,16#0000BDC3,16#0000A3C5,16#000099CB
    ];
  END_VAR
  VAR_IN_OUT
    cp1250           : string [255];
    utf8             : string [255];
  END_VAR
END_FUNCTION

__DECL FUNCTION CP1251_TO_UTF8 : udint
  VAR_INPUT
    maxLen           : udint;  (*maximum len of output buffer including end zero*)
  END_VAR
  VAR
    TO_UTF8_128_255  : ARRAY [128..255] OF dword :=  [
      16#000082D0,16#000083D0,16#009A80E2,16#000093D1,16#009E80E2,16#00A680E2,16#00A080E2,16#00A180E2,
      16#00AC82E2,16#00B080E2,16#000089D0,16#00B980E2,16#00008AD0,16#00008CD0,16#00008BD0,16#00008FD0,
      16#000092D1,16#009880E2,16#009980E2,16#009C80E2,16#009D80E2,16#00A280E2,16#009380E2,16#009480E2,
      16#00BDBFEF,16#00A284E2,16#000099D1,16#00BA80E2,16#00009AD1,16#00009CD1,16#00009BD1,16#00009FD1,
      16#0000A0C2,16#00008ED0,16#00009ED1,16#000088D0,16#0000A4C2,16#000090D2,16#0000A6C2,16#0000A7C2,
      16#000081D0,16#0000A9C2,16#000084D0,16#0000ABC2,16#0000ACC2,16#0000ADC2,16#0000AEC2,16#000087D0,
      16#0000B0C2,16#0000B1C2,16#000086D0,16#000096D1,16#000091D2,16#0000B5C2,16#0000B6C2,16#0000B7C2,
      16#000091D1,16#009684E2,16#000094D1,16#0000BBC2,16#000098D1,16#000085D0,16#000095D1,16#000097D1,
      16#000090D0,16#000091D0,16#000092D0,16#000093D0,16#000094D0,16#000095D0,16#000096D0,16#000097D0,
      16#000098D0,16#000099D0,16#00009AD0,16#00009BD0,16#00009CD0,16#00009DD0,16#00009ED0,16#00009FD0,
      16#0000A0D0,16#0000A1D0,16#0000A2D0,16#0000A3D0,16#0000A4D0,16#0000A5D0,16#0000A6D0,16#0000A7D0,
      16#0000A8D0,16#0000A9D0,16#0000AAD0,16#0000ABD0,16#0000ACD0,16#0000ADD0,16#0000AED0,16#0000AFD0,
      16#0000B0D0,16#0000B1D0,16#0000B2D0,16#0000B3D0,16#0000B4D0,16#0000B5D0,16#0000B6D0,16#0000B7D0,
      16#0000B8D0,16#0000B9D0,16#0000BAD0,16#0000BBD0,16#0000BCD0,16#0000BDD0,16#0000BED0,16#0000BFD0,
      16#000080D1,16#000081D1,16#000082D1,16#000083D1,16#000084D1,16#000085D1,16#000086D1,16#000087D1,
      16#000088D1,16#000089D1,16#00008AD1,16#00008BD1,16#00008CD1,16#00008DD1,16#00008ED1,16#00008FD1
    ];
  END_VAR
  VAR_IN_OUT
    cp1251           : string [255];
    utf8             : string [255];
  END_VAR
END_FUNCTION

__DECL FUNCTION CP1252_TO_UTF8 : udint
  VAR_INPUT
    maxLen           : udint;  (*maximum len of output buffer including end zero*)
  END_VAR
  VAR
    TO_UTF8_128_255  : ARRAY [128..255] OF dword :=  [
      16#00AC82E2,16#00BDBFEF,16#009A80E2,16#000092C6,16#009E80E2,16#00A680E2,16#00A080E2,16#00A180E2,
      16#000086CB,16#00B080E2,16#0000A0C5,16#00B980E2,16#000092C5,16#00BDBFEF,16#0000BDC5,16#00BDBFEF,
      16#00BDBFEF,16#009880E2,16#009980E2,16#009C80E2,16#009D80E2,16#00A280E2,16#009380E2,16#009480E2,
      16#00009CCB,16#00A284E2,16#0000A1C5,16#00BA80E2,16#000093C5,16#00BDBFEF,16#0000BEC5,16#0000B8C5,
      16#0000A0C2,16#0000A1C2,16#0000A2C2,16#0000A3C2,16#0000A4C2,16#0000A5C2,16#0000A6C2,16#0000A7C2,
      16#0000A8C2,16#0000A9C2,16#0000AAC2,16#0000ABC2,16#0000ACC2,16#0000ADC2,16#0000AEC2,16#0000AFC2,
      16#0000B0C2,16#0000B1C2,16#0000B2C2,16#0000B3C2,16#0000B4C2,16#0000B5C2,16#0000B6C2,16#0000B7C2,
      16#0000B8C2,16#0000B9C2,16#0000BAC2,16#0000BBC2,16#0000BCC2,16#0000BDC2,16#0000BEC2,16#0000BFC2,
      16#000080C3,16#000081C3,16#000082C3,16#000083C3,16#000084C3,16#000085C3,16#000086C3,16#000087C3,
      16#000088C3,16#000089C3,16#00008AC3,16#00008BC3,16#00008CC3,16#00008DC3,16#00008EC3,16#00008FC3,
      16#000090C3,16#000091C3,16#000092C3,16#000093C3,16#000094C3,16#000095C3,16#000096C3,16#000097C3,
      16#000098C3,16#000099C3,16#00009AC3,16#00009BC3,16#00009CC3,16#00009DC3,16#00009EC3,16#00009FC3,
      16#0000A0C3,16#0000A1C3,16#0000A2C3,16#0000A3C3,16#0000A4C3,16#0000A5C3,16#0000A6C3,16#0000A7C3,
      16#0000A8C3,16#0000A9C3,16#0000AAC3,16#0000ABC3,16#0000ACC3,16#0000ADC3,16#0000AEC3,16#0000AFC3,
      16#0000B0C3,16#0000B1C3,16#0000B2C3,16#0000B3C3,16#0000B4C3,16#0000B5C3,16#0000B6C3,16#0000B7C3,
      16#0000B8C3,16#0000B9C3,16#0000BAC3,16#0000BBC3,16#0000BCC3,16#0000BDC3,16#0000BEC3,16#0000BFC3
    ];
  END_VAR
  VAR_IN_OUT
    cp1252           : string [255];
    utf8             : string [255];
  END_VAR
END_FUNCTION

__DECL FUNCTION CP1253_TO_UTF8 : udint
  VAR_INPUT
    maxLen           : udint;  (*maximum len of output buffer including end zero*)
  END_VAR
  VAR
    TO_UTF8_128_255  : ARRAY [128..255] OF dword :=  [
      16#00AC82E2,16#00BDBFEF,16#009A80E2,16#000092C6,16#009E80E2,16#00A680E2,16#00A080E2,16#00A180E2,
      16#00BDBFEF,16#00B080E2,16#00BDBFEF,16#00B980E2,16#00BDBFEF,16#00BDBFEF,16#00BDBFEF,16#00BDBFEF,
      16#00BDBFEF,16#009880E2,16#009980E2,16#009C80E2,16#009D80E2,16#00A280E2,16#009380E2,16#009480E2,
      16#00BDBFEF,16#00A284E2,16#00BDBFEF,16#00BA80E2,16#00BDBFEF,16#00BDBFEF,16#00BDBFEF,16#00BDBFEF,
      16#0000A0C2,16#000085CE,16#000086CE,16#0000A3C2,16#0000A4C2,16#0000A5C2,16#0000A6C2,16#0000A7C2,
      16#0000A8C2,16#0000A9C2,16#00BDBFEF,16#0000ABC2,16#0000ACC2,16#0000ADC2,16#0000AEC2,16#009580E2,
      16#0000B0C2,16#0000B1C2,16#0000B2C2,16#0000B3C2,16#000084CE,16#0000B5C2,16#0000B6C2,16#0000B7C2,
      16#000088CE,16#000089CE,16#00008ACE,16#0000BBC2,16#00008CCE,16#0000BDC2,16#00008ECE,16#00008FCE,
      16#000090CE,16#000091CE,16#000092CE,16#000093CE,16#000094CE,16#000095CE,16#000096CE,16#000097CE,
      16#000098CE,16#000099CE,16#00009ACE,16#00009BCE,16#00009CCE,16#00009DCE,16#00009ECE,16#00009FCE,
      16#0000A0CE,16#0000A1CE,16#00BDBFEF,16#0000A3CE,16#0000A4CE,16#0000A5CE,16#0000A6CE,16#0000A7CE,
      16#0000A8CE,16#0000A9CE,16#0000AACE,16#0000ABCE,16#0000ACCE,16#0000ADCE,16#0000AECE,16#0000AFCE,
      16#0000B0CE,16#0000B1CE,16#0000B2CE,16#0000B3CE,16#0000B4CE,16#0000B5CE,16#0000B6CE,16#0000B7CE,
      16#0000B8CE,16#0000B9CE,16#0000BACE,16#0000BBCE,16#0000BCCE,16#0000BDCE,16#0000BECE,16#0000BFCE,
      16#000080CF,16#000081CF,16#000082CF,16#000083CF,16#000084CF,16#000085CF,16#000086CF,16#000087CF,
      16#000088CF,16#000089CF,16#00008ACF,16#00008BCF,16#00008CCF,16#00008DCF,16#00008ECF,16#00BDBFEF
    ];
  END_VAR
  VAR_IN_OUT
    cp1253           : string [255];
    utf8             : string [255];
  END_VAR
END_FUNCTION

__DECL FUNCTION CP1254_TO_UTF8 : udint
  VAR_INPUT
    maxLen           : udint;  (*maximum len of output buffer including end zero*)
  END_VAR
  VAR
    TO_UTF8_128_255  : ARRAY [128..255] OF dword :=  [
      16#00AC82E2,16#000081C2,16#009A80E2,16#000092C6,16#009E80E2,16#00A680E2,16#00A080E2,16#00A180E2,
      16#000086CB,16#00B080E2,16#0000A0C5,16#00B980E2,16#000092C5,16#00008DC2,16#00008EC2,16#00008FC2,
      16#000090C2,16#009880E2,16#009980E2,16#009C80E2,16#009D80E2,16#00A280E2,16#009380E2,16#009480E2,
      16#00009CCB,16#00A284E2,16#0000A1C5,16#00BA80E2,16#000093C5,16#00009DC2,16#00009EC2,16#0000B8C5,
      16#0000A0C2,16#0000A1C2,16#0000A2C2,16#0000A3C2,16#0000A4C2,16#0000A5C2,16#0000A6C2,16#0000A7C2,
      16#0000A8C2,16#0000A9C2,16#0000AAC2,16#0000ABC2,16#0000ACC2,16#0000ADC2,16#0000AEC2,16#0000AFC2,
      16#0000B0C2,16#0000B1C2,16#0000B2C2,16#0000B3C2,16#0000B4C2,16#0000B5C2,16#0000B6C2,16#0000B7C2,
      16#0000B8C2,16#0000B9C2,16#0000BAC2,16#0000BBC2,16#0000BCC2,16#0000BDC2,16#0000BEC2,16#0000BFC2,
      16#000080C3,16#000081C3,16#000082C3,16#000083C3,16#000084C3,16#000085C3,16#000086C3,16#000087C3,
      16#000088C3,16#000089C3,16#00008AC3,16#00008BC3,16#00008CC3,16#00008DC3,16#00008EC3,16#00008FC3,
      16#00009EC4,16#000091C3,16#000092C3,16#000093C3,16#000094C3,16#000095C3,16#000096C3,16#000097C3,
      16#000098C3,16#000099C3,16#00009AC3,16#00009BC3,16#00009CC3,16#0000B0C4,16#00009EC5,16#00009FC3,
      16#0000A0C3,16#0000A1C3,16#0000A2C3,16#0000A3C3,16#0000A4C3,16#0000A5C3,16#0000A6C3,16#0000A7C3,
      16#0000A8C3,16#0000A9C3,16#0000AAC3,16#0000ABC3,16#0000ACC3,16#0000ADC3,16#0000AEC3,16#0000AFC3,
      16#00009FC4,16#0000B1C3,16#0000B2C3,16#0000B3C3,16#0000B4C3,16#0000B5C3,16#0000B6C3,16#0000B7C3,
      16#0000B8C3,16#0000B9C3,16#0000BAC3,16#0000BBC3,16#0000BCC3,16#0000B1C4,16#00009FC5,16#0000BFC3
    ];
  END_VAR
  VAR_IN_OUT
    cp1254           : string [255];
    utf8             : string [255];
  END_VAR
END_FUNCTION

__DECL FUNCTION CP1255_TO_UTF8 : udint
  VAR_INPUT
    maxLen           : udint;  (*maximum len of output buffer including end zero*)
  END_VAR
  VAR
    TO_UTF8_128_255  : ARRAY [128..255] OF dword :=  [
      16#00AC82E2,16#00BDBFEF,16#009A80E2,16#000092C6,16#009E80E2,16#00A680E2,16#00A080E2,16#00A180E2,
      16#000086CB,16#00B080E2,16#00BDBFEF,16#00B980E2,16#00BDBFEF,16#00BDBFEF,16#00BDBFEF,16#00BDBFEF,
      16#00BDBFEF,16#009880E2,16#009980E2,16#009C80E2,16#009D80E2,16#00A280E2,16#009380E2,16#009480E2,
      16#00009CCB,16#00A284E2,16#00BDBFEF,16#00BA80E2,16#00BDBFEF,16#00BDBFEF,16#00BDBFEF,16#00BDBFEF,
      16#0000A0C2,16#0000A1C2,16#0000A2C2,16#0000A3C2,16#00AA82E2,16#0000A5C2,16#0000A6C2,16#0000A7C2,
      16#0000A8C2,16#0000A9C2,16#000097C3,16#0000ABC2,16#0000ACC2,16#0000ADC2,16#0000AEC2,16#0000AFC2,
      16#0000B0C2,16#0000B1C2,16#0000B2C2,16#0000B3C2,16#0000B4C2,16#0000B5C2,16#0000B6C2,16#0000B7C2,
      16#0000B8C2,16#0000B9C2,16#0000B7C3,16#0000BBC2,16#0000BCC2,16#0000BDC2,16#0000BEC2,16#0000BFC2,
      16#0000B0D6,16#0000B1D6,16#0000B2D6,16#0000B3D6,16#0000B4D6,16#0000B5D6,16#0000B6D6,16#0000B7D6,
      16#0000B8D6,16#0000B9D6,16#00BDBFEF,16#0000BBD6,16#0000BCD6,16#0000BDD6,16#0000BED6,16#0000BFD6,
      16#000080D7,16#000081D7,16#000082D7,16#000083D7,16#0000B0D7,16#0000B1D7,16#0000B2D7,16#0000B3D7,
      16#0000B4D7,16#00BDBFEF,16#00BDBFEF,16#00BDBFEF,16#00BDBFEF,16#00BDBFEF,16#00BDBFEF,16#00BDBFEF,
      16#000090D7,16#000091D7,16#000092D7,16#000093D7,16#000094D7,16#000095D7,16#000096D7,16#000097D7,
      16#000098D7,16#000099D7,16#00009AD7,16#00009BD7,16#00009CD7,16#00009DD7,16#00009ED7,16#00009FD7,
      16#0000A0D7,16#0000A1D7,16#0000A2D7,16#0000A3D7,16#0000A4D7,16#0000A5D7,16#0000A6D7,16#0000A7D7,
      16#0000A8D7,16#0000A9D7,16#0000AAD7,16#00BDBFEF,16#00BDBFEF,16#008E80E2,16#008F80E2,16#00BDBFEF
    ];
  END_VAR
  VAR_IN_OUT
    cp1255           : string [255];
    utf8             : string [255];
  END_VAR
END_FUNCTION



{LIBFILE="LOCALLIB\ICONTROLLIB_V22_20181210.MLB"}
(* Mosaic IDE library *)
(* File name : C:\TecoLib\iControlLib_V22_20181210.mlb *)
(* Library : iControlLib 2.2 *)
(* Author : Teco a.s. *)
(* Copyright : (c)2018 Teco a.s. *)
(* IEC compiler version : 4.2.2.2 *)
(* Assembler version : 4.3.00 *)

//{Knihovna : iControlLib 2.2  }
(* History: *)
(*
v1.0 2014-12-16 nem  first version for tests
v1.1 2015-02-09 nem  corrected block fb_iDimmerRGB
                     blocks fb_iDimmer, fb_iDimmerLED and 
                     fb_iDimmerRGB have the same behavior
v1.2 2015-05-13 nem  corrected fb_iJalousie for better
                     cooperation with fb_JalAlarm +
                     default value of pauseTime changed
                     to 1 sec
                     corrected fb_TimeAction for long cycle time
v1.3 2015-08-20 nem  corrected fb_iDimmer - ramp counting
v1.4 2015-11-25 nem  corrected fb_iDimmerRGB - color setting from iFoxtrot app
v1.5 2015-12-14 nem  added blocks fb_iScene4 and fb_iScene8
                     for control of scenes
v1.6 2016-02-03 nem  added blocks fb_iWebConf, fb_iWebCamera
                     and fb_iSocket 
v1.7 2016-07-26 nem  added block fb_iDisplay
v1.8 2016-08-26 nem  added blocks fb_iDisplay_OnOff, fb_iDisplay_Val,
                     fb_iDisplay_Edit, deleted block fb_iDisplay
v1.9 not public nem  block fb_iTherm replaced by block fb_iSensorTemp,
                     block fb_iButton1 replaced by block fb_Button1,
                     deleted blocks fb_iButton2, fb_iContact
v2.0 2017-02-09 nem  directive PUBLIC changed to PUBLIC_iFOX  
                     added blocks fb_iTimeProgWeek, 
                     fb_iTimeProgWeek1 a fb_iTimeProgWeek2 
v2.1 2018-03-14 nem  added block fb_iTimeProgWeek3 
	        byd  added pulse lenght control to fbJalousie
v2.2 2018-12-10 byd  variable showname added to T_TIME_PROG_WEEK_WEB_SETTINGS, which controls visibility of time program name on canvas
                par  added block fb_C_RC_0006R, modified blocks fb_iDimmer, fb_iJalousie, fb_iRelay, fb_iScene4, fb_iScene8
*)

(*----------------------------------------------------------------------------*)
// {LIBRARY="LOCALLIB\DATABOXLIB_V17_20170717.MLB"}
// {LIBRARY="LOCALLIB\DEBUGCOMLIB_V17_20160411.MLB"}

VAR_GLOBAL CONSTANT
 ICL_SIZE_NAME : int :=  24;
 ICL_IFOX_PATH : string [12] :=  'WWW/iFOX/';
 APP_ICON_default : uint :=  0;
 APP_ICON_socket : uint :=  1;
 APP_ICON_fan : uint :=  2;
 APP_ICON_heating : uint :=  3;
 APP_ICON_extLink : uint :=  1000;
 APP_ICON_rain : uint :=  1001;
 APP_ICON_vlc : uint :=  1002;
 APP_ICON_parking : uint :=  1003;
 APP_ICON_parkingcar : uint :=  1004;
 APP_ICON_music : uint :=  1005;
 APP_ICON_radarcloud : uint :=  1006;
 APP_ICON_kodi : uint :=  1007;

END_VAR

TYPE T_SET_RGB_LIGHT :
  STRUCT
    level            : real;
    RGB              : T_RGB_COLOR;
  END_STRUCT;
END_TYPE

TYPE  T_TIME_VAL : time :=  T#24h00m0s;
END_TYPE

TYPE T_TIME_PROG_WEEK :
  STRUCT
    name             : string [24];  (*name of time program*)
    update           : usint;  (*pozadavek na update cas. programu z aplikace iFoxtrot*)
    typ              : usint;  (*ICL_TPW_TYPE_HEATING, ICL_TPW_TYPE_COOLING, ICL_TPW_TYPE_HEATING_COOLING*)
    numTimes         : usint;  (*pocet casovych znacek za den (min 2, max 7)*)
    units            : usint;  (*jednotky 0 = °C, 1 = °F*)
    heatTemp         : ARRAY [0..3] OF real;  (*teploty topeni pro kazdy rezim casoveho programu*)
    coolTemp         : ARRAY [0..3] OF real;  (*teploty chlazeni pro kazdy rezim casoveho programu*)
    times            : ARRAY [0..6,0..6] OF T_TIME_VAL;  (*casove intervaly casoveho programu*)
    values           : ARRAY [0..6,0..7] OF usint;  (*rezimy casoveho programu*)
    holiday          : ARRAY [0..1] OF dt;  (*dovolena [od, do]*)
    reserved         : dword;  (*rezerva*)
    crc              : uint;  (*crc = 0 ... povel ze strany termostatu a nebo web rozhrani pro ukladani struktury do souboru*)
  END_STRUCT;
END_TYPE

TYPE T_TIME_PROG_WEEK_STAT :
  STRUCT
    manual           : bool;  (*0 = auto, 1 = manual*)
    holiday          : bool;  (*1 = is holiday*)
    heat             : bool;  (*pozadavek na topeni*)
    cool             : bool;  (*pozadavek na chlazeni*)
    units            : bool;  (*0 = °C, 1 = °F*)
    roomTemp         : real;  (*teplota v mistnosti*)
    heatTemp         : real;  (*pozadovana teplota topeni*)
    coolTemp         : real;  (*pozadovana teplota chlazeni*)
    mode             : sint;  (*zvoleny rezim ... 0 = limit, 1 = ECO, 2 = NIGHT {utlum), 3 = DAY (komfort)*)
    interval         : usint;  (*aktualni interval podle cas. programu*)
    delta            : real;  (*aktualni delta <-5.0, 5.0>*)
    initial          : word;  (*initial.0-1	editacni mod - 0 zobrazit data, 1 prochazeni dat, 2 editacni rezim*)
  END_STRUCT;
END_TYPE

TYPE T_TIME_PROG_WEEK_CONT :
  STRUCT
    nextProg         : bool;  (*auto -> manual, manual -> auto*)
    nextMode         : bool;  (*zmena rezimu v manualnim modu (ECO <-> NIGHT <-> DAY)*)
    rqMode           : sint :=  -1;  (*zvoleny rezim ... -1 = no request, 0 = limit, 1 = ECO, 2 = NIGHT {utlum), 3 = DAY (komfort)*)
    rqNewDelta       : bool;  (*zadost o nastaveni nove hodnoty delta*)
    newDelta         : real;  (*nova hodnota delta <-5.0, 5.0>*)
  END_STRUCT;
END_TYPE

TYPE T_TIME_PROG_WEEK_INTERFACE :
  STRUCT
    stat             : T_TIME_PROG_WEEK_STAT;
    cont             : T_TIME_PROG_WEEK_CONT;
  END_STRUCT;
END_TYPE

TYPE T_TIME_PROG_WEEK_WEB_SETTINGS :
  STRUCT
    darkBg           : bool;  (*:= FALSE = light background, TRUE = dark background*)
    showName         : bool;  (*:= TRUE = show name of the week program*)
    copyT            : string [24];  (*:= 'Copy ';*)
    selT             : string [24];  (*:= 'Select dest. day';*)
    startH           : string [32];  (*:= 'Set start of holiday';*)
    endH             : string [32];  (*:= 'Set end of holiday';*)
    days             : ARRAY [0..6] OF string [4];  (*:= ['MON','TUE','WED','THU','FRI','SAT','SUN'];*)
    months           : ARRAY [1..12] OF string [16];  (*:= ['January','February','March','April','May','June','July','August','September','October','November','December'];*)
    buttons          : ARRAY [0..4] OF string [9];  (*:= ['HEAT','COOL','HOLIDAY','CANCEL','SAVE']*)
  END_STRUCT;
END_TYPE

TYPE  T_TIME_PROG_WEEK_WEB_SETTINGS_CZE : T_TIME_PROG_WEEK_WEB_SETTINGS :=  ( copyT   := 'Kopírovat ',
                                                                          selT    := 'Zvolte cílový den',
                                                                          startH  := 'Zadejte zaèátek dovolené',
                                                                          endH    := 'Zadejte konec dovolené',
                                                                          days    := ['PO','ÚT','ST','ÈT','PÁ','SO','NE'],
                                                                          months  := ['Leden','Únor','Bøezen','Duben','Kvìten','Èerven','Èervenec','Srpen','Záøí','Øíjen','Listopad','Prosinec'],
                                                                          buttons := ['TOPENÍ','CHLAZENÍ','DOVOLENÁ','ZRUIT','ULOIT']);
END_TYPE

TYPE  T_TIME_PROG_WEEK_WEB_SETTINGS_ENG : T_TIME_PROG_WEEK_WEB_SETTINGS :=  ( copyT   := 'Copy ',
                                                                          selT    := 'Select dest. day',
                                                                          startH  := 'Set start of holiday',
                                                                          endH    := 'Set end of holiday',
                                                                          days    := ['MO','TU','WE','TH','FR','SA','SU'],
                                                                          months  := ['January','February','March','April','May','June','July','August','September','October','November','December'],
                                                                          buttons := ['HEATING','COOLING','HOLIDAY','CANCEL','SAVE']);
END_TYPE

__DECL FUNCTION_BLOCK fb_iLight
(*Basic control of light output*)
  VAR_INPUT
    lightOn          : bool R_EDGE;  (*light on*)
    lightOff         : bool R_EDGE;  (*light off*)
    lightToggle      : bool R_EDGE;  (*light toggle*)
    timeLimit        : time;  (*duration of light on*)
    webToggle        : bool R_EDGE;  (*light toggle from web page*)
    lightReset       : bool R_EDGE;  (*central reset of light*)
    name             : string [24];  (*name of light*)
  END_VAR
  VAR_OUTPUT
    out              : bool;  (*light control*)
  END_VAR
  VAR
    GTSAP1_LIGHT_name {PUBLIC_IFOX} : string [24];
    GTSAP1_LIGHT_enable {PUBLIC_IFOX} : bool :=  1;
    GTSAP1_LIGHT_type {PUBLIC_IFOX} : bool :=  0;
    GTSAP1_LIGHT_onoff {OPEN_UP} {PUBLIC_IFOX} : bool;
    stopTime         : time;
  END_VAR
END_FUNCTION_BLOCK

VAR_GLOBAL CONSTANT
 ICL_RELAY_TYPE_ON_OFF : usint :=  0;
 ICL_RELAY_TYPE_DIMMING : usint :=  1;
 ICL_RELAY_TYPE_MULTI_STATE : usint :=  2;

END_VAR

__DECL FUNCTION_BLOCK fb_iRelay
(*Function block for basic control of relay output
         Pulse on the input 'in' starts pulse on output 'out' during defined time in the parameter 'pulsTime'.
         Only rising edge on the input 'in' (0 to 1) generates pulse on output 'out_on'.The falling edge on the input 'in' (1 to 0) generates pulse on output 'out_off'*)
  VAR_INPUT
    relayOn          : bool R_EDGE;  (*relay on*)
    relayOff         : bool R_EDGE;  (*relay off*)
    relayToggle      : bool R_EDGE;  (*relay toggle*)
    pulseTime        : time;  (*pulse duration*)
    webToggle        : bool R_EDGE;  (*relay toggle from web page*)
    relayReset       : bool R_EDGE;  (*central reset of relay*)
    symbol           : uint;  (*icon in iFoxtrot App (APP_ICON_socket, ..)*)
    name             : string [24];  (*name*)
  END_VAR
  VAR_OUTPUT
    out              : bool;  (*relay control*)
    out_on           : bool;  (*Short pulse when out changed from 0 to 1*)
    out_off          : bool;  (*Short pulse when out changed from 1 to 0*)
    fbPtr            : udint;  (*function block pointer*)
  END_VAR
  VAR
    GTSAP1_RELAY_name {PUBLIC_IFOX} : string [24];  (*name of function block*)
    GTSAP1_RELAY_enable {PUBLIC_IFOX} : bool :=  1;  (*command to display FB in iFoxtrot App*)
    GTSAP1_RELAY_type {PUBLIC_IFOX} : usint :=  ICL_RELAY_TYPE_ON_OFF;  (*relay type (0=onOff, 1=dimming, 2=multiState)*)
    GTSAP1_RELAY_symbol {PUBLIC_IFOX} : uint;  (*icon in iFoxtrot App (APP_ICON_socket, ..)*)
    GTSAP1_RELAY_onoff {OPEN_UP} {PUBLIC_IFOX} : bool;  (*relay on/off command from iFoxtrot App*)
    stopTime         : time;
    in_Ftrig         : F_TRIG;
    in_Rtrig         : R_TRIG;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_iAction
(*block catches requests of actions which are generated from mobile app or web page*)
  VAR_INPUT
    action           : bool R_EDGE;  (*request for action*)
    webAction        : bool R_EDGE;  (*request for action from web page*)
    name             : string [24];  (*name*)
  END_VAR
  VAR
    GTSAP1_ACTION_name {PUBLIC_IFOX} : string [24];
    GTSAP1_ACTION_enable {PUBLIC_IFOX} : bool :=  1;
    GTSAP1_ACTION_exec {OPEN_UP} {PUBLIC_IFOX} : bool;
  END_VAR
  VAR_OUTPUT
    out              : bool;  (*TRUE means make action*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_Button1
(*block for processing of signals from button; long and short press detection*)
  VAR_INPUT
    in               : bool;  (*button*)
    pressTime        : time :=  T#750ms;  (*time for long click*)
  END_VAR
  VAR_OUTPUT
    out              : bool;  (*copy of input in*)
    click            : bool;  (*short click*)
    press            : bool;  (*long click*)
  END_VAR
  VAR
    in_Ftrig         : F_TRIG;
    in_ton           : TON;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_iSensorPIR
(*presence detection*)
  VAR_INPUT
    in               : bool;  (*PIR sensor*)
    delay            : time;  (*insensitivity*)
    name             : string [24];  (*name*)
  END_VAR
  VAR_OUTPUT
    out              : bool;  (*detection of motion*)
  END_VAR
  VAR
    GTSAP1_PIRSENSOR_name {PUBLIC_IFOX} : string [24];
    GTSAP1_PIRSENSOR_enable {PUBLIC_IFOX} : bool :=  1;
    GTSAP1_PIRSENSOR_value {PUBLIC_IFOX} : bool;
    timSensor        : TON;  (*zpozdeni detekce*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_iDimmer
(*Light dimmer,
         short press activates and deactivates light (to set level with ramp "offOnRamp")
         long presses changes the level with ramp "setRamp". Output level 0..100% - for controlling 0..10V*)
  VAR_INPUT
    lightOn          : bool R_EDGE;  (*turn on the light at the last level (short press)*)
    levelUp          : bool;  (*increase the level (long press)*)
    lightOff         : bool R_EDGE;  (*turn off the light (short press)*)
    levelDw          : bool;  (*decrease the level (long press)*)
    lightToggle      : bool R_EDGE;  (*toggle of the light*)
    minLevel         : real :=  10.0;  (*min level for light [%]*)
    offOnRamp        : time :=  T#5s;  (*ramp Off/On from min level to 100% [sec]*)
    setRamp          : time :=  T#8s;  (*ramp Up/Dw from min level to 100%  [sec]*)
    timeLimit        : time;  (*maximum time limit light [sec]*)
    webToggle        : bool R_EDGE;  (*control lights from web page*)
    lightReset       : bool R_EDGE;  (*central switching off*)
    name             : string [24];  (*name of light*)
  END_VAR
  VAR_IN_OUT
    setLevel         : real;  (*last level (this variable have to be RETAIN)*)
  END_VAR
  VAR_OUTPUT
    out              : bool;  (*indication Off/On*)
    level            : real;  (*level 0..100[%]*)
    minLev           : real;  (*min level 0..90[%]*)
    fbPtr            : udint;  (*function block pointer*)
  END_VAR
  VAR
    GTSAP1_LIGHT_name {PUBLIC_IFOX} : string [24];
    GTSAP1_LIGHT_enable {PUBLIC_IFOX} : bool :=  1;
    GTSAP1_LIGHT_type {PUBLIC_IFOX} : bool :=  1;
    GTSAP1_LIGHT_dimtype {PUBLIC_IFOX} : bool :=  0;
    GTSAP1_LIGHT_onoff {OPEN_UP} {PUBLIC_IFOX} : bool;
    GTSAP1_LIGHT_dimlevel {OPEN_UP} {PUBLIC_IFOX} : real;
    gtsap1_old       : real;  (*pro vyhodnoceni zmeny od mobilni aplikace*)
    oldSetLevel      : real;  (*pro vyhodnoceni zmeny retain promenne*)
    toggleOn         : bool;  (*pomocna pro zapnuti*)
    toggleOff        : bool;  (*pomocna pro vypnuti*)
    lastLevelUp      : bool;
    lastLevelDw      : bool;
    lastSL52         : udint;
    tim              : TON;  (*casovac pro omezeni doby osvetleni*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_iDimmerLED
(*LED light dimmer,
         short press activates and deactivates light (to set level with ramp "offOnRamp")
         long presses changes the level with ramp "setRamp".
         Output level 0..100%, ramp [sec] for one channel of a CIB ULED/ILED/RLC*)
  VAR_INPUT
    lightOn          : bool R_EDGE;  (*turn on the light at the last level (short press)*)
    levelUp          : bool;  (*increase the level (long press)*)
    lightOff         : bool R_EDGE;  (*turn off the light (short press)*)
    levelDw          : bool;  (*decrease the level (long press)*)
    lightToggle      : bool R_EDGE;  (*toggle of the light*)
    minLevel         : real :=  10.0;  (*min level for light [%]*)
    offOnRamp        : time :=  T#5s;  (*ramp Off/On from min level to 100% [sec]*)
    setRamp          : time :=  T#8s;  (*ramp Up/Dw from min level to 100%  [sec]*)
    timeLimit        : time;  (*maximum time limit light [sec]*)
    webToggle        : bool R_EDGE;  (*control lights from web page*)
    lightReset       : bool R_EDGE;  (*central switching off*)
    name             : string [24];  (*name of light*)
  END_VAR
  VAR_IN_OUT
    setLevel         : real;  (*last level (this variable have to be RETAIN)*)
  END_VAR
  VAR_OUTPUT
    out              : bool;  (*indication Off/On*)
    level            : real;  (*level 0..100 [%]*)
    ramp             : usint;  (*ramp for On/Off*)
    minLev           : real;  (*min level 0..90[%]*)
  END_VAR
  VAR
    GTSAP1_LIGHT_name {PUBLIC_IFOX} : string [24];
    GTSAP1_LIGHT_enable {PUBLIC_IFOX} : bool :=  1;
    GTSAP1_LIGHT_type {PUBLIC_IFOX} : bool :=  1;
    GTSAP1_LIGHT_dimtype {PUBLIC_IFOX} : bool :=  0;
    GTSAP1_LIGHT_onoff {OPEN_UP} {PUBLIC_IFOX} : bool;
    GTSAP1_LIGHT_dimlevel {OPEN_UP} {PUBLIC_IFOX} : real;
    gtap1_old        : real;  (*pro vyhodnoceni zmeny od mobilni aplikace*)
    oldSetLevel      : real;  (*pro vyhodnoceni zmeny retain promenne*)
    toggleOn         : bool;  (*pomocna pro zapnuti*)
    toggleOff        : bool;  (*pomocna pro vypnuti*)
    lastLevelUp      : bool;
    lastLevelDw      : bool;
    lastSL52         : udint;
    tim              : TON;  (*casovac pro omezeni doby osvetleni*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION iControl_RGB_COLOR_TO_UDINT {HIDDEN} : udint
  VAR_INPUT
    color            : T_RGB_COLOR;
  END_VAR
END_FUNCTION

__DECL FUNCTION iControl_UDINT_TO_RGB_COLOR {HIDDEN} : T_RGB_COLOR
  VAR_INPUT
    color            : udint;
  END_VAR
END_FUNCTION

__DECL FUNCTION_BLOCK fb_iDimmerRGB
(*RGB dimmer,
         short press activates and deactivates light (to set level with ramp "offOnRamp")
         long press changes the level with ramp "setRamp"
         Outputs: 3 x level 0..100%, 3 x ramp [sec] for 3 RGB channels of ULED/ILED CIB module*)
  VAR_INPUT
    lightOn          : bool R_EDGE;  (*turn on the light at the last level (short press)*)
    levelUp          : bool;  (*increase the level (long press)*)
    lightOff         : bool R_EDGE;  (*turn off the light (short press)*)
    levelDw          : bool;  (*decrease the level (long press)*)
    lightToggle      : bool R_EDGE;  (*toggle of the light*)
    minLevel         : real :=  5.0;  (*min level for light [%]*)
    offOnRamp        : time :=  T#5s;  (*ramp Off/On from min level to 100% [sec]*)
    setRamp          : time :=  T#8s;  (*ramp Up/Dw from min level to 100%  [sec]*)
    timeLimit        : time;  (*maximum time limit light [sec]*)
    webToggle        : bool R_EDGE;  (*control lights from web page*)
    lightReset       : bool R_EDGE;  (*central switching off*)
    name             : string [24];  (*name of light*)
  END_VAR
  VAR_IN_OUT
    setLight         : T_SET_RGB_LIGHT;  (*last level and color (this variable have to be in VAR_GLOBAL RETAIN)*)
  END_VAR
  VAR_OUTPUT
    out              : bool;  (*indication Off/On*)
    levelRed         : real;  (*red level 0..100 [%]*)
    levelGreen       : real;  (*green level 0..100 [%]*)
    levelBlue        : real;  (*blue level 0..100 [%]*)
    rampRed          : usint;  (*red ramp [sec]*)
    rampGreen        : usint;  (*green ramp [sec]*)
    rampBlue         : usint;  (*blue ramp [sec]*)
    minLev           : real;  (*min level 0..90[%]*)
  END_VAR
  VAR
    GTSAP1_LIGHT_name {PUBLIC_IFOX} : string [24];
    GTSAP1_LIGHT_enable {PUBLIC_IFOX} : bool :=  1;
    GTSAP1_LIGHT_type {PUBLIC_IFOX} : bool :=  1;
    GTSAP1_LIGHT_dimtype {PUBLIC_IFOX} : bool :=  1;
    GTSAP1_LIGHT_onoff {OPEN_UP} {PUBLIC_IFOX} : bool;
    GTSAP1_LIGHT_dimlevel {OPEN_UP} {PUBLIC_IFOX} : real;
    GTSAP1_LIGHT_rgb {OPEN_UP} {PUBLIC_IFOX} : udint;
    toggleOn         : bool;  (*pomocna pro zapnuti*)
    toggleOff        : bool;  (*pomocna pro vypnuti*)
    lastLevelUp      : bool;
    lastLevelDw      : bool;
    lastSL52         : udint;
    level            : real;  (*svetelnost RGB (jas)*)
    oldSetGTSAP1     : T_SET_RGB_LIGHT;
    oldSetLight      : T_SET_RGB_LIGHT;
    tim              : TON;  (*casovac pro omezeni doby osvetleni*)
    red              : real;
    green            : real;
    blue             : real;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_iJalousie
(*Jalousie control*)
  VAR_INPUT
    rotUp            : bool R_EDGE;  (*step up*)
    up               : bool R_EDGE;  (*move up*)
    rotDw            : bool R_EDGE;  (*step down*)
    dw               : bool R_EDGE;  (*move down*)
    block            : bool;  (*blocking*)
    stop             : bool R_EDGE;  (*stop the movement*)
    ctrUp            : bool R_EDGE;  (*central up*)
    ctrDw            : bool R_EDGE;  (*central down*)
    webUp            : bool R_EDGE;  (*activation of "move up" from web interface*)
    webDw            : bool R_EDGE;  (*activation of "move down"  from web interface*)
    upDwTime         : time :=  T#20s;  (*maximum time of movement*)
    rotTime          : time :=  T#0.5s;  (*lenght of step [sec]*)
    pauseTime        : time :=  T#1.0s;  (*delay between reversation of movement [sec]*)
    ctrTime          : time := T#10.0s ;  (*central movement delay [sec]*)
    name             : string [24];  (*name of the jalousie*)
  END_VAR
  VAR_OUTPUT
    outUp            : bool;  (*jalousie is moving up*)
    outDw            : bool;  (*jalousie is moving down*)
    sig              : bool;  (*jalousie is moving*)
    sigUp            : bool;  (*jalousie is up*)
    sigDw            : bool;  (*jalousie is down*)
    pd               : usint;  (*impulse length for rotating jalousie*)
    posit            : usint;  (*jalousie position [%]*)
    fbPtr            : udint;  (*function block pointer*)
  END_VAR
  VAR
    GTSAP1_SHUTTER_name {PUBLIC_IFOX} : string [24];
    GTSAP1_SHUTTER_enable {PUBLIC_IFOX} : bool :=  1;
    GTSAP1_SHUTTER_up {PUBLIC_IFOX} : bool;
    GTSAP1_SHUTTER_down {PUBLIC_IFOX} : bool;
    GTSAP1_SHUTTER_run {PUBLIC_IFOX} : bool;
    GTSAP1_SHUTTER_uppos {PUBLIC_IFOX} : bool;
    GTSAP1_SHUTTER_downpos {PUBLIC_IFOX} : bool;
    GTSAP1_SHUTTER_up_control {OPEN_UP} {PUBLIC_IFOX} : bool;
    GTSAP1_SHUTTER_down_control {OPEN_UP} {PUBLIC_IFOX} : bool;
    GTSAP1_SHUTTER_rotup_control {OPEN_UP} {PUBLIC_IFOX} : bool;
    GTSAP1_SHUTTER_rotdown_control {OPEN_UP} {PUBLIC_IFOX} : bool;
    cas_stop         : time :=  T#0s;
    pauseUp          : bool;
    pauseDw          : bool;
    longUpDw         : bool;
    timUp            : TOF;
    timDw            : TOF;
    centrUp          : bool;
    centrUpH         : bool;
    centrDw          : bool;
    centrDwH         : bool;
    centrDelay       : time;
    lpd              : usint;
    positTim         : time;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_TimeAction
(*Function block that creates action impulse in given time of day.
   timeOfAction := T#22h activates the output in 22:00:00 [hh:mm:ss]*)
  VAR_INPUT
    enable           : bool;  (*povolení aktivace*)
    timeOfAction1    : time;  (*time of 1st action*)
    timeOfAction2    : time;  (*time of 2nd action*)
  END_VAR
  VAR_OUTPUT
    out1             : bool;  (*output for 1st action*)
    out2             : bool;  (*output for 2nd action*)
  END_VAR
  VAR
    out1Trgr         : R_TRIG;
    out2Trgr         : R_TRIG;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_JalAlarm
(*Basic reaction to alerts.
    Precedency:
    1. fire  : move up and block
    2. ice   : stop and block
    3. wind  : move up and block
    4. glass : move down*)
  VAR_INPUT
    fire             : bool;  (*fire alert: move up and block jalousie inputs*)
    ice              : bool;  (*ice alert: stop the movement and block jalousie inputs*)
    wind             : bool;  (*wind alert: move up and block jalousie inputs*)
    glass            : bool;  (*glass breaking alert: move down*)
    blockJal         : bool;  (*blocking of jalousie inputs*)
    stopJal          : bool R_EDGE;  (*stop the movement*)
    ctrUpJal         : bool R_EDGE;  (*central movement up*)
    ctrDwJal         : bool R_EDGE;  (*central movement down*)
  END_VAR
  VAR_OUTPUT
    block            : bool;  (*blocking of jalousie inputs, connect with jalousie control*)
    stop             : bool;  (*stop the movement, connect with jalousie cotnrol*)
    ctrUp            : bool;  (*central movement up, connect with jalousie cotnrol*)
    ctrDw            : bool;  (*central movement down, connect with jalousie cotnrol*)
  END_VAR
  VAR
    fire_Rtrig       : R_TRIG;
    ice_Rtrig        : R_TRIG;
    wind_Rtrig       : R_TRIG;
    glass_Rtrig      : R_TRIG;
    fireH            : bool;
    iceH             : bool;
    windH            : bool;
    glassH           : bool;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_RndPulse
(*Function block that randomly activates its output for a radnom time duration.*)
  VAR_INPUT
    enable           : bool;  (*Enables the FB*)
    sTime            : time;  (*Start of the generating (time)*)
    eTime            : time;  (*End of the generating (time)*)
    minOffT          : time :=  T#5m;  (*Minimal time of "0"*)
    minOnT           : time :=  T#10m;  (*Minimal time of "1"*)
    maxLenght        : time :=  T#1h;  (*Maximal lenght of "1" and "0".*)
  END_VAR
  VAR_OUTPUT
    out              : bool;  (*randomly generated output signal*)
    outOn            : bool;  (*rising edge of out*)
    outOff           : bool;  (*falling edge of out*)
  END_VAR
  VAR
    tOffStart        : bool;
    timerOff         : TON;
    timerOn          : TON;
    bottleneck       : real;
    i                : usint :=  1;
    duration         : time;
    cas              : ARRAY [1..2] OF time;
    dTime            : time;
    trigOn           : R_TRIG;
    trigOff          : F_TRIG;
    seed             : dint;
    init_seed        : bool :=  1;
    k                : dint;
    random           : real;
  END_VAR
END_FUNCTION_BLOCK

VAR_GLOBAL CONSTANT
 ICL_SCENE_PREFIX : string [4] :=  'SCN_';
 ICL_SCENE_FORMAT : string [8] :=  '%04X.sc?';
 ICL_SCENE_ERR1 : string [23] :=  'Name of scene is empty!';
 ICL_SCENE_ERR2 : string [11] :=  ' not found!';

END_VAR

__DECL FUNCTION_BLOCK fb_iScene4
(*Scene control
         Block can control up to 4 scenes*)
  VAR_INPUT
    scene1On         : bool R_EDGE;  (*set up scene 1*)
    scene2On         : bool R_EDGE;  (*set up scene 2*)
    scene3On         : bool R_EDGE;  (*set up scene 3*)
    scene4On         : bool R_EDGE;  (*set up scene 4*)
    webScene1On      : bool R_EDGE;  (*set up scene 1 from web page*)
    webScene2On      : bool R_EDGE;  (*set up scene 2 from web page*)
    webScene3On      : bool R_EDGE;  (*set up scene 3 from web page*)
    webScene4On      : bool R_EDGE;  (*set up scene 4 from web page*)
    name             : string [24];  (*name of scene*)
  END_VAR
  VAR_OUTPUT
    busy             : bool;  (*block is busy*)
    lastErr          : string [80];  (*last error description*)
    file             : string [12];  (*name of json file with description of scene*)
    scene            : usint;  (*active scene*)
    fbPtr            : udint;  (*function block pointer*)
  END_VAR
  VAR
    GTSAP1_SCENE_name {PUBLIC_IFOX} : string [24];
    GTSAP1_SCENE_file {PUBLIC_IFOX} : string [24];
    GTSAP1_SCENE_enable {PUBLIC_IFOX} : bool :=  1;
    GTSAP1_SCENE_num {PUBLIC_IFOX} : usint :=  4;
    GTSAP1_SCENE_set1 {OPEN_UP} {PUBLIC_IFOX} : bool;
    GTSAP1_SCENE_set2 {OPEN_UP} {PUBLIC_IFOX} : bool;
    GTSAP1_SCENE_set3 {OPEN_UP} {PUBLIC_IFOX} : bool;
    GTSAP1_SCENE_set4 {OPEN_UP} {PUBLIC_IFOX} : bool;
    rqScene1         : bool;
    rqScene2         : bool;
    rqScene3         : bool;
    rqScene4         : bool;
    rqScene          : bool;
    JsonParser       : fbJsonFileParser;  (*FB pro pársování souboru*)
    json             : TJsonInfo;  (*struktura pro výsledky pársování*)
    fileName         : string [24];
    extNum           : usint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_iScene8
(*Scene control
         Block can control up to 8 scenes*)
  VAR_INPUT
    scene1On         : bool R_EDGE;  (*set up scene 1*)
    scene2On         : bool R_EDGE;  (*set up scene 2*)
    scene3On         : bool R_EDGE;  (*set up scene 3*)
    scene4On         : bool R_EDGE;  (*set up scene 4*)
    scene5On         : bool R_EDGE;  (*set up scene 5*)
    scene6On         : bool R_EDGE;  (*set up scene 6*)
    scene7On         : bool R_EDGE;  (*set up scene 7*)
    scene8On         : bool R_EDGE;  (*set up scene 8*)
    webScene1On      : bool R_EDGE;  (*set up scene 1 from web page*)
    webScene2On      : bool R_EDGE;  (*set up scene 2 from web page*)
    webScene3On      : bool R_EDGE;  (*set up scene 3 from web page*)
    webScene4On      : bool R_EDGE;  (*set up scene 4 from web page*)
    webScene5On      : bool R_EDGE;  (*set up scene 5 from web page*)
    webScene6On      : bool R_EDGE;  (*set up scene 6 from web page*)
    webScene7On      : bool R_EDGE;  (*set up scene 7 from web page*)
    webScene8On      : bool R_EDGE;  (*set up scene 8 from web page*)
    name             : string [24];  (*name of scene*)
  END_VAR
  VAR_OUTPUT
    busy             : bool;  (*block is busy*)
    lastErr          : string [80];  (*last error description*)
    file             : string [12];  (*name of json file with description of scene*)
    scene            : usint;  (*active scene*)
    fbPtr            : udint;  (*function block pointer*)
  END_VAR
  VAR
    GTSAP1_SCENE_name {PUBLIC_IFOX} : string [24];
    GTSAP1_SCENE_file {PUBLIC_IFOX} : string [24];
    GTSAP1_SCENE_enable {PUBLIC_IFOX} : bool :=  1;
    GTSAP1_SCENE_num {PUBLIC_IFOX} : usint :=  8;
    GTSAP1_SCENE_set1 {OPEN_UP} {PUBLIC_IFOX} : bool;
    GTSAP1_SCENE_set2 {OPEN_UP} {PUBLIC_IFOX} : bool;
    GTSAP1_SCENE_set3 {OPEN_UP} {PUBLIC_IFOX} : bool;
    GTSAP1_SCENE_set4 {OPEN_UP} {PUBLIC_IFOX} : bool;
    GTSAP1_SCENE_set5 {OPEN_UP} {PUBLIC_IFOX} : bool;
    GTSAP1_SCENE_set6 {OPEN_UP} {PUBLIC_IFOX} : bool;
    GTSAP1_SCENE_set7 {OPEN_UP} {PUBLIC_IFOX} : bool;
    GTSAP1_SCENE_set8 {OPEN_UP} {PUBLIC_IFOX} : bool;
    rqScene1         : bool;
    rqScene2         : bool;
    rqScene3         : bool;
    rqScene4         : bool;
    rqScene5         : bool;
    rqScene6         : bool;
    rqScene7         : bool;
    rqScene8         : bool;
    rqScene          : bool;
    JsonParser       : fbJsonFileParser;  (*FB pro pársování souboru*)
    json             : TJsonInfo;  (*struktura pro výsledky pársování*)
    fileName         : string [24];
    extNum           : usint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_iWebConf
(*Publication of web page into iFoxtrot application or link of external application

  applications supported over URL:
  SoundTouch:     (SoundTouch Controller from Bose https:itunes.apple.com/cz/app/soundtouch-controller/id708379313?mt=8)
  control4v2:     (Control4 https:itunes.apple.com/us/app/control4/id734435367?mt=8)
  sonos:          (Sonos Controller https:itunes.apple.com/cz/app/sonos-controller/id293523031?mt=8)
  vlc-x-callback: (VLC, parameter description: https:wiki.videolan.org/Documentation:IOS/#x-callback-url)
  vlc:            (VLC without parameters)
  xbmcremote:     (Official Kodi Remote https:itunes.apple.com/cz/app/official-kodi-remote/id520480364?mt=8)
  music:          (system iOS Music aplication)*)
  VAR_INPUT
    link             : string [80];  (*link on PLC web page or URl link of application ('vlc://', ...) ! case sensitive*)
    symbol           : uint :=  APP_ICON_extLink;  (*icon name of application (rain, vlc, parking, parkingcar, music, radarcloud, kodi)*)
    name             : string [24];  (*name of block (iFoxtrot icon)*)
  END_VAR
  VAR
    GTSAP1_WEBCONF_name {PUBLIC_IFOX} : string [24];
    GTSAP1_WEBCONF_url {PUBLIC_IFOX} : string [80];  (*napr. index.xml*)
    GTSAP1_WEBCONF_enable {PUBLIC_IFOX} : bool :=  1;
    GTSAP1_WEBCONF_symbol {PUBLIC_IFOX} : uint;  (*viz konstanty APP_ICON_extLink, APP_ICON_rain, APP_ICON_vlc, APP_ICON_parking, APP_ICON_parkingcar, APP_ICON_music, APP_ICON_radarcloud, APP_ICON_kodi*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_iWebCamera
(*Publication of web camera into iFoxtrot application*)
  VAR_INPUT
    url              : string [80];  (*URL address of web camera*)
    name             : string [24];  (*name of block (iFoxtrot icon)*)
  END_VAR
  VAR
    GTSAP1_CAMERA_name {PUBLIC_IFOX} : string [24];
    GTSAP1_CAMERA_url {PUBLIC_IFOX} : string [80];  (*napr. http://posta.mukolin.cz/axis-cgi/jpg/image.cgi*)
    GTSAP1_CAMERA_enable {PUBLIC_IFOX} : bool :=  1;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_iSocket
(*Basic control of relay output*)
  VAR_INPUT
    socketOn         : bool R_EDGE;  (*socket on*)
    socketOff        : bool R_EDGE;  (*socket off*)
    socketToggle     : bool R_EDGE;  (*socket toggle*)
    pulseTime        : time;  (*pulse duration*)
    webToggle        : bool R_EDGE;  (*socket toggle from web page*)
    socketReset      : bool R_EDGE;  (*central reset of socket*)
    name             : string [24];  (*name*)
  END_VAR
  VAR_OUTPUT
    out              : bool;  (*socket control*)
  END_VAR
  VAR
    GTSAP1_SOCKET_name {PUBLIC_IFOX} : string [24];
    GTSAP1_SOCKET_enable {PUBLIC_IFOX} : bool :=  1;
    GTSAP1_SOCKET_onoff {OPEN_UP} {PUBLIC_IFOX} : bool;
    stopTime         : time;
  END_VAR
END_FUNCTION_BLOCK

VAR_GLOBAL CONSTANT
 ICL_DISPLAY_TYPE_ON_OFF : usint :=  0;
 ICL_DISPLAY_TYPE_VALUE : usint :=  1;

END_VAR

__DECL FUNCTION_BLOCK fb_iDisplay_Val
(*function block for display of value including units*)
  VAR_INPUT
    value            : real;  (*value (REAL variable)*)
    unit             : string [8];  (*units (kWh, km/h, ...)*)
    precision        : int;  (*size of fraction part*)
    link             : string [80];  (*URL address of web page*)
    symbol           : uint;  (*icon in iFoxtrot App (APP_ICON_socket, ..)*)
    name             : string [24];  (*name*)
  END_VAR
  VAR_OUTPUT
    out              : real;  (*copy 'value'*)
  END_VAR
  VAR
    GTSAP1_DISPLAY_name {PUBLIC_IFOX} : string [24];  (*Name of function block*)
    GTSAP1_DISPLAY_enable {PUBLIC_IFOX} : bool :=  1;  (*Icon in iFoxtrot App (APP_ICON_socket, ..)*)
    GTSAP1_DISPLAY_edit {PUBLIC_IFOX} : bool :=  0;  (*Indication of editable value or not*)
    GTSAP1_DISPLAY_type {PUBLIC_IFOX} : usint :=  ICL_DISPLAY_TYPE_VALUE;  (*Display type (0=onOff, 1=real value)*)
    GTSAP1_DISPLAY_symbol {PUBLIC_IFOX} : uint;  (*Command to display FB in iFoxtrot App*)
    GTSAP1_DISPLAY_value {PUBLIC_IFOX} : real;  (*Value to display*)
    GTSAP1_DISPLAY_unit {PUBLIC_IFOX} : string [8];  (*Measurement unit (%,bar,C/F ...)*)
    GTSAP1_DISPLAY_precision {PUBLIC_IFOX} : int;  (*Precision of fraction part of Value*)
    GTSAP1_DISPLAY_url {PUBLIC_IFOX} : string [80];  (*Link (URL) to web page (grapth, history ...)*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_iDisplay_Edit
(*Function block for display in mobile applications iFoxtrot value including physical units*)
  VAR_INPUT
    unit             : string [8];  (*units (kWh, km/h, ...)*)
    precision        : int;  (*size of fraction part*)
    limitUp          : real;  (*Upper limit of 'Value'*)
    limitDw          : real;  (*Lower limit of 'Value'*)
    step             : real :=  0.1;  (*Value of one step increment or decrement from iFoxtrot*)
    webUp            : bool R_EDGE;  (*inc value from web interface*)
    webDw            : bool R_EDGE;  (*dec value from web interface*)
    link             : string [80];  (*URL address of web page*)
    symbol           : uint;  (*icon in iFoxtrot App (APP_ICON_socket, ..)*)
    name             : string [24];  (*name of function block in iFoxtrot App*)
  END_VAR
  VAR_IN_OUT
    value            : real;  (*value (REAL variable)*)
  END_VAR
  VAR_OUTPUT
    out              : real;  (*copy of 'Value'*)
  END_VAR
  VAR
    GTSAP1_DISPLAY_name {PUBLIC_IFOX} : string [24];  (*Name of function block*)
    GTSAP1_DISPLAY_enable {PUBLIC_IFOX} : bool :=  1;  (*Command to display FB in iFoxtrot App*)
    GTSAP1_DISPLAY_edit {PUBLIC_IFOX} : bool :=  1;  (*Indication of editable value or not*)
    GTSAP1_DISPLAY_type {PUBLIC_IFOX} : usint :=  ICL_DISPLAY_TYPE_VALUE;  (*Display type (0=onOff, 1= real/uint value)*)
    GTSAP1_DISPLAY_symbol {PUBLIC_IFOX} : uint;  (*Icon in iFoxtrot App (APP_ICON_socket, ..)*)
    GTSAP1_DISPLAY_value {PUBLIC_IFOX} : real;  (*Value to display*)
    GTSAP1_DISPLAY_unit {PUBLIC_IFOX} : string [8];  (*Measurement unit (%,bar,C/F ...)*)
    GTSAP1_DISPLAY_precision {PUBLIC_IFOX} : int;  (*Precision of fraction part of Value*)
    GTSAP1_DISPLAY_url {PUBLIC_IFOX} : string [80];  (*Link (URL) to web page (graph, history ...)*)
    GTSAP1_DISPLAY_incValue {PUBLIC_IFOX} : bool;  (*Command from App iFoxtrot to increase desired value*)
    GTSAP1_DISPLAY_decValue {PUBLIC_IFOX} : bool;  (*Command from App iFoxtrot to decrease desired value*)
    GTSAP1_DISPLAY_valueSet {OPEN_UP} {PUBLIC_IFOX} : real :=  1E38;  (*tuhle promennou zapise iFoxtrot do JSON souboru kdyz je fb_iDisplay_Val_edit zarazen do sceny*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_iDisplay_OnOff
(*function block for display of boolean valriable (state)*)
  VAR_INPUT
    value            : bool;  (*value (BOOL variable)*)
    symbolOn         : uint;  (*icon in iFoxtrot App (APP_ICON_socket, ..)*)
    symbolOff        : uint;  (*icon in iFoxtrot App (APP_ICON_socket, ..)*)
    name             : string [24];  (*name*)
  END_VAR
  VAR_OUTPUT
    out              : bool;  (*copy of 'Value'                                   kopie 'Value'*)
  END_VAR
  VAR
    GTSAP1_DISPLAY_name {PUBLIC_IFOX} : string [24];  (*name of function block*)
    GTSAP1_DISPLAY_enable {PUBLIC_IFOX} : bool :=  1;  (*command to display FB in iFoxtrot App*)
    GTSAP1_DISPLAY_edit {PUBLIC_IFOX} : bool :=  0;
    GTSAP1_DISPLAY_type {PUBLIC_IFOX} : usint :=  ICL_DISPLAY_TYPE_ON_OFF;  (*display type (0=onOff, 1= real value)*)
    GTSAP1_DISPLAY_symbol {PUBLIC_IFOX} : uint;  (*icon in iFoxtrot App (APP_ICON_socket, ..)*)
    GTSAP1_DISPLAY_onOff {PUBLIC_IFOX} : bool;  (*Value (state) to display*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_iSensorTemp
(*function block for measurement of temperature (degrees of Celsius) including first order filter
   and posibility of temperature correction*)
  VAR_INPUT
    in               : real;  (*temperature (REAL variable)*)
    offset           : real;  (*correction of temperature*)
    filterTime       : time :=  T#30s;  (*time constant of filter*)
    name             : string [24];  (*name*)
  END_VAR
  VAR_OUTPUT
    out              : real;  (*out := filter( in + offset)*)
  END_VAR
  VAR
    GTSAP1_DISPLAY_name {PUBLIC_IFOX} : string [24];  (*Name of function block*)
    GTSAP1_DISPLAY_enable {PUBLIC_IFOX} : bool :=  1;  (*Icon in iFoxtrot App (APP_ICON_socket, ..)*)
    GTSAP1_DISPLAY_edit {PUBLIC_IFOX} : bool :=  0;  (*Indication of editable value or not*)
    GTSAP1_DISPLAY_type {PUBLIC_IFOX} : usint :=  ICL_DISPLAY_TYPE_VALUE;  (*Display type (0=onOff, 1=real value)*)
    GTSAP1_DISPLAY_symbol {PUBLIC_IFOX} : uint :=  100;  (*Command to display FB in iFoxtrot App*)
    GTSAP1_DISPLAY_value {PUBLIC_IFOX} : real;  (*Value to display*)
    GTSAP1_DISPLAY_unit {PUBLIC_IFOX} : string [8] :=  '°C';  (*Measurement unit (%,bar,C/F ...)*)
    GTSAP1_DISPLAY_precision {PUBLIC_IFOX} : int :=  1;  (*Precision of fraction part of Value*)
    filter           : fbFirstOrder;  (*filtr prvniho radu*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbHolidayCalendar {HIDDEN}
  VAR_INPUT
    vis              : bool;
    refr             : bool R_EDGE;
    webGuiSettings   : T_TIME_PROG_WEEK_WEB_SETTINGS;
  END_VAR
  VAR_OUTPUT
    butCancel        : bool;
    butSave          : bool;
    canvasOK         : bool;
    canvasLen        : uint;
  END_VAR
  VAR_IN_OUT
    canvasData       : TCanvasData1024;
    startHoliday     : dt;
    endHoliday       : dt;
  END_VAR
  VAR CONSTANT
    CC_width         : int :=  700;
    CC_width2        : int :=  CC_width /2;
    CC_width3        : int :=  CC_width /3;
    CC_width5        : int :=  CC_width /5;
    CC_width7        : int :=  CC_width /7;
    CC_width10       : int :=  CC_width /10;
    CC_width20       : int :=  CC_width /20;
    CC_height        : int :=  1000;
    CC_R             : int :=  CC_width /14;
    CC_textSize      : int :=  CC_height /25;  (*40*)
  END_VAR
  VAR
    fontColor        : udint;
    selectColor      : udint;
    visTrig          : R_TRIG;
    wasTouch         : bool;
    tecoDT           : TTecoDateTime;
    startDate        : dt;
    holIndex         : uint;
    holiday          : ARRAY [0..1] OF dt;
    today            : date;
    i                : int;
    d                : dt;
    m                : usint;
  END_VAR
END_FUNCTION_BLOCK

VAR_GLOBAL CONSTANT
 ICL_TPW_TYPE_HEATING : usint :=  1;
 ICL_TPW_TYPE_COOLING : usint :=  2;
 ICL_TPW_TYPE_HEATING_COOLING : usint :=  3;
 ICL_TPW_PREFIX : string [4] :=  'WTP_';
 ICL_TPW_FORMAT : string [8] :=  '%04X.JSN';
 ICL_TPW_JSN_EXT : string [8] :=  '.JSN';
 ICL_TPW_APP_EXT : string [8] :=  '.APP';
 ICL_TPW_BAK_EXT : string [8] :=  '.BAK';
 ICL_TPW_TMP_EXT : string [8] :=  '.TMP';
 ICL_TPW_ERR1 : string [26] :=  'Name of program is empty!';
 ICL_TPW_ERR2 : string [11] :=  ' not found!';
 ICL_TPW_ERR3 : string [19] :=  'Corrupted JSON file';
 ICL_TPW_ERR4 : string [23] :=  'No time program in JSON';
 ICL_TPW_KEYWORD : string [16] :=  'timeProgWeekData';

END_VAR

__DECL FUNCTION AddTextToRecord {HIDDEN} : udint
(*Add next part of record*)
  VAR_INPUT
    text             : string [80];
    ptrRec           : PTR_TO string [255];
  END_VAR
  VAR
    lenRec           : uint;
  END_VAR
END_FUNCTION

__DECL FUNCTION fc_TimeProgWeek_LoadDefault {HIDDEN} : bool
  VAR_INPUT
    units            : bool;  (*0 = °C, 1 = °F*)
    timeProgWeekData : PTR_TO T_TIME_PROG_WEEK;
  END_VAR
  VAR CONSTANT
    initTimeProg24x7data : T_TIME_PROG_WEEK :=  ( typ      := ICL_TPW_TYPE_HEATING_COOLING,
                                                 numTimes := 5,
                                                 heatTemp := [5.0,19.0,21.0,23.0],  // musi byt vzestupne
                                                 coolTemp := [33.0,28.0,25.0,24.0], // musi byt sestupne
                                                 times    := [T#0h0m0s, T#6h15m0s, T#8h0m0s,  T#15h00m0s, T#21h00m0s, T#24h0m0s, T#24h0m0s,
                                                              T#0h0m0s, T#6h15m0s, T#8h0m0s,  T#15h00m0s, T#21h00m0s, T#24h0m0s, T#24h0m0s,
                                                              T#0h0m0s, T#6h15m0s, T#8h0m0s,  T#15h00m0s, T#21h00m0s, T#24h0m0s, T#24h0m0s,
                                                              T#0h0m0s, T#6h15m0s, T#8h0m0s,  T#15h00m0s, T#21h00m0s, T#24h0m0s, T#24h0m0s,
                                                              T#0h0m0s, T#6h15m0s, T#8h0m0s,  T#15h00m0s, T#21h00m0s, T#24h0m0s, T#24h0m0s,
                                                              T#0h0m0s, T#7h15m0s, T#22h0m0s, T#24h00m0s, T#24h00m0s, T#24h0m0s, T#24h0m0s,
                                                              T#0h0m0s, T#7h15m0s, T#22h0m0s, T#24h00m0s, T#24h00m0s, T#24h0m0s, T#24h0m0s],
                                                 values   := [1,2,3,2,3,1,1,1,
                                                              1,2,3,2,3,1,1,1,
                                                              1,2,3,2,3,1,1,1,
                                                              1,2,3,2,3,1,1,1,
                                                              1,2,3,2,3,1,1,1,
                                                              1,2,3,2,1,1,1,1,
                                                              1,2,3,2,1,1,1,1],
                                                 holiday  := [DT#1970-01-01-00:00:00.0, DT#1970-01-01-00:00:00.0],   // dovolena <od, do>
                                                 crc      := 0);
  END_VAR
END_FUNCTION

__DECL FUNCTION_BLOCK fb_TimeProgWeek_LoadDataFromFile {HIDDEN}
  VAR_INPUT
    exec             : bool;
    units            : bool;  (*0 = °C, 1 = °F*)
    fileName         : string [24];
    timeProgName     : string [80];  (*jmeno promenne s casovym programem*)
    timeProgAdr      : udint;  (*adresa promenne s casovym programem*)
  END_VAR
  VAR_OUTPUT
    done             : bool;
    busy             : bool;
    lastErr          : string [80];  (*last error description*)
    rqSave           : bool;  (*ulozit po nacteni*)
    err              : bool;
  END_VAR
  VAR
    JsonParser {HIDDEN} : fbJsonFileParser;  (*FB pro pársování souboru*)
    json             : TJsonInfo;  (*struktura pro výsledky pársování*)
    res              : bool;
    isTimeProg24x7   : bool;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION ICL_GetVarNameByAdr {HIDDEN} : string [255]
(*Returns name of variable according to address of variable*)
  VAR_INPUT
    varAdr           : udint;  (*address of variable*)
    varSize          : udint;  (*size of variable (number of bytes)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION_BLOCK fb_TimeProgWeek_Basic {HIDDEN}
(*This block provides data storage and retrieval of time schedule to/from JSON file*)
  VAR_INPUT
    typ              : usint :=  ICL_TPW_TYPE_HEATING_COOLING;  (*time program type : ICL_TPW_TYPE_HEATING, ICL_TPW_TYPE_COOLING, ICL_TPW_TYPE_HEATING_COOLING*)
    numTimes         : usint;  (*number of time marks during the day*)
    units            : bool;  (*0 = °C, 1 = °F*)
    name             : string [24];  (*name of time program*)
    adrTimeProg      : udint;  (*address of variable timeProgWeekData*)
  END_VAR
  VAR_OUTPUT
    busy             : bool;  (*block is busy*)
    lastErr          : string [80];  (*last error description*)
    file             : string [12];  (*name of json file with description of time program*)
  END_VAR
  VAR
    WeekTimeProg24x7data_temp {OPEN_UP} {TRACK_ADR} : T_TIME_PROG_WEEK;
    TimeProgWeek_LoadDataFromFile {HIDDEN} : fb_TimeProgWeek_LoadDataFromFile;
    fb_CreatePath    : CreatePath;
    fb_WriteToFile   : WriteToFile;
    fb_ReadFromFile  : ReadFromFile;
    fileDesc         : TFileInfo;  (*struktura s informacemi o souboru*)
    jsonBuf          : ARRAY [0..1023] OF usint;  (*buffer pro sestaveni json souboru*)
    fileName         : string [24];
    fileName_app     : string [24];
    fileName_tmp     : string [24];
    fileName_bak     : string [24];
    extSaveRq        : bool;
    extCopyReadRq    : bool;
    extCopyWriteRq   : bool;
    extSaveToBAKRq   : bool;
    extSaveToJSNRq   : bool;
    extPowerUpLoadRq : bool :=  TRUE;
    extPowerUpLoadJSNRq : bool :=  TRUE;
    extPowerUpLoadBAKRq : bool;
    extSaveNewDataToJSNRq : bool :=  TRUE;
    extSaveNewDataToBAKRq : bool;
    extLoadTempDataRq : bool;
    last_units       : bool;
    last_crc         : uint;
    ptr              : PTR_TO usint;
    ptrTimeProgWeekData : PTR_TO T_TIME_PROG_WEEK;
    ptr_str          : PTR_TO string [80];
    crc              : uint;
    varBaseName      : string [80];
    iFoxPath         : string [20] :=  ICL_IFOX_PATH;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION CustomTimeProgTimToPos {HIDDEN} : int
  VAR_INPUT
    tim              : time;
    width            : int;
  END_VAR
END_FUNCTION

__DECL FUNCTION CustomTimeProgPosToTim {HIDDEN} : time
  VAR_INPUT
    pos              : int;
    width            : int;
    lim              : real;
    w                : real;
    t                : time;
  END_VAR
END_FUNCTION

__DECL FUNCTION_BLOCK fb_TimeProgWeek_Web {HIDDEN}
  VAR_INPUT
    adrTimeProg      : udint;
  END_VAR
  VAR_IN_OUT
    webGuiSettings   : T_TIME_PROG_WEEK_WEB_SETTINGS;
    canvasData       : TCanvasData1024;
  END_VAR
  VAR_OUTPUT
    canvasOK         : bool;
    canvasLen        : uint;
  END_VAR
  VAR CONSTANT
    C_HEAT_3         : udint :=  GCOLOR_RED_600;  (*16#182CDD;*)
    C_HEAT_2         : udint :=  GCOLOR_DEEP_ORANGE_500;  (*16#1958E2;*)
    C_HEAT_1         : udint :=  GCOLOR_ORANGE_600;  (*16#1B83E6;*)
    C_HEAT_0         : udint :=  GCOLOR_AMBER_400;  (*16#D9CE7E;*)
    C_COOL_3         : udint :=  GCOLOR_INDIGO_600;  (*16#DD7718;*)
    C_COOL_2         : udint :=  GCOLOR_BLUE_600;  (*16#E2A219;*)
    C_COOL_1         : udint :=  GCOLOR_LIGHT_BLUE_400;  (*16#E6D11B;*)
    C_COOL_0         : udint :=  GCOLOR_CYAN_200;  (*16#58AEFF;*)
    C_BUTTONS        : udint :=  GCOLOR_DEEP_PURPLE_500;
    C_BACKGR         : udint :=  16#686868;  (*== GCOLOR_GREY_650;*)
    C_LINE           : udint :=  GCOLOR_GREY_300;  (*16#E1E1E1;*)
    C_NUM_STEPS      : usint :=  4;  (*pocet teplot*)
    C_NUM_TIMES      : usint :=  7;  (*max. pocet casovych znacek za den*)
    C_HEAT_COLOR     : ARRAY [0..3] OF udint :=  [C_HEAT_0, C_HEAT_1, C_HEAT_2, C_HEAT_3];
    C_COOL_COLOR     : ARRAY [0..3] OF udint :=  [C_COOL_0, C_COOL_1, C_COOL_2, C_COOL_3];
    C_width          : int :=  500;
    C_width2         : int :=  C_width /2;
    C_width3         : int :=  C_width /3;
    C_width6         : int :=  C_width /6;
    C_4C_width6      : int :=  4*C_width6;
    C_5C_width6      : int :=  5*C_width6;
    C_width10        : int :=  C_width /10;
    C_width10_70     : int :=  C_width10 - C_width/70;  (*posun zacatku pri kresleni prvku do horni listy*)
    C_9C_width10     : int :=  9*C_width10;
    C_height         : int :=  350;
    C_hMarg          : int :=  3*C_width /20;
    C_hMarg2         : int :=  C_hMarg /2;
    C_hMarg4         : int :=  C_hMarg /4;
    C_wMarg          : int :=  C_width /20;
    C_wMarg2         : int :=  C_wMarg /2;
    C_hStep          : int :=  C_width /20;
    C_hStep2         : int :=  C_hStep /2;
    C_selDist        : int :=  C_width /20;
    C_textSize       : int :=  C_hMarg2 /3 -1;
    C_textSize2      : int :=  C_textSize /2;
    C_controlBar     : int :=  -70-C_hMarg2;
    C_R              : int :=  C_textSize*3 /2 +3;
    C_wb             : int :=  C_width /8 +5;
    C_wb2            : int :=  C_wb /2;
    C_wb4            : int :=  C_wb /4;
    C_ws             : int :=  C_width /7;
    C_ws2            : int :=  C_ws /2;
  END_VAR
  VAR
    numTimes         : usint;  (*pocet casovych znacek za den*)
    selLine          : int;
    selBlock         : int;
    selButton1       : int;
    C_delta          : real;
    endTime          : time :=  T#24h;
    actTim           : PTR_TO time;
    actTim2          : PTR_TO time;
    actTim3          : PTR_TO time;
    heatCool         : bool;  (*0 heating, 1 cooling*)
    wasTouch         : bool;
    rqSave           : bool;
    repaint          : bool;
    saveProg         : bool;
    counterInit      : bool;
    flgHoliday       : bool;
    copy             : int;
    counterTON       : TON;
    time_prog        : T_TIME_PROG_WEEK;  (*kopie casoveho programu*)
    ptr_time_prog    : PTR_TO T_TIME_PROG_WEEK;  (*ptr na casovy program*)
    disp             : usint :=  255;
    corrDist         : int;
    x_time           : int;
    lastTouchX       : int;
    lastTouchY       : int;
    lastCRC          : uint;
    HolidayCalendar {HIDDEN} : fbHolidayCalendar;
    triangle         : ARRAY [0..2] OF TCanvasPoint :=  [( x := 0,  y := 0), ( x := -5,  y := 9),( x := 5,  y := 9)];
    triangleUP       : ARRAY [0..2] OF TCanvasPoint :=  [( x := 0,  y := -7),( x := -7,  y := 6),( x := 7,  y := 6)];
    triangleDW       : ARRAY [0..2] OF TCanvasPoint :=  [( x := -7, y := -6),( x := 0,   y := 7),( x := 7,  y := -6)];
    canvasMax        : uint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_TimeProgWeek_Control {HIDDEN}
  VAR_INPUT
    onOff            : bool :=  TRUE;  (*rizeni zapnute/vypnute*)
    manPriority      : bool;  (*0 = rezim manual skonci pri 1.zmene casoveho programu, 1 = rezim manual se ukonci pouze prepnutim do auto*)
    roomTemp         : real;  (*teplota v mistnosti*)
    hyst             : real :=  0.1;  (*hystereze (necitlivost vystupu heat/cool) <0.0,0.5>*)
    webNextProg      : bool R_EDGE;  (*auto -> manual, manual -> auto*)
    webNextMode      : bool R_EDGE;  (*zmena rezimu v manualnim modu*)
    webIncDelta      : bool R_EDGE;
    webDecDelta      : bool R_EDGE;
    adrTimeProg      : udint;
  END_VAR
  VAR_IN_OUT
    settings         : T_TIME_PROG_WEEK_INTERFACE;
  END_VAR
  VAR_OUTPUT
    status           : T_TIME_PROG_WEEK_STAT;  (*stav rizeni*)
  END_VAR
  VAR
    GTSAP1_TPW_name {PUBLIC_IFOX} : string [24];
    GTSAP1_TPW_enable {PUBLIC_IFOX} : bool :=  1;
    GTSAP1_TPW_type {PUBLIC_IFOX} : usint;  (*typ casoveho programu*)
    GTSAP1_TPW_file {PUBLIC_IFOX} : string [24];
    GTSAP1_TPW_crc {PUBLIC_IFOX} : uint;  (*last valid crc of time program*)
    GTSAP1_TPW_update {PUBLIC_IFOX} : bool;  (*command from app to update week program data from file*)
    GTSAP1_TPW_manual {PUBLIC_IFOX} : bool;  (*0 = auto, 1 = manual*)
    GTSAP1_TPW_holiday {PUBLIC_IFOX} : bool;  (*0 = normal control, 1 = holiday (=> ECO mode)*)
    GTSAP1_TPW_heat {PUBLIC_IFOX} : bool;  (*pozadavek na topeni*)
    GTSAP1_TPW_cool {PUBLIC_IFOX} : bool;  (*pozadavek na chlazeni*)
    GTSAP1_TPW_roomTemp {PUBLIC_IFOX} : real;  (*teplota v mistnosti*)
    GTSAP1_TPW_heatTemp {PUBLIC_IFOX} : real;  (*pozadovana teplota topeni*)
    GTSAP1_TPW_coolTemp {PUBLIC_IFOX} : real;  (*pozadovana teplota chlazeni*)
    GTSAP1_TPW_mode {PUBLIC_IFOX} : sint;  (*zvoleny rezim ... 0 = limit, 1 = ECO, 2 = NIGHT {utlum), 3 = DAY (komfort)*)
    GTSAP1_TPW_delta {PUBLIC_IFOX} : real;  (*aktualni delta <-5.0, 5.0>*)
    GTSAP1_TPW_nextProg {PUBLIC_IFOX} : bool;  (*auto -> manual, manual -> auto*)
    GTSAP1_TPW_nextMode {PUBLIC_IFOX} : bool;  (*zmena rezimu v manualnim modu (ECO <-> NIGHT <-> DAY)*)
    GTSAP1_TPW_incDelta {PUBLIC_IFOX} : bool;  (*+0.5*)
    GTSAP1_TPW_decDelta {PUBLIC_IFOX} : bool;  (*-0.5*)
    GTSAP1_TPW_manualSet {OPEN_UP} {PUBLIC_IFOX} : sint :=  -1;  (*0 = auto, 1 = manual, -1=nenastaveno*)
    GTSAP1_TPW_modeSet {OPEN_UP} {PUBLIC_IFOX} : sint :=  -1;  (*0 = limit, 1 = ECO, 2 = NIGHT {utlum), 3 = DAY (komfort), -1=nenastaveno*)
    init             : bool;
    lastManual       : bool;
    numTimes         : usint;
    lastInterval     : usint;
    ptr_time_prog    : PTR_TO T_TIME_PROG_WEEK;
    incMode          : sint;
  END_VAR
END_FUNCTION_BLOCK

TYPE TCIB_CRC0011R_iTHERM_iRH :
  STRUCT
    iTHERM           : real;
    iRH              : usint;
  END_STRUCT;
END_TYPE

TYPE  TCIB_PAGING_ARRAY : ARRAY [0..4] OF byte;
END_TYPE

TYPE TCIB_C_RC_0011R_IN :
  STRUCT
    BUTTONS          : usint;
    iTHERM_iRH       : TCIB_CRC0011R_iTHERM_iRH;
    eTHERM           : real;
    PAGING {HIDDEN}  : TCIB_PAGING_ARRAY;
  END_STRUCT;
END_TYPE

TYPE  TCIB_CRC0011R_DATA : ARRAY [0..3] OF int;
END_TYPE

TYPE  TCIB_CRC0011R_DATA_TYPE : ARRAY [0..3] OF byte;
END_TYPE

TYPE TCIB_CRC0011R_VAL :
  STRUCT
    DATA             : TCIB_CRC0011R_DATA;
    DATA_TYPE        : TCIB_CRC0011R_DATA_TYPE;
  END_STRUCT;
END_TYPE

TYPE TCIB_CRC0011R_ICO :
  STRUCT
    BUTT_EDIT        : bool;
    BUTT_ESC         : bool;
    BUTT_OK          : bool;
    BUTT_DOWN        : bool;
    BUTT_UP          : bool;
    MODE_SUN         : bool;
    MODE_MOON        : bool;
    MODE_ECO         : bool;
    PROG_AUTOMAT     : bool;
    PROG_HAND        : bool;
    PROG_HOLIDAY     : bool;
    TEMP_INDOOR      : bool;
    TEMP_OUTDOOR     : bool;
    TEMP             : bool;
    FAN_0            : bool;
    FAN_1            : bool;
    FAN_2            : bool;
    FAN_3            : bool;
    FAN_AUTOMAT      : bool;
    HEATING          : bool;
    COOLING          : bool;
    WINDOW           : bool;
    LOCK             : bool;
    WARNING          : bool;
    DAY_1            : bool;
    DAY_2            : bool;
    DAY_3            : bool;
    DAY_4            : bool;
    DAY_5            : bool;
    DAY_6            : bool;
    DAY_7            : bool;
    LINE             : bool;
    RADIO_0          : bool;
    RADIO_1          : bool;
    RADIO_2          : bool;
    RADIO_3          : bool;
    RADIO_BATTERY    : bool;
    MAIN_VAL_C       : bool;
    MAIN_VAL_F       : bool;
    MAIN_VAL_RH      : bool;
    MAIN_VAL_PERC    : bool;
    MAIN_VAL_DOT     : bool;
    SEC_VAL_C        : bool;
    SEC_VAL_F        : bool;
    SEC_VAL_RH       : bool;
    SEC_VAL_PERC     : bool;
    SEC_VAL_COLON    : bool;
    SEC_VAL_DOT      : bool;
    SEC_VAL_DOT2     : bool;
    SEC_VAL_DOT3     : bool;
    SEC_VAL_AM       : bool;
    SEC_VAL_PM       : bool;
    ARROW            : bool;
    dummy53 {HIDDEN} : bool;
    dummy54 {HIDDEN} : bool;
    dummy55 {HIDDEN} : bool;
  END_STRUCT;
END_TYPE

TYPE TCIB_C_RC_0011R_OUT :
  STRUCT
    VAL              : TCIB_CRC0011R_VAL;
    ICO              : TCIB_CRC0011R_ICO;
    PAGING {HIDDEN}  : TCIB_PAGING_ARRAY;
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK fb_TimeProgWeek_C_RC_0011R {HIDDEN}
  VAR_INPUT
    adrTimeProg      : udint;  (*adresa timeProgWeekData*)
    fan              : usint;  (*ventilace*)
  END_VAR
  VAR_IN_OUT
    settings         : T_TIME_PROG_WEEK_INTERFACE;  (*nastaveni modulu*)
    C_RC_in          : TCIB_C_RC_0011R_IN;  (*vstupni struktura (data z modulu)*)
    C_RC_out         : TCIB_C_RC_0011R_OUT;  (*vystupni struktura (data pro modul)*)
  END_VAR
  VAR_OUTPUT
    warning          : usint;  (*chyba*)
  END_VAR
  VAR
    C_RC_inL         : TCIB_C_RC_0011R_IN;  (*predchozi vstupni struktura*)
    settingsL        : T_TIME_PROG_WEEK_INTERFACE;  (*predchozi nastaveni*)
    time_progL       : T_TIME_PROG_WEEK;  (*predchozi WTP*)
    ptr_time_prog    : PTR_TO T_TIME_PROG_WEEK;  (*pointer na WTP*)
    dateTime         : TTecoDateTime;  (*cas a datum*)
    fanL             : usint;  (*ventilace (fanCoil)*)
    warningL         : usint;  (*chyba*)
    confirmWait      : usint;  (*priznak cekani na potvrzeni prijmu (odpoved)*)
    noConfirmCnt     : usint;  (*mereni, pokud modul nedostal odpoved*)
    confirmType      : usint;  (*priznak naposledy odeslanych dat*)
    confirmCnt       : usint;  (*citac odpovedi (pro detekci zmeny - inkrementuje se po kazde odpovedi)*)
    newMess          : bool;  (*priznak novych vystupnich dat/odpoved, dalsi ceka ve fronte*)
    resetUpdate      : byte;  (*pozadavek modulu o nastaveni a cas*)
    paginL           : TCIB_PAGING_ARRAY;  (*zaloha vystupniho packetu*)
    edit             : bool;  (*priznak editace v modulu*)
    crc              : uint;
    fbBlock          : usint;  (*fb synchronizuje data s displejem jen v "Editacnim(Autonomni) rezimu" (0 nezinicializovano, 1 Editacni(Autonomni) rezim, 2 ostatni rezimy)*)
    settUpdate       : bool;  (*priznak zmeny nastaveni*)
    tempUpdate       : bool;  (*priznak zmeny teploty (offsetu)*)
    tempOffs         : real;  (*offset pozadovane teploty*)
    modulInit        : word;  (*inicializacni nastaveni modulu*)
    d                : uint;
    i                : uint;
    timeVar          : dint;
    hour             : dint;
    b                : byte;
    w                : word;
    dataInd          : ARRAY [0..1] OF uint;
    dayInd           : ARRAY [0..1] OF uint;
    holidDay         : usint;
    holidMonth       : usint;
    holidYear        : usint;
    holidString      : string [22];
    holidCompare     : string [22];
    dateVar          : TTecoDateTime;
  END_VAR
  VAR CONSTANT
    PAGE_TIME        : usint :=   2#001;  (*cas a datum*)
    PAGE_SETT        : usint :=   2#010;  (*nastaveni (prijem: mode, progr, fan, warning, vysilani: warning)*)
    PAGE_WTP         : usint :=   2#011;  (*tydenni casovy program*)
    PAGE_BOARD       : usint :=   2#100;  (*rozsirujici deska*)
    PAGE_TEMP        : usint :=   2#101;  (*pozadovana rucne nastavena teplota (offset)*)
    PAGE_RESET       : usint :=   2#110;  (*pozadavek modulu o nastaveni a cas (pri kazdem spusteni)*)
    PAGE_INIT        : usint :=   2#111;  (*inicializacni nastaveni modulu*)
    PAGE_EDIT        : byte :=  2#1000;  (*priznak editace*)
    WTP_M            : byte :=  2#1000;  (*priznak rezimu casoveho programu (jako PAGE_EDIT, dokud se neprenese cas.program, je zaroven signalizovana editace)*)
    WTP_T            : byte :=  2#0000;  (*priznak casu casoveho programu*)
    WTP_TEMP         : byte :=  2#10000000;  (*0 heating, 1 cooling*)
    WTP_TNUM         : byte :=  2#0001000;  (*pocet casovych znacek WTP*)
    WTP_END          : byte :=  2#0010000;  (*prenesena vsechna data pro WTP*)
    RESET_TIME       : byte :=  2#1;  (*pozadavek o cas*)
    RESET_SETT       : byte :=  2#10;  (*pozadavek o nastaveni*)
    T_TEMPER         : byte :=  16#1;  (*teplota*)
    T_TEMPER_INPUT   : byte :=  16#2;  (*vnitrni teplota*)
    T_TEMPER_OUTPUT  : byte :=  16#3;  (*vnejsi teplota*)
    T_HUMIDITY       : byte :=  16#4;  (*vnitrni vlhkost*)
    T_TIME           : byte :=  16#5;  (*cas (jen vedl.hodnota)*)
    T_AM             : byte :=  16#20;  (*'am' u casu (jen u vedl.hodnoty)*)
    T_PM             : byte :=  16#40;  (*'pm' u casu (jen u vedl.hodnoty)*)
    T_DECIMAL_POINT  : byte :=  16#80;  (*desetinna tecka*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_iTimeProgWeek
(*Heating/cooling control according to the weekly time program
  Time program settings from a web page or from the C-RC-0011R
  Control of heating/cooling from the web page or from the C-RC-0011R
  Automatically working together with iFoxtrot application*)
  VAR_INPUT
    onOff            : bool :=  TRUE;  (*control on/off*)
    units            : bool;  (*temperature units 0 = °C, 1 = °F*)
    manPriority      : bool;  (*manual mode priority*)
    roomTemp         : real;  (*temperature*)
    hyst             : real :=  0.1;  (*hysteresis of output heat/cool*)
    typ              : usint :=  ICL_TPW_TYPE_HEATING_COOLING;  (*time program type : ICL_TPW_TYPE_HEATING, ICL_TPW_TYPE_COOLING, ICL_TPW_TYPE_HEATING_COOLING*)
    numTimes         : usint;  (*number of time marks during the day*)
    webNextProg      : bool R_EDGE;  (*web control auto<->manual*)
    webNextMode      : bool R_EDGE;  (*web control ECO->NIGHT->COMFORT*)
    webIncDelta      : bool R_EDGE;  (*web control increase setpoint*)
    webDecDelta      : bool R_EDGE;  (*web control decrease setpoint*)
    name             : string [24];  (*name of time program*)
  END_VAR
  VAR_IN_OUT
    TimeProg_Settings : T_TIME_PROG_WEEK_INTERFACE;  (*block state*)
    TimeProg_webSettings : T_TIME_PROG_WEEK_WEB_SETTINGS;  (*text settings for web interface*)
    C_RC_in          : TCIB_C_RC_0011R_IN;  (*input data from module C-RC-0011R*)
    C_RC_out         : TCIB_C_RC_0011R_OUT;  (*output data for module C-RC-0011R*)
  END_VAR
  VAR_OUTPUT
    heat             : bool;  (*heating requirement*)
    cool             : bool;  (*cooling requirement*)
    heatTemp         : real;  (*requested temperature of heating*)
    coolTemp         : real;  (*requested temperature of cooling*)
    webStatus        : T_TIME_PROG_WEEK_STAT;  (*state of control (for web)*)
    busy             : bool;  (*block is busy with json file*)
    lastErr          : string [80];  (*last error description*)
    jsonFile         : string [12];  (*name of json file with description of time program*)
    timeProgWeekData {OPEN_UP} {TRACK_ADR} : T_TIME_PROG_WEEK;  (*the weekly time program*)
    canvasData       : TCanvasData1024;  (*canvas data*)
  END_VAR
  VAR
    TimeProgBasic    : fb_TimeProgWeek_Basic;
    TimeProgWeb      : fb_TimeProgWeek_Web;
    TimeProgControl  : fb_TimeProgWeek_Control;
    TimeProgDevice   : fb_TimeProgWeek_C_RC_0011R;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_iTimeProgWeek1
(*Heating/cooling control according to the weekly time program
  Time program settings from a web page
  Control of heating/cooling from the web page
  Automatically working together with iFoxtrot application*)
  VAR_INPUT
    onOff            : bool :=  TRUE;  (*control on/off*)
    units            : bool;  (*temperature units 0 = °C, 1 = °F*)
    manPriority      : bool;  (*manual mode priority*)
    roomTemp         : real;  (*temperature*)
    hyst             : real :=  0.1;  (*hysteresis of output heat/cool*)
    typ              : usint :=  ICL_TPW_TYPE_HEATING_COOLING;  (*time program type : ICL_TPW_TYPE_HEATING, ICL_TPW_TYPE_COOLING, ICL_TPW_TYPE_HEATING_COOLING*)
    numTimes         : usint;  (*number of time marks during the day*)
    webNextProg      : bool R_EDGE;  (*web control auto<->manual*)
    webNextMode      : bool R_EDGE;  (*web control ECO->NIGHT->COMFORT*)
    webIncDelta      : bool R_EDGE;  (*web control increase setpoint*)
    webDecDelta      : bool R_EDGE;  (*web control decrease setpoint*)
    name             : string [24];  (*name of time program*)
  END_VAR
  VAR_IN_OUT
    TimeProg_Settings : T_TIME_PROG_WEEK_INTERFACE;  (*block state*)
    TimeProg_webSettings : T_TIME_PROG_WEEK_WEB_SETTINGS;  (*text settings for web interface*)
  END_VAR
  VAR_OUTPUT
    heat             : bool;  (*heating requirement*)
    cool             : bool;  (*cooling requirement*)
    heatTemp         : real;  (*requested temperature of heating*)
    coolTemp         : real;  (*requested temperature of cooling*)
    webStatus        : T_TIME_PROG_WEEK_STAT;  (*state of control*)
    busy             : bool;  (*block is busy with json file*)
    lastErr          : string [80];  (*last error description*)
    jsonFile         : string [12];  (*name of json file with description of time program*)
    timeProgWeekData {OPEN_UP} {TRACK_ADR} : T_TIME_PROG_WEEK;  (*the weekly time program*)
    canvasData       : TCanvasData1024;  (*canvas data*)
  END_VAR
  VAR
    TimeProgBasic    : fb_TimeProgWeek_Basic;
    TimeProgWeb      : fb_TimeProgWeek_Web;
    TimeProgControl  : fb_TimeProgWeek_Control;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_iTimeProgWeek2
(*Heating/cooling control according to the weekly time program
  Time program settings from the C-RC-0011R
  Control of heating/cooling from the web page or from the C-RC-0011R
  Automatically working together with iFoxtrot application*)
  VAR_INPUT
    onOff            : bool :=  TRUE;  (*control on/off*)
    units            : bool;  (*temperature units 0 = °C, 1 = °F*)
    manPriority      : bool;  (*manual mode priority*)
    roomTemp         : real;  (*temperature*)
    hyst             : real :=  0.1;  (*hysteresis of output heat/cool*)
    typ              : usint :=  ICL_TPW_TYPE_HEATING_COOLING;  (*time program type : ICL_TPW_TYPE_HEATING, ICL_TPW_TYPE_COOLING, ICL_TPW_TYPE_HEATING_COOLING*)
    numTimes         : usint;  (*number of time marks during the day*)
    webNextProg      : bool R_EDGE;  (*web control auto<->manual*)
    webNextMode      : bool R_EDGE;  (*web control ECO->NIGHT->COMFORT*)
    webIncDelta      : bool R_EDGE;  (*web control increase setpoint*)
    webDecDelta      : bool R_EDGE;  (*web control decrease setpoint*)
    name             : string [24];  (*name of time program*)
  END_VAR
  VAR_IN_OUT
    TimeProg_Settings : T_TIME_PROG_WEEK_INTERFACE;  (*block state*)
    C_RC_in          : TCIB_C_RC_0011R_IN;  (*input data from module C-RC-0011R*)
    C_RC_out         : TCIB_C_RC_0011R_OUT;  (*output data for module C-RC-0011R*)
  END_VAR
  VAR_OUTPUT
    heat             : bool;  (*heating requirement*)
    cool             : bool;  (*cooling requirement*)
    heatTemp         : real;  (*requested temperature of heating*)
    coolTemp         : real;  (*requested temperature of cooling*)
    webStatus        : T_TIME_PROG_WEEK_STAT;  (*state of control*)
    busy             : bool;  (*block is busy with json file*)
    lastErr          : string [80];  (*last error description*)
    jsonFile         : string [12];  (*name of json file with description of time program*)
    timeProgWeekData {OPEN_UP} {TRACK_ADR} : T_TIME_PROG_WEEK;  (*the weekly time program*)
  END_VAR
  VAR
    TimeProgBasic    : fb_TimeProgWeek_Basic;
    TimeProgControl  : fb_TimeProgWeek_Control;
    TimeProgDevice   : fb_TimeProgWeek_C_RC_0011R;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_iTimeProgWeek3
(*Heating/cooling control according to the weekly time program
  Control of heating/cooling from the web page or from iFoxtrot application
  Time program settings from application iFoxtrot only*)
  VAR_INPUT
    onOff            : bool :=  TRUE;  (*control on/off*)
    units            : bool;  (*temperature units 0 = °C, 1 = °F*)
    manPriority      : bool;  (*manual mode priority*)
    roomTemp         : real;  (*temperature*)
    hyst             : real :=  0.1;  (*hysteresis of output heat/cool*)
    typ              : usint :=  ICL_TPW_TYPE_HEATING_COOLING;  (*time program type : ICL_TPW_TYPE_HEATING, ICL_TPW_TYPE_COOLING, ICL_TPW_TYPE_HEATING_COOLING*)
    numTimes         : usint;  (*number of time marks during the day*)
    webNextProg      : bool R_EDGE;  (*web control auto<->manual*)
    webNextMode      : bool R_EDGE;  (*web control ECO->NIGHT->COMFORT*)
    webIncDelta      : bool R_EDGE;  (*web control increase setpoint*)
    webDecDelta      : bool R_EDGE;  (*web control decrease setpoint*)
    name             : string [24];  (*name of time program*)
  END_VAR
  VAR_IN_OUT
    TimeProg_Settings : T_TIME_PROG_WEEK_INTERFACE;  (*block state*)
  END_VAR
  VAR_OUTPUT
    heat             : bool;  (*heating requirement*)
    cool             : bool;  (*cooling requirement*)
    heatTemp         : real;  (*requested temperature of heating*)
    coolTemp         : real;  (*requested temperature of cooling*)
    webStatus        : T_TIME_PROG_WEEK_STAT;  (*state of control*)
    busy             : bool;  (*block is busy with json file*)
    lastErr          : string [80];  (*last error description*)
    jsonFile         : string [12];  (*name of json file with description of time program*)
    timeProgWeekData {OPEN_UP} {TRACK_ADR} : T_TIME_PROG_WEEK;  (*the weekly time program*)
  END_VAR
  VAR
    TimeProgBasic    : fb_TimeProgWeek_Basic;
    TimeProgControl  : fb_TimeProgWeek_Control;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_iFan
(*Fan control*)
  VAR_INPUT
    fanOn            : bool R_EDGE;  (*turn on the fan*)
    levelUp          : bool R_EDGE;  (*raise the level*)
    fanOff           : bool R_EDGE;  (*turn off the fan*)
    levelDw          : bool R_EDGE;  (*reduce the level*)
    fanToggle        : bool R_EDGE;  (*toggle the fan*)
    webToggle        : bool R_EDGE;  (*toggle the fan from web page*)
    setRamp          : time :=  T#8s;  (*ramp Up/Dw from min level to 100%  [sec]*)
    offOnRamp        : time :=  T#5s;  (*ramp Off/On from min level to 100% [sec]*)
    timeLimit        : time;  (*maximum time limit fan [sec]*)
    step             : real :=  20.0;  (*change value*)
    name             : string [24];  (*name of the fan*)
  END_VAR
  VAR_IN_OUT
    setLevel         : real;  (*the last set level (place the variable in the VAR_GLOBAL RETAIN)*)
  END_VAR
  VAR_OUTPUT
    out              : bool;  (*indication Off/On*)
    level            : real;  (*level 0..100[%]*)
    fbPtr            : udint;  (*function block pointer*)
  END_VAR
  VAR
    GTSAP1_FAN_name {PUBLIC_IFOX} : string [24];  (*name of function block*)
    GTSAP1_FAN_enable {PUBLIC_IFOX} : bool :=  1;  (*command to display FB in iFoxtrot App*)
    GTSAP1_FAN_onoff {OPEN_UP} {PUBLIC_IFOX} : bool;  (**)
    GTSAP1_FAN_level {OPEN_UP} {PUBLIC_IFOX} : real;  (**)
    gtsap1_old       : real;  (*pro vyhodnoceni zmeny od mobilni aplikace*)
    oldSetLevel      : real;  (*pro vyhodnoceni zmeny retain promenne*)
    toggleOn         : bool;  (*pomocna pro zapnuti*)
    toggleOff        : bool;  (*pomocna pro vypnuti*)
    lastSL52         : udint;
    tim              : TON;  (*casovac pro omezeni doby osvetleni*)
    levelChange      : usint;  (*pomocna pro zmenu*)
  END_VAR
END_FUNCTION_BLOCK

VAR_GLOBAL CONSTANT
 CRC0006R_SIZE_NAME : int :=   6;

END_VAR

TYPE  TCIB_PAGING_ARR : ARRAY [0..4] OF byte;
END_TYPE

TYPE TCIB_CRC0006R_STAT :
  STRUCT
    OUFT             : bool;
    VLDT             : bool;
    OUFR             : bool;
    VLDR             : bool;
    OUFL             : bool;
    VLDL             : bool;
    OUF1             : bool;
    VLD1             : bool;
    OUF2             : bool;
    VLD2             : bool;
    dummy10 {HIDDEN} : bool;
    dummy11 {HIDDEN} : bool;
    dummy12 {HIDDEN} : bool;
    dummy13 {HIDDEN} : bool;
    dummy14 {HIDDEN} : bool;
    dummy15 {HIDDEN} : bool;
  END_STRUCT;
END_TYPE

TYPE TCIB_CRC0006R_DI :
  STRUCT
    DI1              : bool;
    DI2              : bool;
    CLICK_DI1        : bool;
    CLICK_DI2        : bool;
    PRESS_DI1        : bool;
    PRESS_DI2        : bool;
    dummy6 {HIDDEN}  : bool;
    dummy7 {HIDDEN}  : bool;
  END_STRUCT;
END_TYPE

TYPE TCIB_C_RC_0006R_IN :
  STRUCT
    DI               : TCIB_CRC0006R_DI;
    PAGING {HIDDEN}  : TCIB_PAGING_ARR;
    BUTTONS          : usint;
    STAT             : TCIB_CRC0006R_STAT;
    THERM            : real;
    RH               : usint;
    LIGHT            : usint;
    AI1              : real;
    AI2              : real;
  END_STRUCT;
END_TYPE

TYPE TCIB_C_RC_0006R_OUT :
  STRUCT
    MODUL_SETT       : byte;
    PAGING {HIDDEN}  : TCIB_PAGING_ARR;
  END_STRUCT;
END_TYPE

TYPE TIRELAY_UNIT :
  STRUCT
    webToggle        : bool;  (*relay toggle*)
    name             : string [6];  (*name*)
    out              : bool;  (*relay control*)
    fbPtr {HIDDEN}   : udint :=  1;  (*function block pointer*)
  END_STRUCT;
END_TYPE

TYPE TIFAN_UNIT :
  STRUCT
    name             : string [6];  (*name*)
    setLevel         : real;  (**)
    fbPtr {HIDDEN}   : udint :=  1;  (*function block pointer*)
  END_STRUCT;
END_TYPE

TYPE TISCENE8_UNIT :
  STRUCT
    scene1On         : bool;  (*set up scene 1*)
    scene2On         : bool;  (*set up scene 2*)
    scene3On         : bool;  (*set up scene 3*)
    scene4On         : bool;  (*set up scene 4*)
    scene5On         : bool;  (*set up scene 5*)
    scene6On         : bool;  (*set up scene 6*)
    scene7On         : bool;  (*set up scene 7*)
    scene8On         : bool;  (*set up scene 8*)
    name             : string [6];  (*name*)
    scene            : usint;  (*activ scene*)
    fbPtr {HIDDEN}   : udint :=  1;  (*function block pointer*)
  END_STRUCT;
END_TYPE

TYPE TIJALOUSIE_UNIT :
  STRUCT
    rotUp            : bool;  (*step up*)
    up               : bool;  (*move up*)
    rotDw            : bool;  (*step down*)
    dw               : bool;  (*move down*)
    name             : string [6];  (*name*)
    posit            : usint;  (*jalousie position*)
    fbPtr {HIDDEN}   : udint :=  1;  (*function block pointer*)
  END_STRUCT;
END_TYPE

TYPE TIDIMMER_UNIT :
  STRUCT
    webToggle        : bool;  (*control lights from web page*)
    name             : string [6];  (*name*)
    setLevel         : real;  (*last level (this variable have to be RETAIN)*)
    out              : bool;  (*indication Off/On*)
    fbPtr {HIDDEN}   : udint :=  1;  (*function block pointer*)
  END_STRUCT;
END_TYPE

TYPE T_ICONTROL_BOSE_PARAM :
  STRUCT
    enabled          : bool;  (*false - zakázáno, true - povoleno*)
    name             : string [32];  (*Name of BOSE device*)
  END_STRUCT;
END_TYPE

TYPE T_ICONTROL_BOSE_COM_STATE :
  STRUCT
    found            : bool;  (*Result of multicast transmission: true-found, false-not found*)
    ip_adr           : TIPadr;  (*IP address of BOSE device collected from multicast transmission*)
    comm_err         : bool :=   true;  (*Indicator of device connection state: true-disconnected, false-connected*)
    last_comm_err {HIDDEN} : usint :=   5;
  END_STRUCT;
END_TYPE

TYPE T_ICONTROL_BOSE_DEVICE_STATE :
  STRUCT
    volume           : usint;  (*Current volume level 0-100%*)
    state            : usint;  (*Operation state 0 - unknown, 1-play, 2-pause, 3-stop, 4-buffering, 5-URLS*)
    mute             : bool;  (*Indicator if volume muted*)
    play             : bool;  (*Play function is active*)
    pause            : bool;  (*Pause function is active*)
    buffering        : bool;  (*Buffering data (preparng to start)*)
    standby          : bool;  (*Power indicator, true-turned off, false-turned on*)
    station_name     : string [32];  (*Last radio station name preseted*)
    ip_str           : string [16];  (*Device IP address in string format*)
  END_STRUCT;
END_TYPE

TYPE T_ICONTROL_BOSE_CONTROL :
  STRUCT
    volUp            : bool;
    volDw            : bool;
    mute             : bool;  (*Command to mute volume*)
    play             : bool;  (*Command to play*)
    pause            : bool;  (*Command to pause*)
    power            : bool;  (*Command to turn on/off*)
    preset_1         : bool;  (*Command to set audio source internet radio and preset station 1*)
    preset_2         : bool;  (*Command to set audio source internet radio and preset station 2*)
    preset_3         : bool;  (*Command to set audio source internet radio and preset station 3*)
    preset_4         : bool;  (*Command to set audio source internet radio and preset station 4*)
    preset_5         : bool;  (*Command to set audio source internet radio and preset station 5*)
    preset_6         : bool;  (*Command to set audio source internet radio and preset station 6*)
    sourceAUX        : bool;  (*Command to set audio source AUX*)
    sourceBLUETOOTH  : bool;  (*Command to set audio source BLUETOOTH*)
  END_STRUCT;
END_TYPE

TYPE T_ICONTROL_BOSE_UNIT :
  STRUCT
    param            : T_ICONTROL_BOSE_PARAM;
    com_state        : T_ICONTROL_BOSE_COM_STATE;
    device_state     : T_ICONTROL_BOSE_DEVICE_STATE;
    control          : T_ICONTROL_BOSE_CONTROL;
  END_STRUCT;
END_TYPE

TYPE  T_ICONTROL_BOSE_UNIT_LIST : ARRAY [0..9] OF T_ICONTROL_BOSE_UNIT;
END_TYPE

__DECL FUNCTION_BLOCK fb_C_RC_0006R
(*Control of the modul C-RC-0006R*)
  VAR_INPUT
    master           : bool :=  0;  (*Master module*)
    iDimmer_1        : udint :=  0;  (*Light dimmer 1*)
    iDimmer_2        : udint :=  0;  (*Light dimmer 2*)
    iDimmer_3        : udint :=  0;  (*Light dimmer 3*)
    iDimmer_4        : udint :=  0;  (*Light dimmer 4*)
    iDimmer_5        : udint :=  0;  (*Light dimmer 5*)
    iDimmer_6        : udint :=  0;  (*Light dimmer 6*)
    iDimmer_7        : udint :=  0;  (*Light dimmer 7*)
    iDimmer_8        : udint :=  0;  (*Light dimmer 8*)
    iDimmer_9        : udint :=  0;  (*Light dimmer 9*)
    iDimmer_10       : udint :=  0;  (*Light dimmer 10*)
    iDimmer_11       : udint :=  0;  (*Light dimmer 11*)
    iDimmer_12       : udint :=  0;  (*Light dimmer 12*)
    iJalousie_1      : udint :=  0;  (*Jalousie 1*)
    iJalousie_2      : udint :=  0;  (*Jalousie 2*)
    iJalousie_3      : udint :=  0;  (*Jalousie 3*)
    iJalousie_4      : udint :=  0;  (*Jalousie 4*)
    iJalousie_5      : udint :=  0;  (*Jalousie 5*)
    iJalousie_6      : udint :=  0;  (*Jalousie 6*)
    iJalousie_7      : udint :=  0;  (*Jalousie 7*)
    iJalousie_8      : udint :=  0;  (*Jalousie 8*)
    iScene8          : udint :=  0;  (*Scene control*)
    iFan_1           : udint :=  0;  (*Ventilation control 1*)
    iFan_2           : udint :=  0;  (*Ventilation control 2*)
    iRelay           : udint :=  0;  (*Relay output control*)
    AudioControl     : udint :=  0;  (*Audio control*)
    temp             : real;  (*Temperature*)
    RH               : usint;  (*Humidity*)
    CO2              : uint;  (*CO2 concentrations*)
  END_VAR
  VAR_IN_OUT
    reqTemp          : real;  (*requested temperature*)
    modul_in         : TCIB_C_RC_0006R_IN;  (**)
    modul_out        : TCIB_C_RC_0006R_OUT;  (**)
  END_VAR
  VAR
    inPaging         : TCIB_PAGING_ARR;  (*vstupni buffer*)
    outPaging        : TCIB_PAGING_ARR;  (*vystupni buffer*)
    pagingBackup     : TCIB_PAGING_ARR;  (*buffer pro odlozeni neodeslanych dat*)
    confirmWait      : usint;  (*priznak cekani na potvrzeni prijmu (odpoved)*)
    confirmType      : byte;  (*priznak naposledy odeslanych dat*)
    confirmCnt       : usint;  (*citac odpovedi (pro detekci zmeny - inkrementuje se po kazde odpovedi)*)
    confirmTimer     : usint;  (*casovac cekani na odpoved*)
    newMess          : bool;  (*priznak novych vystupnich dat/odpoved, dalsi ceka ve fronte*)
    resetUpdate      : byte;  (*pozadavek modulu o data, nastaveni, cas ...*)
    i                : usint;
    init             : byte;  (*inicializace: bit0 obecne, bit1 svetla, bit1 zaluzie, bit3 sceny*)
    initOffs         : usint;
    ptrToInput       : PTR_TO udint;
    ptrToUdint       : PTR_TO udint;
    ptrToReal        : PTR_TO real;
    ptrToByte        : PTR_TO byte;
    ptrToData        : PTR_TO byte;
    DateTime         : TTecoDateTime;  (*cas a datum*)
    size             : udint;
    id               : usint;
    cmd              : byte;
    iDimmer          : ARRAY [0..11] OF PTR_TO fb_iDimmer;
    fb               : PTR_TO fb_iDimmer;
    iScene           : PTR_TO fb_iScene8;
    iJalous          : ARRAY [0..7] OF PTR_TO fb_iJalousie;
    relay            : PTR_TO fb_iRelay;
    vent             : PTR_TO fb_iFan;
    fancoil          : PTR_TO fb_iFan;
    lightLevel       : ARRAY [0..11] OF real;  (*stmivani az 12 svetel*)
    lightSet         : ARRAY [0..11] OF byte;  (*ovladani az 12 svetel*)
    lightNum         : usint;  (*pocet zapojenych svetel*)
    lightTimeout     : int;
    setScene         : byte;
    jalousiePos      : ARRAY [0..7] OF usint;  (*stav az 8 zaluzii (polona v %)*)
    jalousieNum      : usint;  (*pocet zapojenych zaluzii*)
    jalousieOffs     : usint;
    unitListPtr      : PTR_TO T_ICONTROL_BOSE_UNIT_LIST;
    boseUnitsNum     : usint;
    boseUnits_volume : ARRAY [0..9] OF usint;
    boseUnits_mute   : ARRAY [0..9] OF bool;
    boseUnits_play   : ARRAY [0..9] OF bool;
    boseUnits_pause  : ARRAY [0..9] OF bool;
    boseUnits_standby : ARRAY [0..9] OF bool;
    audioState       : byte;
    dataOut          : ARRAY [0..11] OF byte;
    dataOutPrev      : ARRAY [0..11] OF byte;
    dataIn           : ARRAY [0..4] OF byte;
    str              : string [6];
  END_VAR
  VAR CONSTANT
    CONFIRM_TIMEOUT  : usint :=  20;
    FANLIMIT         : usint :=  5;
    LIGHT_MAX        : usint :=  12;
    JALOUSIE_MAX     : usint :=  8;
    BOSE_UNITS_MAX   : usint :=  10;
    DATA_BYTE_LEN    : usint :=  12;
    COMM_LIGHT       : byte :=  1;
    COMM_SCENE       : byte :=  2;
    COMM_JALOUS      : byte :=  3;
    COMM_HEATCOOL    : byte :=  4;
    COMM_AUDIO       : byte :=  5;
    COMM_DATA        : byte :=  6;
    COMM_RESET       : byte :=  7;
    COMM_INIT        : byte :=  8;
    COMM_NAMES       : byte :=  9;
    DATA_TIME        : byte :=  1;
    DATA_TEMP        : byte :=  2;
    DATA_TEMP_REF    : byte :=  3;
    DATA_RH          : byte :=  4;
    DATA_CO2         : byte :=  5;
    RESET_DATA       : byte :=  16#01;  (*pozadavek o data*)
    RESET_LIGHT      : byte :=  16#02;  (*pozadavek o nastaveni svetel*)
    RESET_JALOUS     : byte :=  16#04;  (*pozadavek o nastaveni zaluzii*)
    RESET_SCENE      : byte :=  16#08;  (*pozadavek o nastaveni scen*)
    RESET_NAMES      : byte :=  16#10;  (*pozadavek o nazev iFan*)
    RESET_AUDIO      : byte :=  16#20;  (*pozadavek o nazev iFan*)
    RESET            : byte :=  16#40;  (*reset*)
  END_VAR
END_FUNCTION_BLOCK



{LIBFILE="LOCALLIB\MODBUSRTU_V36_20190430.MLB"}
(* Mosaic IDE library *)
(* File name : D:\TecoUserLibs\ModbusRTU_V36_20190430.mlb *)
(* Library : ModbusRTU 3.6 *)
(* Author : Teco a.s. *)
(* Copyright : Teco (c) 2011 - 2019 *)
(* IEC compiler version : 4.2.2.2 *)
(* Assembler version : 4.3.00 *)

//{Knihovna : ModbusRTU 3.6  }
(* History: *)
(*
v1.2 2010-02-18 pet - seamless connection of ErrorCode from ComLib function 
RecvFrom() 
     2010-02-18 nem - new behavior of output Done (see FB ModbusRTUmas())
v1.3 2010-08-17 nem - new function block ModbusTCPmas() and new function 
                      ModbusCmdTCP()
     2010-09-02 nem - Dependency on the libraries added. 
                      Library requires Mosaic version 2.0.25 or higher
v1.4 2010-11-19 pet - switched depending on the libraries 
                      works with all versions of Mosaic
v1.5 2010-12-06 pet - Adjusted comments
v1.6 2011-09-06 nem - item UnitID added to structure TCmdStructTCP
v1.7 2013-08-21 byd - Adjusted max. length DataR a DataT +6 byte,  
added test COM_ERR5, adjusted RecvFrom(lenRx := 255 +6 -k)
v1.8 2013-08-27 byd - Adjusted max. length for Write Multiple Registers to 123 
objects
v1.9 2013-10-03 byd - Added clearing of unused bits in answers to Read Coils and 
Read Discrete Inputs
                      Fixed flags of reading and writing and counter of messages in 
blocks fbModbusTCPslave and fbModbusRTUslave 
		      Read Coils and Read Discrete Inputs returns only number of 
read bits according to request (before it returned number of bits round up to whole 
eights)
v2.0 2013-10-08 byd - Fixed order of bytes in reply from fbModbusTCPslave
v2.1 2014-09-30 byd - Fixed length of answer to Force Single Coil
                      Fixed manual mode in Opraven manuální reim v ModbusCmdTCP()
v2.2 2015-02-12 byd - Supressed detection of ETH connection in FB ModbusRTUmas()
v2.3 2015-03-09 byd - GetModbusErrTxt returns text for 16#C6 error - Invalid channel 
mode
v2.4 2015-05-11 byd - fixed error from version 2.2, which caused ModbusTCPmas not 
working
v2.5 2015-07-09 byd - added information about address and quantitny of objects 
read/written by function block fbModbusTCPslave and fbModbusRTUslave
v2.6 2015-07-10 byd - improved work with pointers
v2.7 2015-08-20 byd - added possibility to run a command in the same cycle, in which 
is a block ModbusTCPmas enabled by input EN in manual mode
v2.8 2015-09-01 byd - added blocks with delay between messages
v2.9 2016-10-03 byd - type for number of commands changed from SINT to USINT for function block fbModbusRTUmas2
v3.0 2016-10-17 byd - fbModbusRTUmas2 fix error, when there was no delay between commands after detecting error on reception
v3.1 2017-04-18 byd - added support for function Mask Write Register
                      changed setting of IP address in function blocks ModbusTCPmas and fbModbusTCPmas2, so it's no longer influenced by UNI connection settings
v3.2 2017-11-03 byd - added block fbModbusUDPmas for Modbus UDP
                      removed intermediate states prolonging delays between receiving and transmitting in all blocks
v3.3 2018-01-09 byd - fixed endless loop when commands did't contain any comnand to be selected by GrSel (from version 3.2)
v3.4 2018-04-03 byd - removed limitation of Modbus TCP master to run only on ETH1 interface. Now it can run on ETH2, ETH3,... if the IP address and port is set in HW configuration (IP address in ModbusCmdTCP is ignored)
v3.5 2019-01-23 byd - fbModbusTCPslave changes port even if there is a active connection
v3.6 2019-30-04 byd - function blocks fbModbusRTUmas and fbModbusRTUmas2 doesn't close connection when reply from slave device contains exception
*)

(*----------------------------------------------------------------------------*)

TYPE TCmdStruct :
  STRUCT  (*Structure for control of Modbus RTU master FB Struktura pro øízení funkèního bloku Modbus RTU master*)
    Gr               : usint;  (*The command can be grouped for sending an auto mode or manual mode..*)
    SNo              : usint;  (*Station number of slave device 1 to 247  (0 is broadcast)*)
    FNC              : usint;  (*Command code Modbus 01,02,03,04,05,06,15,16,17,22*)
    StAdr            : uint;  (*Address of Modbus object 0000..65535 (Coil,InpBits,InpRegs,HoldRegs)*)
    NoPoint          : uint;  (*Number of data types (BOOL or WORD) to be read or written*)
    PtrData          : udint;  (*Pointer to sent or received data (ARRAY[] OF BOOL or ARRAY[] OF INT)*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION ModbusCmd : bool
(*The Function writes communication parameters into array of commands.
  Communication with Modbus slave devices will be controlled by this array.
  This function prepares commands for function block ModbusRTUmas() and fbModbusRTUmas2.
  Function returns TRUE if Gr is not equal to zero*)
  VAR_INPUT
    Gr               : usint;  (*The command can be grouped for sending for auto mode or manual mode (1..255)*)
    SNo              : usint;  (*Station number of slave device 1 to 247  (0 is broadcast)*)
    FNC              : usint;  (*Command code Modbus 01,02,03,04,05,06,15,16,17,22*)
    StAdr            : uint;  (*Start address of Modbus object 0..65535 (Coil, Inputs, Input registers, Holding registers)*)
    NoPoint          : uint;  (*Number of data types (BOOL or WORD) to be read or written*)
    PtrData          : PTR_TO usint;  (*Pointer to sent or received data !!Warning!! If FNC is equal to 1, 2 or 5 pointer has to be to BOOL or ARRAY OF BOOL*)
  END_VAR
  VAR_IN_OUT
    Cmd              : TCmdStruct;  (*Command, which will be set*)
  END_VAR
END_FUNCTION

TYPE TCmdStructTCP :
  STRUCT  (*Structure for control of Modbus TCP master FB*)
    Gr               : usint;  (*The command can be grouped for sending an auto mode or manual mode..*)
    IP               : string [22];  (*IP address (and port if needed) of slave device (for example '192.168.1.1' or '192.168.1.1:512')*)
    UnitID           : usint;  (*Unit identifier of remote slave device*)
    FNC              : usint;  (*command code Modbus 01,02,03,04,05,06,15,16,17,22*)
    StAdr            : uint;  (*address of Modbus object 0000..65535 (Coil,InpBits,InpRegs,HoldRegs)*)
    NoPoint          : uint;  (*number of data types (BOOL or WORD) to be read or written*)
    PtrData          : udint;  (*pointer to sent or received data (ARRAY[] OF BOOL or ARRAY[] OF INT)*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION ModbusCmdTCP : bool
(*The Function writes communication parameters into array of commands.
  Communication with Modbus slave devices will be controlled by this array.
  This function prepares commands for function block ModbusTCPmas(), fbModbusTCPmas2 and fbModbusUDPmas.
  Function returns TRUE if Gr is not equal to zero*)
  VAR_INPUT
    Gr               : usint;  (*The commands can be grouped for sending at auto mode or manual mode*)
    IP               : string [80];  (*IP address (and port if needed) of slave device*)
    UnitID           : usint;  (*Unit identifier of remote slave device*)
    FNC              : usint;  (*Command code Modbus 01,02,03,04,05,06,15,16,22*)
    StAdr            : uint;  (*Address of Modbus object 0000..65535 (Coil,InpBits,InpRegs,HoldRegs)*)
    NoPoint          : uint;  (*Number of data types (BOOL or WORD) to be read or written 0..9999*)
    PtrData          : PTR_TO usint;  (*Pointer to sent or received data !!Warning!! If FNC is equal to 1, 2 or 5 pointer has to be to BOOL or ARRAY OF BOOL*)
  END_VAR
  VAR_IN_OUT
    Cmd              : TCmdStructTCP;  (*Command, which will be set*)
  END_VAR
END_FUNCTION

VAR_GLOBAL CONSTANT
 ModbusRTUlib_MDBErrorStrings {HIDDEN} : ARRAY [0..24] OF string [40] :=  [
    'No error                                ',   //0
    'Response with other slave address       ',   //1 +128 Response with other station number of slave device
    'Response with other FNC                 ',   //2 +128 Response with other FNC
    'Checksum error in reception             ',   //3 +128 Checksum error in reception
    'Unknown FNC in transmit command         ',   //4 +128 Unknown FNC in transmit command
    'Response with Unknown FNC               ',   //5 +128 Response with Unknown FNC
    '                                        ',   //6 +128
    'Response Timeout Error                  ',   //7 +128 Response Timeout Error
    '                                        ',   //8 +128
    'Exception: ILLEGAL FUNCTION             ',   //1 +136 Exception from slave device
    'Exception: ILLEGAL DATA ADDRESS         ',   //2 +136 Exception from slave device
    'Exception: ILLEGAL DATA VALUE           ',   //3 +136 Exception from slave device
    'Exception: SLAVE DEVICE FAILURE         ',   //4 +136 Exception from slave device
    'Exception: ACKNOWLEDGE                  ',   //5 +136 Exception from slave device
    'Exception: SLAVE DEVICE BUSY            ',   //6 +136 Exception from slave device
    '                                        ',   //7 +136
    'Exception: MEMORY PARITY ERROR          ',   //8 +136 Exception from slave device
    '                                        ',   //9 +136
    'Exception: GATEWAY PATH UNAVAILABLE     ',   //A +136 Exception from slave device
    'GATEWAY TARGET DEVICE FAILED TO RESPOND ',   //B +136 Exception from slave device
    'Invalid parameter chanCode              ',   //20+128 Channel can be ETH1_uni0, ..., ETH1_uni7 only
    'Can not establish a TCP connection      ',   //21+128
    'Invalid IP address of slave device      ',   //22+128 IP address can not be 0.0.0.0
    'Change of IP address failed             ',   //23+128 IP address can not be changed
    'Unknown ERROR                           '];
 GrMan : usint :=  0;  (*Group number reserved for manual control*)
 GrInit : usint :=  255;  (*Group number reserved for initialization commands*)
 MDB_FNC_ReadCoilStatus : usint :=  01;  (*Read Coil Status*)
 MDB_FNC_ReadInputStatus : usint :=  02;  (*Read Input Status*)
 MDB_FNC_ReadHoldingRegisters : usint :=  03;  (*Read Holding Registers*)
 MDB_FNC_ReadInputRegisters : usint :=  04;  (*Read Input Registers*)
 MDB_FNC_ForceSingleCoil : usint :=  05;  (*Force Single Coil*)
 MDB_FNC_PresetSingleRegister : usint :=  06;  (*Preset Single Register*)
 MDB_FNC_ReadExceptionStatus : usint :=  07;  (*Read Exception Status*)
 MDB_FNC_Diagnostics : usint :=  08;  (*Diagnostics*)
 MDB_FNC_ForceMultipleCoils : usint :=  15;  (*Force Multiple Coils*)
 MDB_FNC_PresetMultipleRegisters : usint :=  16;  (*Preset Multiple Registers*)
 MDB_FNC_ReportSlaveID : usint :=  17;  (*Report Slave ID*)
 MDB_FNC_MaskWrite : usint :=  22;  (*Mask Write*)

END_VAR

__DECL FUNCTION GetModbusErrTxt : bool
(*Converts error code returned by function blocks fbModbusRTUslave, fbModbusTCPslave, ModbusRTUmas, ModbusTCPmas to text description in English language
  Function returns true if ErrorCode is not equal to zero*)
  VAR_INPUT
    ErrorCode        : usint;  (*Error code*)
  END_VAR
  VAR_IN_OUT
    ErrTxt           : string [80];  (*Error description*)
  END_VAR
END_FUNCTION

TYPE ModbusRTUlib_TStateMB {HIDDEN} : 
  (StartMB,
   SndMB,
   SndMBt,
   WaitRespMB,
   RecMB,
   ErrMB,
   DelayMB 
  );
END_TYPE

__DECL FUNCTION_BLOCK ModbusRTUmas
(*Communicates with the slave devices by protocol Modbus RTU.*)
  VAR_INPUT
    EN               : bool;  (*Enable*)
    GrSel            : usint;  (*Select the sequence of sending commands defined by array of commands of type TCmdStruct.*)
    CmdNo            : sint;  (*Command number in array of commands of type TCmdStruct to be send in manual mode. In auto mode, this is ignored.*)
    Start            : bool R_EDGE;  (*Sends command defined by CmdNo in manual mode. In auto mode, this is ignored.*)
    MaxCmd           : sint;  (*Total number of commands in an array.*)
    chanCode         : uint;  (*Channel code (CH1_uni, ..., CH10_uni)*)
    Endian           : bool;  (*Storage of word object in communication; BigEndian = 0, LittleEndian = 1*)
    MBtimeOut        : time :=  T#2s;  (*ModBus time out (default=2[sec])*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*communication command was completed succesfully (R_Edge pulse)*)
    LastCmd          : sint;  (*Index of command which is recently executed. 0=none,[1..MaxRec]*)
    ErrCode          : usint;  (*Error code*)
  END_VAR
  VAR_IN_OUT
    Commands         : TCmdStruct;  (*Array of commands to manage Modbus communications*)
  END_VAR
  VAR
    SendTo           : fbSendTo;
    RecvFrom         : fbRecvFrom;
    DataR            : ARRAY [0..261] OF usint;  (*reciv data    !!! // Byd rev.1.7*)
    NUMR             : uint;  (*number of reciv data*)
    ERRr             : usint;  (*Error of reciv data*)
    DataT            : ARRAY [0..261] OF usint;  (*transmit data  !!! // Byd rev.1.7*)
    StateMB          : ModbusRTUlib_TStateMB;
    InitMB_Done      : bool;  (*inicialization records was completed*)
    isTcp            : bool;
    RespTimeOut      : TON;
    traNum           : uint;
    autoCmd          : sint;
  END_VAR
END_FUNCTION_BLOCK

TYPE ModbusRTUlib_TStatesMdbTCP :   (*Initialization*)
  (MdbTCP_init,  (*Initialization*)
   MdbTCP_start,  (*Waiting for Start in manual mode, looking for next command in auto mode*)
   MdbTCP_selCommand,  (*Selecting command set by auto or manual mode*)
   MdbTCP_setIPadr,  (*Setting IP address acording to selected command*)
   MdbTCP_estabCon,  (*Establishing connection with selected IP*)
   MdbTCP_sendData,  (*Sending command*)
   MdbTCP_recData,  (*Receiving slave answer*)
   MdbTCP_error   (*Closing connecting after detecting error*)
  );
END_TYPE

__DECL FUNCTION_BLOCK ModbusTCPmas
(*Communicates via selected TCP connection with the slave devices by protocol Modbus TCP.*)
  VAR_INPUT
    EN               : bool;  (*Enable*)
    GrSel            : usint;  (*Select the sequence of sending commands defined by array of commands of type TCmdStructTCP.*)
    CmdNo            : usint;  (*Command number in array of commands of type TCmdStructTCP to be send in manual mode. In auto mode, this is ignored.*)
    Start            : bool R_EDGE;  (*Sends command defined by CmdNo in manual mode. In auto mode, this is ignored.*)
    MaxCmd           : usint;  (*Total number of commands in an array.*)
    chanCode         : uint;  (*Channel code (ETH1_uni0, ..., ETH1_uni7)*)
    Endian           : bool;  (*Storage of word object in communication; BigEndian = 0, LittleEndian = 1*)
    MBtimeOut        : time :=  T#2s;  (*ModBus time out (default=2[sec])*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*Communication command was completed (pulse for 1 PLC cycle)*)
    LastCmd          : usint;  (*Index of command which is recently executed. 0=none,[1..MaxRec]*)
    ErrCode          : usint;  (*Error code*)
    State            : ModbusRTUlib_TStatesMdbTCP;  (*State of communication*)
  END_VAR
  VAR_IN_OUT
    Commands         : TCmdStructTCP;  (*Array of commands to manage communications*)
  END_VAR
  VAR
    initDone         : bool;  (*inicialization records was completed*)
    wasStart         : bool;  (*zachyceni startu*)
    autoCmd          : usint;
    ptr              : PTR_TO TCmdStructTCP;
    newEthAdr        : TRemoteEthAdr;
    localCmd         : TCmdStruct;
    modbusRTU        : ModbusRTUmas :=  (isTcp := 1);
    chkTim           : TON;
    lastState        : ModbusRTUlib_TStatesMdbTCP;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbModbusRTUmas2
(*Communicates with the slave devices by protocol Modbus RTU.*)
  VAR_INPUT
    EN               : bool;  (*Enable*)
    GrSel            : usint;  (*Select the sequence of sending commands defined by array of commands of type TCmdStruct.*)
    CmdNo            : usint;  (*Command number in array of commands of type TCmdStruct to be send in manual mode. In auto mode, this is ignored.*)
    Start            : bool R_EDGE;  (*Sends command defined by CmdNo in manual mode. In auto mode, this is ignored.*)
    MaxCmd           : usint;  (*Total number of commands in an array.*)
    chanCode         : uint;  (*Channel code (CH1_uni, ..., CH10_uni)*)
    Endian           : bool;  (*Storage of word object in communication; BigEndian = 0, LittleEndian = 1*)
    MBtimeOut        : time :=  T#2s;  (*ModBus time out (default=2[sec])*)
    Delay            : time;  (*Delay between received message and new message*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*communication command was completed succesfully (R_Edge pulse)*)
    LastCmd          : usint;  (*Index of command which is recently executed. 0=none,[1..MaxRec]*)
    ErrCode          : usint;  (*Error code*)
  END_VAR
  VAR_IN_OUT
    Commands         : TCmdStruct;  (*Array of commands to manage Modbus communications*)
  END_VAR
  VAR
    SendTo           : fbSendTo;
    RecvFrom         : fbRecvFrom;
    DataR            : ARRAY [0..261] OF usint;  (*reciv data    !!! // Byd rev.1.7*)
    NUMR             : uint;  (*number of reciv data*)
    ERRr             : usint;  (*Error of reciv data*)
    DataT            : ARRAY [0..261] OF usint;  (*transmit data  !!! // Byd rev.1.7*)
    StateMB          : ModbusRTUlib_TStateMB;
    InitMB_Done      : bool;  (*inicialization records was completed*)
    isTcp            : bool;
    RespTimeOut      : TON;
    DelayTimeOut     : TON;
    traNum           : uint;
    autoCmd          : usint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbModbusTCPmas2
(*Communicates via selected TCP connection with the slave devices by protocol Modbus TCP.*)
  VAR_INPUT
    EN               : bool;  (*Enable*)
    GrSel            : usint;  (*Select the sequence of sending commands defined by array of commands of type TCmdStructTCP.*)
    CmdNo            : usint;  (*Command number in array of commands of type TCmdStructTCP to be send in manual mode. In auto mode, this is ignored.*)
    Start            : bool R_EDGE;  (*Sends command defined by CmdNo in manual mode. In auto mode, this is ignored.*)
    MaxCmd           : usint;  (*Total number of commands in an array.*)
    chanCode         : uint;  (*Channel code (ETH1_uni0, ..., ETH1_uni7)*)
    Endian           : bool;  (*Storage of word object in communication; BigEndian = 0, LittleEndian = 1*)
    MBtimeOut        : time :=  T#2s;  (*ModBus time out (default=2[sec])*)
    Delay            : time;  (*Delay between received message and new message*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*Communication command was completed (pulse for 1 PLC cycle)*)
    LastCmd          : usint;  (*Index of command which is recently executed. 0=none,[1..MaxRec]*)
    ErrCode          : usint;  (*Error code*)
    State            : ModbusRTUlib_TStatesMdbTCP;  (*State of communication*)
  END_VAR
  VAR_IN_OUT
    Commands         : TCmdStructTCP;  (*Array of commands to manage communications*)
  END_VAR
  VAR
    initDone         : bool;  (*inicialization records was completed*)
    wasStart         : bool;  (*zachyceni startu*)
    autoCmd          : usint;
    ptr              : PTR_TO TCmdStructTCP;
    newEthAdr        : TRemoteEthAdr;
    localCmd         : TCmdStruct;
    modbusRTU        : fbModbusRTUmas2 :=  (isTcp := 1);
    chkTim           : TON;
    lastState        : ModbusRTUlib_TStatesMdbTCP;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbModbusUDPmas
(*Communicates via selected UDP connection with the slave devices by protocol Modbus UDP.*)
  VAR_INPUT
    EN               : bool;  (*Enable*)
    GrSel            : usint;  (*Select the sequence of sending commands defined by array of commands of type TCmdStructTCP.*)
    CmdNo            : usint;  (*Command number in array of commands of type TCmdStructTCP to be send in manual mode. In auto mode, this is ignored.*)
    Start            : bool R_EDGE;  (*Sends command defined by CmdNo in manual mode. In auto mode, this is ignored.*)
    MaxCmd           : usint;  (*Total number of commands in an array.*)
    chanCode         : uint;  (*Channel code (ETH1_uni0, ..., ETH1_uni7)*)
    Endian           : bool;  (*Storage of word object in communication; BigEndian = 0, LittleEndian = 1*)
    MBtimeOut        : time :=  T#2s;  (*ModBus time out (default=2[sec])*)
    Delay            : time;  (*Delay between received message and new message*)
    localPort        : uint :=  61502;  (*Local port for sending messages, each instance must have different one*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*Communication command was completed (pulse for 1 PLC cycle)*)
    LastCmd          : usint;  (*Index of command which is recently executed. 0=none,[1..MaxRec]*)
    ErrCode          : usint;  (*Error code*)
    State            : ModbusRTUlib_TStatesMdbTCP;  (*State of communication*)
  END_VAR
  VAR_IN_OUT
    Commands         : TCmdStructTCP;  (*Array of commands to manage communications*)
  END_VAR
  VAR
    initDone         : bool;  (*inicialization records was completed*)
    autoCmd          : usint;
    ptr              : PTR_TO TCmdStructTCP;
    newEthAdr        : TRemoteEthAdr;
    localCmd         : TCmdStruct;
    modbusRTU        : fbModbusRTUmas2 :=  (isTcp := 1);
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION fcModbusUdpOff : bool
(*Disables Modbus UDP driver
  The presence of function call in code of user program disables UDP driver. For reenabling driver is necessary to upload code without function call and switch off/on CPM.*)
END_FUNCTION

__DECL FUNCTION fcModbusTcpOff : bool
(*Disables Modbus TCP driver
  The presence of function call in code of user program disables TCP driver. For reenabling driver is necessary to upload code without function call and switch off/on CPM.
  This function overrides setting made by fcModbusUdpOff. For disabling both drivers use fcModbusTcpUdpOff.*)
END_FUNCTION

__DECL FUNCTION fcModbusTcpUdpOff : bool
(*Disables Modbus TCP and UDP driver
  The presence of function call in code of user program disables TCP and UDP driver. For reenabling driver is necessary to upload code without function call and switch off/on CPM.*)
END_FUNCTION

__DECL FUNCTION_BLOCK fbModbusSlave {HIDDEN}
  VAR_INPUT
    Buf              : ARRAY [0..256] OF usint;
    inputsCnt        : uint;  (*Number of inputs (number of BOOLs)*)
    coilsCnt         : uint;  (*Number of coils (number of BOOLs)*)
    inputRegCnt      : uint;  (*Number of input   registers (number of WORDs)*)
    holdingRegCnt    : uint;  (*Number of holding registers (number of WORDs)*)
    Exception        : usint;
    Broadcast        : bool;
  END_VAR
  VAR_OUTPUT
    Read             : bool;
    Write            : bool;
    SendTo_rq        : bool;
    SendTo_lenTx     : uint;
    Addr             : uint;
    Quantity         : uint;
  END_VAR
  VAR_IN_OUT
    inputs           : bool;  (*First input in array (must be BOOL)*)
    coils            : bool;  (*First coil in array (must be BOOL)*)
    inputRegs        : uint;  (*First input register in array*)
    holdingRegs      : uint;  (*First holding register in array*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbModbusRTUslave
(*Interprets Modbus RTU commands on serial channel
     Supported commands:
     01 Read Coils
     02 Read Discrete Inputs
     03 Read Holding Register
     04 Read Input Register
     05 Force Single Coil
     06 Preset Single Register
     15 Force Multiple Coils
     16 Preset Multiple Registers
     22 Mask Write Register
     Number and location of coils, discrete inputs, holding registers and input registers are user defined. Data block can be overlapped.
     Communication speed, data format and parity have to be set according to Modbus master, minimum idle time between receiving and sending messages should be 4 bytes
     Minimum length of receiving zone is 256 bytes.
     Minimum length of transmiting zone  is 255 bytes.*)
  VAR_INPUT
    sAdr             : usint;  (*Address 1-247*)
    chanCode         : uint;  (*Channel code (CH1_uni, ..., CH10_uni)*)
    inputsCnt        : uint;  (*Number of inputs (number of BOOLs)*)
    coilsCnt         : uint;  (*Number of coils (number of BOOLs)*)
    inputRegCnt      : uint;  (*Number of input   registers (number of WORDs)*)
    holdingRegCnt    : uint;  (*Number of holding registers (number of WORDs)*)
  END_VAR
  VAR_OUTPUT
    read             : bool;  (*Data was read*)
    write            : bool;  (*New data was written*)
    brdcst           : bool;  (*Broadcast received*)
    lastCmd          : usint;  (*Last command received*)
    lastAddr         : uint;  (*Last address read/written*)
    lastQuantity     : uint;  (*Last quantity of object read/written*)
    err              : bool;  (*Error*)
    errCode          : usint;  (*Error code*)
    msgCnt           : udint;  (*Processed message count*)
    errCnt           : udint;  (*Error count (crc, parity,..)*)
    excCnt           : udint;  (*Exception count*)
  END_VAR
  VAR_IN_OUT
    inputs           : bool;  (*First input in array (must be BOOL)*)
    coils            : bool;  (*First coil in array (must be BOOL)*)
    inputRegs        : uint;  (*First input register in array*)
    holdingRegs      : uint;  (*First holding register in array*)
  END_VAR
  VAR
    RecvFrom         : fbRecvFrom;
    SendTo           : fbSendTo;
    Mdb              : fbModbusSlave;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbModbusTCPslave
(*Interprets Modbus RTU commands on TCP connection
     Supported commands:
     01 Read Coils
     02 Read Discrete Inputs
     03 Read Holding Register
     04 Read Input Register
     05 Write Single Coil
     06 Write Single Register
     15 Write Multiple Coils
     16 Write Multiple registers
     22 Mask Write Register
     Number and location of coils, discrete inputs, holding registers and input registers are user defined. Data block can be overlapped.
     TCP connection has to TCP slave, local port is set by function block.
     Minimum length of receiving zone is 259 bytes.
     Minimum length of transmiting zone  is 259 bytes.
     Function block disable default Modbus TCP driver.*)
  VAR_INPUT
    UnitID           : usint;  (*Unit identifier of slave device*)
    chanCode         : uint;  (*Channel code (CH1_uni, ..., CH10_uni)*)
    port             : uint :=  502;  (*Local port number (502)*)
    inputsCnt        : uint;  (*Number of inputs (number of BOOLs)*)
    coilsCnt         : uint;  (*Number of coils (number of BOOLs)*)
    inputRegCnt      : uint;  (*Number of input   registers (number of WORDs)*)
    holdingRegCnt    : uint;  (*Number of holding registers (number of WORDs)*)
  END_VAR
  VAR_OUTPUT
    read             : bool;  (*Data was read*)
    write            : bool;  (*New data was written*)
    established      : bool;  (*TCP connection established*)
    lastCmd          : usint;  (*Last command received*)
    lastAddr         : uint;  (*Last address read/written*)
    lastQuantity     : uint;  (*Last quantity of object read/written*)
    err              : bool;  (*Error*)
    errCode          : usint;  (*Error code*)
    msgCnt           : udint;  (*Processed message count*)
    errCnt           : udint;  (*Error count*)
    excCnt           : udint;  (*Exception count*)
  END_VAR
  VAR_IN_OUT
    inputs           : bool;  (*First input in array (must be BOOL)*)
    coils            : bool;  (*First coil in array (must be BOOL)*)
    inputRegs        : uint;  (*First input register in array*)
    holdingRegs      : uint;  (*First holding register in array*)
  END_VAR
  VAR
    RecvFrom         : fbRecvFrom;
    SendTo           : fbSendTo;
    TrascactionIndent : uint;
    ProtocolIndent   : uint;
    Length           : uint;
    Mdb              : fbModbusSlave;
  END_VAR
END_FUNCTION_BLOCK



